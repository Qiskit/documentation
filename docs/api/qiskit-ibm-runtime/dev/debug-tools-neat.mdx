---
title: Neat (dev version)
description: API reference for qiskit_ibm_runtime.debug_tools.Neat in the dev version of qiskit-ibm-runtime
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit_ibm_runtime.debug_tools.Neat
---

# Neat

<Class id="qiskit_ibm_runtime.debug_tools.Neat" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/main/qiskit_ibm_runtime/debug_tools/neat.py#L36-L276" signature="Neat(backend, noise_model=None)" modifiers="class">
  Bases: `object`

  A class to help understand the expected performance of estimator jobs.

  The “Noisy Estimator Analyzer Tool” (or “NEAT”) is a convenience tool that users of the `Estimator` primitive can employ to analyze and predict the performance of their queries. Its simulate method uses `qiskit-aer` to simulate the estimation task classically efficiently, either in ideal conditions or in the presence of noise. The simulations’ results can be compared with other simulation results or with primitive results results to draw custom figures of merit.

  **Parameters**

  *   **backend** ([*BackendV2*](/docs/api/qiskit/qiskit.providers.BackendV2)) – A backend.
  *   **noise\_model** ([*NoiseModel*](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html#qiskit_aer.noise.NoiseModel "(in Qiskit Aer v0.17.1)") *| None*) – A noise model for the operations of the given backend. If `None`, it defaults to the noise model generated by `NoiseModel.from_backend()`.

  ## Attributes

  ### noise\_model

  <Attribute id="qiskit_ibm_runtime.debug_tools.Neat.noise_model">
    The noise model used by this analyzer tool for the noisy simulations.
  </Attribute>

  ## Methods

  ### backend

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.backend" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/main/qiskit_ibm_runtime/debug_tools/neat.py#L113-L117" signature="backend()">
    The backend used by this analyzer tool.

    **Return type**

    [*BackendV2*](/docs/api/qiskit/qiskit.providers.BackendV2)
  </Function>

  ### ideal\_sim

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.ideal_sim" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/main/qiskit_ibm_runtime/debug_tools/neat.py#L173-L208" signature="ideal_sim(pubs, cliffordize=False, seed_simulator=None, precision=0)">
    Perform an ideal, noiseless simulation of the estimator task specified by `pubs`.

    This function uses `qiskit-aer`’s `Estimator` class to simulate the estimation task classically.

    <Admonition title="Note" type="note">
      To ensure scalability, every circuit in `pubs` is required to be a Clifford circuit, so that it can be simulated efficiently regardless of its size. For estimation tasks that involve non-Clifford circuits, the recommended workflow consists of mapping the non-Clifford circuits to the nearest Clifford circuits using the `ConvertISAToClifford` transpiler pass, or equivalently, to use the Neat’s [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") convenience method. Alternatively, setting `cliffordize` to `True` ensures that the [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") method is applied automatically to the given `pubs` prior to the simulation.
    </Admonition>

    **Parameters**

    *   **pubs** (*Sequence\[EstimatorPub | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]] | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes], Mapping\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str | Tuple\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str, ...], \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | str | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]]] | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes], Mapping\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str | Tuple\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str, ...], \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | str | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]], Real]]*) – The PUBs specifying the estimation task of interest.
    *   **cliffordize** (*bool*) – Whether or not to automatically apply the `ConvertISAToClifford` transpiler pass to the given `pubs` before performing the simulations.
    *   **seed\_simulator** (*int | None*) – A seed for the simulator.
    *   **precision** (*float*) – The target precision for the estimates of each expectation value in the returned results.

    **Returns**

    The results of the simulation.

    **Return type**

    [*NeatResult*](debug-tools-neat-result "qiskit_ibm_runtime.debug_tools.neat_results.NeatResult")
  </Function>

  ### noisy\_sim

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.noisy_sim" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/main/qiskit_ibm_runtime/debug_tools/neat.py#L210-L245" signature="noisy_sim(pubs, cliffordize=False, seed_simulator=None, precision=0)">
    Perform a noisy simulation of the estimator task specified by `pubs`.

    This function uses `qiskit-aer`’s `Estimator` class to simulate the estimation task classically.

    <Admonition title="Note" type="note">
      To ensure scalability, every circuit in `pubs` is required to be a Clifford circuit, so that it can be simulated efficiently regardless of its size. For estimation tasks that involve non-Clifford circuits, the recommended workflow consists of mapping the non-Clifford circuits to the nearest Clifford circuits using the `ConvertISAToClifford` transpiler pass, or equivalently, to use the Neat’s [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") convenience method. Alternatively, setting `cliffordize` to `True` ensures that the [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") method is applied automatically to the given `pubs` prior to the simulation.
    </Admonition>

    **Parameters**

    *   **pubs** (*Sequence\[EstimatorPub | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]] | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes], Mapping\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str | Tuple\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str, ...], \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | str | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]]] | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes], Mapping\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str | Tuple\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str, ...], \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | str | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]], Real]]*) – The PUBs specifying the estimation task of interest.
    *   **cliffordize** (*bool*) – Whether or not to automatically apply the `ConvertISAToClifford` transpiler pass to the given `pubs` before performing the simulations.
    *   **seed\_simulator** (*int | None*) – A seed for the simulator.
    *   **precision** (*float*) – The target precision for the estimates of each expectation value in the returned results.

    **Returns**

    The results of the simulation.

    **Return type**

    [*NeatResult*](debug-tools-neat-result "qiskit_ibm_runtime.debug_tools.neat_results.NeatResult")
  </Function>

  ### to\_clifford

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.to_clifford" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/main/qiskit_ibm_runtime/debug_tools/neat.py#L247-L273" signature="to_clifford(pubs)">
    Return the cliffordized version of the given `pubs`.

    This convenience method runs the `ConvertISAToClifford` transpiler pass on the PUBs’ circuits.

    **Parameters**

    **pubs** (*Sequence\[EstimatorPub | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]] | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes], Mapping\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str | Tuple\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str, ...], \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | str | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]]] | Tuple\[*[*QuantumCircuit*](/docs/api/qiskit/qiskit.circuit.QuantumCircuit)*, str |* [*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)  *|*[*SparsePauliOp*](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp)  *|*[*SparseObservable*](/docs/api/qiskit/qiskit.quantum_info.SparseObservable)  *| Mapping\[str |*[*Pauli*](/docs/api/qiskit/qiskit.quantum_info.Pauli)*, float] | \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes], Mapping\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str | Tuple\[*[*Parameter*](/docs/api/qiskit/qiskit.circuit.Parameter) *| str, ...], \_Buffer | \_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]] | \_NestedSequence\[\_SupportsArray\[*[*dtype*](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype)*\[Any]]] | bool | int | float | complex | str | bytes | \_NestedSequence\[bool | int | float | complex | str | bytes]], Real]]*) – The PUBs to turn into Clifford PUBs.

    **Returns**

    The Clifford PUBs.

    **Return type**

    list\[*EstimatorPub*]
  </Function>
</Class>

