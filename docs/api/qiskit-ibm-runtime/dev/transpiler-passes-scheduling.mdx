---
title: scheduling (dev version)
description: API reference for qiskit_ibm_runtime.transpiler.passes.scheduling in the dev version of qiskit-ibm-runtime
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit_ibm_runtime.transpiler.passes.scheduling
---

<span id="transpiler-scheduling-passes-qiskit-ibm-runtime-transpiler-passes-scheduling" />

<span id="module-qiskit_ibm_runtime.transpiler.passes.scheduling" />

# Transpiler scheduling passes

`qiskit_ibm_runtime.transpiler.passes.scheduling`

A collection of scheduling passes for working with IBM Quantum’s next-generation backends that support advanced “dynamic circuit” capabilities. Ie., circuits with support for classical control-flow/feedback based off of measurement results. For more information on dynamic circuits, see our [Classical feedforward and control flow](/docs/guides/classical-feedforward-and-control-flow) guide.

<Admonition title="Warning" type="caution">
  You should not mix these scheduling passes with Qiskit’s built in scheduling passes as they will negatively interact with the scheduling routines for dynamic circuits. This includes setting `scheduling_method` in [`transpile()`](/docs/api/qiskit/compiler#qiskit.compiler.transpile "(in Qiskit v2.1)") or `generate_preset_pass_manager()`.
</Admonition>

## Classes

|                                                                                                                                                                                                 |                                                                                                                                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [`BlockBasePadder`](transpiler-passes-scheduling-block-base-padder "qiskit_ibm_runtime.transpiler.passes.scheduling.BlockBasePadder")                                                           | The base class of padding pass.                                                                                                                              |
| [`ALAPScheduleAnalysis`](transpiler-passes-scheduling-alap-schedule-analysis "qiskit_ibm_runtime.transpiler.passes.scheduling.ALAPScheduleAnalysis")                                            | Dynamic circuits as-late-as-possible (ALAP) scheduling analysis pass.                                                                                        |
| [`ASAPScheduleAnalysis`](transpiler-passes-scheduling-asap-schedule-analysis "qiskit_ibm_runtime.transpiler.passes.scheduling.ASAPScheduleAnalysis")                                            | Dynamic circuits as-soon-as-possible (ASAP) scheduling analysis pass.                                                                                        |
| [`DynamicCircuitInstructionDurations`](transpiler-passes-scheduling-dynamic-circuit-instruction-durations "qiskit_ibm_runtime.transpiler.passes.scheduling.DynamicCircuitInstructionDurations") | For dynamic circuits the IBM Qiskit backend currently reports instruction durations that differ compared with those required for the legacy Qobj-based path. |
| [`PadDelay`](transpiler-passes-scheduling-pad-delay "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDelay")                                                                                 | Padding idle time with Delay instructions.                                                                                                                   |
| [`PadDynamicalDecoupling`](transpiler-passes-scheduling-pad-dynamical-decoupling "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDynamicalDecoupling")                                      | Dynamical decoupling insertion pass for IBM dynamic circuit backends.                                                                                        |

## Example usage

Below we demonstrate how to schedule and pad a teleportation circuit with delays for a dynamic circuit backend’s execution model:

```python
from qiskit.circuit import ClassicalRegister, QuantumCircuit, QuantumRegister
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passmanager import PassManager

from qiskit_ibm_runtime.transpiler.passes.scheduling import DynamicCircuitInstructionDurations
from qiskit_ibm_runtime.transpiler.passes.scheduling import ALAPScheduleAnalysis
from qiskit_ibm_runtime.transpiler.passes.scheduling import PadDelay
from qiskit_ibm_runtime.fake_provider import FakeJakartaV2

backend = FakeJakartaV2()

# Use this duration class to get appropriate durations for dynamic
# circuit backend scheduling
durations = DynamicCircuitInstructionDurations.from_backend(backend)
# Generate the main Qiskit transpile passes.
pm = generate_preset_pass_manager(optimization_level=1, backend=backend)
# Configure the as-late-as-possible scheduling pass
pm.scheduling = PassManager([ALAPScheduleAnalysis(durations), PadDelay(durations)])

qr = QuantumRegister(3)
crz = ClassicalRegister(1, name="crz")
crx = ClassicalRegister(1, name="crx")
result = ClassicalRegister(1, name="result")

teleport = QuantumCircuit(qr, crz, crx, result, name="Teleport")

teleport.h(qr[1])
teleport.cx(qr[1], qr[2])
teleport.cx(qr[0], qr[1])
teleport.h(qr[0])
teleport.measure(qr[0], crz)
teleport.measure(qr[1], crx)
with teleport.if_test((crz, 1)):
    teleport.z(qr[2])
with teleport.if_test((crx, 1)):
    teleport.x(qr[2])
teleport.measure(qr[2], result)

# Transpile.
scheduled_teleport = pm.run(teleport)

scheduled_teleport.draw(output="mpl", style="iqp")
```

![Circuit diagram output by the previous code.](/docs/images/api/qiskit-ibm-runtime/dev/qiskit_ibm_runtime-transpiler-passes-scheduling-1.avif)

Instead of padding with delays we may also insert a dynamical decoupling sequence using the [`PadDynamicalDecoupling`](transpiler-passes-scheduling-pad-dynamical-decoupling "qiskit_ibm_runtime.transpiler.passes.scheduling.PadDynamicalDecoupling") pass as shown below:

```python
from qiskit.circuit.library import XGate

from qiskit_ibm_runtime.transpiler.passes.scheduling import PadDynamicalDecoupling


dd_sequence = [XGate(), XGate()]

pm = generate_preset_pass_manager(optimization_level=1, backend=backend)
pm.scheduling = PassManager(
    [
        ALAPScheduleAnalysis(durations),
        PadDynamicalDecoupling(durations, dd_sequence),
    ]
)

dd_teleport = pm.run(teleport)

dd_teleport.draw(output="mpl", style="iqp")
```

![Circuit diagram output by the previous code.](/docs/images/api/qiskit-ibm-runtime/dev/qiskit_ibm_runtime-transpiler-passes-scheduling-2.avif)

When compiling a circuit with Qiskit, it is more efficient and more robust to perform all the transformations in a single transpilation. This has been done above by extending Qiskit’s preset pass managers. For example, Qiskit’s [`transpile()`](/docs/api/qiskit/compiler#qiskit.compiler.transpile "(in Qiskit v2.1)") function internally builds its pass set by using `generate_preset_pass_manager()`. This returns instances of [`StagedPassManager`](/docs/api/qiskit/qiskit.transpiler.StagedPassManager "(in Qiskit v2.1)"), which can be extended.

