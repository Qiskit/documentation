---
title: Neat
description: API reference for qiskit_ibm_runtime.debug_tools.Neat
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit_ibm_runtime.debug_tools.Neat
---

# Neat

<Class id="qiskit_ibm_runtime.debug_tools.Neat" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.31/qiskit_ibm_runtime/debug_tools/neat.py#L37-L277" signature="Neat(backend, noise_model=None)" modifiers="class">
  A class to help understand the expected performance of estimator jobs.

  The “Noisy Estimator Analyzer Tool” (or “NEAT”) is a convenience tool that users of the `Estimator` primitive can employ to analyze and predict the performance of their queries. Its simulate method uses `qiskit-aer` to simulate the estimation task classically efficiently, either in ideal conditions or in the presence of noise. The simulations’ results can be compared with other simulation results or with primitive results results to draw custom figures of merit.

  **Parameters**

  *   **backend** ([`BackendV2`](/api/qiskit/qiskit.providers.BackendV2 "(in Qiskit v1.2)")) – A backend.
  *   **noise\_model** (`Optional`\[[`NoiseModel`](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html#qiskit_aer.noise.NoiseModel "(in Qiskit Aer v0.15.0)")]) – A noise model for the operations of the given backend. If `None`, it defaults to the noise model generated by `NoiseModel.from_backend()`.

  ## Attributes

  ### noise\_model

  <Attribute id="qiskit_ibm_runtime.debug_tools.Neat.noise_model">
    The noise model used by this analyzer tool for the noisy simulations.

    **Return type**

    [`NoiseModel`](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html#qiskit_aer.noise.NoiseModel "(in Qiskit Aer v0.15.0)")
  </Attribute>

  ## Methods

  ### backend

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.backend" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.31/qiskit_ibm_runtime/debug_tools/neat.py#L114-L118" signature="backend()">
    The backend used by this analyzer tool.

    **Return type**

    [`BackendV2`](/api/qiskit/qiskit.providers.BackendV2 "(in Qiskit v1.2)")
  </Function>

  ### ideal\_sim

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.ideal_sim" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.31/qiskit_ibm_runtime/debug_tools/neat.py#L174-L209" signature="ideal_sim(pubs, cliffordize=False, seed_simulator=None, precision=0)">
    Perform an ideal, noiseless simulation of the estimator task specified by `pubs`.

    This function uses `qiskit-aer`’s `Estimator` class to simulate the estimation task classically.

    <Admonition title="Note" type="note">
      To ensure scalability, every circuit in `pubs` is required to be a Clifford circuit, so that it can be simulated efficiently regardless of its size. For estimation tasks that involve non-Clifford circuits, the recommended workflow consists of mapping the non-Clifford circuits to the nearest Clifford circuits using the `ConvertISAToClifford` transpiler pass, or equivalently, to use the Neat’s [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") convenience method. Alternatively, setting `cliffordize` to `True` ensures that the [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") method is applied automatically to the given `pubs` prior to the simulation.
    </Admonition>

    **Parameters**

    *   **pubs** (`Sequence`\[`Union`\[`EstimatorPub`, `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]], `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]], `Mapping`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`, `Tuple`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`], `...`]], `Union`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `str`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]]], `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]], `Mapping`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`, `Tuple`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`], `...`]], `Union`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `str`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]], `Real`]]]) – The PUBs specifying the estimation task of interest.
    *   **cliffordize** (`bool`) – Whether or not to automatically apply the `ConvertISAToClifford` transpiler pass to the given `pubs` before performing the simulations.
    *   **seed\_simulator** (`Optional`\[`int`]) – A seed for the simulator.
    *   **precision** (`float`) – The target precision for the estimates of each expectation value in the returned results.

    **Return type**

    [`NeatResult`](qiskit_ibm_runtime.debug_tools.NeatResult "qiskit_ibm_runtime.debug_tools.neat_results.NeatResult")

    **Returns**

    The results of the simulation.
  </Function>

  ### noisy\_sim

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.noisy_sim" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.31/qiskit_ibm_runtime/debug_tools/neat.py#L211-L246" signature="noisy_sim(pubs, cliffordize=False, seed_simulator=None, precision=0)">
    Perform a noisy simulation of the estimator task specified by `pubs`.

    This function uses `qiskit-aer`’s `Estimator` class to simulate the estimation task classically.

    <Admonition title="Note" type="note">
      To ensure scalability, every circuit in `pubs` is required to be a Clifford circuit, so that it can be simulated efficiently regardless of its size. For estimation tasks that involve non-Clifford circuits, the recommended workflow consists of mapping the non-Clifford circuits to the nearest Clifford circuits using the `ConvertISAToClifford` transpiler pass, or equivalently, to use the Neat’s [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") convenience method. Alternatively, setting `cliffordize` to `True` ensures that the [`to_clifford()`](#qiskit_ibm_runtime.debug_tools.Neat.to_clifford "qiskit_ibm_runtime.debug_tools.Neat.to_clifford") method is applied automatically to the given `pubs` prior to the simulation.
    </Admonition>

    **Parameters**

    *   **pubs** (`Sequence`\[`Union`\[`EstimatorPub`, `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]], `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]], `Mapping`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`, `Tuple`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`], `...`]], `Union`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `str`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]]], `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]], `Mapping`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`, `Tuple`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`], `...`]], `Union`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `str`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]], `Real`]]]) – The PUBs specifying the estimation task of interest.
    *   **cliffordize** (`bool`) – Whether or not to automatically apply the `ConvertISAToClifford` transpiler pass to the given `pubs` before performing the simulations.
    *   **seed\_simulator** (`Optional`\[`int`]) – A seed for the simulator.
    *   **precision** (`float`) – The target precision for the estimates of each expectation value in the returned results.

    **Return type**

    [`NeatResult`](qiskit_ibm_runtime.debug_tools.NeatResult "qiskit_ibm_runtime.debug_tools.neat_results.NeatResult")

    **Returns**

    The results of the simulation.
  </Function>

  ### to\_clifford

  <Function id="qiskit_ibm_runtime.debug_tools.Neat.to_clifford" github="https://github.com/Qiskit/qiskit-ibm-runtime/tree/stable/0.31/qiskit_ibm_runtime/debug_tools/neat.py#L248-L274" signature="to_clifford(pubs)">
    Return the cliffordized version of the given `pubs`.

    This convenience method runs the `ConvertISAToClifford` transpiler pass on the PUBs’ circuits.

    **Parameters**

    **pubs** (`Sequence`\[`Union`\[`EstimatorPub`, `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]], `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]], `Mapping`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`, `Tuple`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`], `...`]], `Union`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `str`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]]], `Tuple`\[[`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "(in Qiskit v1.2)"), `Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)"), [`SparsePauliOp`](/api/qiskit/qiskit.quantum_info.SparsePauliOp "(in Qiskit v1.2)"), `Mapping`\[`Union`\[`str`, [`Pauli`](/api/qiskit/qiskit.quantum_info.Pauli "(in Qiskit v1.2)")], `float`], `_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]], `Mapping`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`, `Tuple`\[`Union`\[[`Parameter`](/api/qiskit/qiskit.circuit.Parameter "(in Qiskit v1.2)"), `str`], `...`]], `Union`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]], `_NestedSequence`\[`_SupportsArray`\[[`dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.1)")\[`Any`]]], `bool`, `int`, `float`, `complex`, `str`, `bytes`, `_NestedSequence`\[`Union`\[`bool`, `int`, `float`, `complex`, `str`, `bytes`]]]], `Real`]]]) – The PUBs to turn into Clifford PUBs.

    **Return type**

    `list`\[`EstimatorPub`]

    **Returns**

    The Clifford PUBs.
  </Function>
</Class>

