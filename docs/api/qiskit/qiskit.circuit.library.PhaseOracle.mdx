---
title: PhaseOracle (latest version)
description: API reference for qiskit.circuit.library.PhaseOracle in the latest version of qiskit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.PhaseOracle
---

# PhaseOracle

<Class id="qiskit.circuit.library.PhaseOracle" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/stable/2.3/qiskit/circuit/library/phase_oracle.py#L23-L138" signature="qiskit.circuit.library.PhaseOracle(expression, var_order=None)" modifiers="class">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.quantumcircuit.QuantumCircuit")

  Phase Oracle.

  The Phase Oracle object constructs circuits for any arbitrary input logical expressions. A logical expression is composed of logical operators & (logical AND), | (logical OR), \~ (logical NOT), and ^ (logical XOR). as well as symbols for literals (variables). For example, ‘a & b’, and (v0 | \~v1) & (\~v2 & v3) are both valid string representation of boolean logical expressions.

  A phase oracle for a boolean function f(x) performs the following quantum operation:

$$
|x\rangle \mapsto (-1)^{f(x)}|x\rangle
$$

  For convenience, this oracle, in addition to parsing arbitrary logical expressions, also supports input strings in the [DIMACS CNF format](https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html), which is the standard format for specifying SATisfiability (SAT) problem instances in [Conjunctive Normal Form (CNF)](https://en.wikipedia.org/wiki/Conjunctive_normal_form), which is a conjunction of one or more clauses, where a clause is a disjunction of one or more literals. See `qiskit.circuit.library.phase_oracle.PhaseOracle.from_dimacs_file()`.

  From 16 variables on, possible performance issues should be expected when using the default synthesizer.

  <Admonition title="Deprecated since version 2.2" type="danger">
    The class `qiskit.circuit.library.phase_oracle.PhaseOracle` is deprecated as of Qiskit 2.2. It will be removed in Qiskit 3.0. Use the class qiskit.circuit.library.PhaseOracleGate instead.
  </Admonition>

  **Parameters**

  *   **expression** ([*str*](https://docs.python.org/3/library/stdtypes.html#str) *| BooleanExpression*) – A Python-like boolean expression string or a BooleanExpression object.
  *   **var\_order** ([*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str)*] | None*) – A list with the order in which variables will be created. (default: by appearance)

  ## Attributes

  ### name

  <Attribute id="qiskit.circuit.library.PhaseOracle.name" attributeTypeHint="str">
    A human-readable name for the circuit.

    **Example**

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2, 2, name="my_circuit")
    print(qc.name)
    ```

    ```text
    my_circuit
    ```
  </Attribute>

  ## Methods

  ### evaluate\_bitstring

  <Function id="qiskit.circuit.library.PhaseOracle.evaluate_bitstring" github="https://github.com/Qiskit/qiskit/tree/stable/2.3/qiskit/circuit/library/phase_oracle.py#L79-L90" signature="evaluate_bitstring(bitstring)">
    Evaluate the oracle on a bitstring. This evaluation is done classically without any quantum circuit.

    **Parameters**

    **bitstring** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The bitstring for which to evaluate. The input bitstring is expected to be in little-endian order.

    **Returns**

    True if the bitstring is a good state, False otherwise.

    **Return type**

    [bool](https://docs.python.org/3/library/functions.html#bool)
  </Function>

  ### from\_dimacs\_file

  <Function id="qiskit.circuit.library.PhaseOracle.from_dimacs_file" github="https://github.com/Qiskit/qiskit/tree/stable/2.3/qiskit/circuit/library/phase_oracle.py#L92-L138" signature="from_dimacs_file(filename)" modifiers="classmethod">
    Create a PhaseOracle from the string in the DIMACS format.

    It is possible to build a PhaseOracle from a file in [DIMACS CNF format](https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html), which is the standard format for specifying SATisfiability (SAT) problem instances in [Conjunctive Normal Form (CNF)](https://en.wikipedia.org/wiki/Conjunctive_normal_form), which is a conjunction of one or more clauses, where a clause is a disjunction of one or more literals.

    The following is an example of a CNF expressed in the DIMACS format:

    ```text
    c DIMACS CNF file with 3 satisfying assignments: 1 -2 3, -1 -2 -3, 1 2 -3.
    p cnf 3 5
    -1 -2 -3 0
    1 -2 3 0
    1 2 -3 0
    1 -2 -3 0
    -1 2 3 0
    ```

    The first line, following the c character, is a comment. The second line specifies that the CNF is over three boolean variables — let us call them $x_1, x_2, x_3$, and contains five clauses. The five clauses, listed afterwards, are implicitly joined by the logical AND operator, $\land$, while the variables in each clause, represented by their indices, are implicitly disjoined by the logical OR operator, $lor$. The $-$ symbol preceding a boolean variable index corresponds to the logical NOT operator, $lnot$. Character 0 (zero) marks the end of each clause. Essentially, the code above corresponds to the following CNF:

    $(\lnot x_1 \lor \lnot x_2 \lor \lnot x_3) \land (x_1 \lor \lnot x_2 \lor x_3) \land (x_1 \lor x_2 \lor \lnot x_3) \land (x_1 \lor \lnot x_2 \lor \lnot x_3) \land (\lnot x_1 \lor x_2 \lor x_3)$.

    **Parameters**

    **filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – A file in DIMACS format.

    **Returns**

    A quantum circuit with a phase oracle.

    **Return type**

    [PhaseOracle](#qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle")
  </Function>
</Class>

