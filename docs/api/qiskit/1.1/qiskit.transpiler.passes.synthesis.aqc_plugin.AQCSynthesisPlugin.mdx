---
title: AQCSynthesisPlugin
description: API reference for qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin
---

# AQCSynthesisPlugin

<Class id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/stable/1.1/qiskit/transpiler/passes/synthesis/aqc_plugin.py#L29-L153" signature="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin" modifiers="class">
  Bases: [`UnitarySynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin")

  An AQC-based Qiskit unitary synthesis plugin.

  This plugin is invoked by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when the `unitary_synthesis_method` parameter is set to `"aqc"`.

  This plugin supports customization and additional parameters can be passed to the plugin by passing a dictionary as the `unitary_synthesis_plugin_config` parameter of the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function.

  Supported parameters in the dictionary:

  **network\_layout (str)**

  Type of network geometry, one of \{`"sequ"`, `"spin"`, `"cart"`, `"cyclic_spin"`, `"cyclic_line"`}. Default value is `"spin"`.

  **connectivity\_type (str)**

  type of inter-qubit connectivity, \{`"full"`, `"line"`, `"star"`}. Default value is `"full"`.

  **depth (int)**

  depth of the CNOT-network, i.e. the number of layers, where each layer consists of a single CNOT-block.

  **optimizer (`Minimizer`)**

  An implementation of the `Minimizer` protocol to be used in the optimization process.

  **seed (int)**

  A random seed.

  **initial\_point ([`ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.0)"))**

  Initial values of angles/parameters to start the optimization process from.

  ## Attributes

  ### max\_qubits

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.max_qubits">
    Maximum number of supported qubits is `14`.
  </Attribute>

  ### min\_qubits

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.min_qubits">
    Minimum number of supported qubits is `3`.
  </Attribute>

  ### supported\_bases

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supported_bases">
    The plugin does not support bases for synthesis.
  </Attribute>

  ### supports\_basis\_gates

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_basis_gates">
    The plugin does not support basis gates and by default it synthesizes a circuit using `["rx", "ry", "rz", "cx"]` gate basis.
  </Attribute>

  ### supports\_coupling\_map

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_coupling_map">
    The plugin does not support coupling maps.
  </Attribute>

  ### supports\_gate\_errors

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_gate_errors">
    The plugin does not support gate errors.
  </Attribute>

  ### supports\_gate\_errors\_by\_qubit

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_gate_errors_by_qubit">
    Return whether the plugin supports taking `gate_errors_by_qubit`

    This differs from `supports_gate_errors`/`gate_errors` by using a different view of the same data. Instead of being keyed by gate name this is keyed by qubit and uses [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") instances to represent gates (instead of gate names).

    `gate_errors_by_qubit` will be a dictionary in the form of `{(qubits,): [Gate, error]}`. For example:

    ```python
    {
    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],
    (0, 1): [CXGate(): 0.012012477900732316]
    }
    ```

    Do note that this dictionary might not be complete or could be empty as it depends on the target backend reporting gate errors on every gate for each qubit. The gate error rates reported in `gate_errors` are provided by the target device `Backend` object and the exact meaning might be different depending on the backend.

    This defaults to False
  </Attribute>

  ### supports\_gate\_lengths

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_gate_lengths">
    The plugin does not support gate lengths.
  </Attribute>

  ### supports\_gate\_lengths\_by\_qubit

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_gate_lengths_by_qubit">
    Return whether the plugin supports taking `gate_lengths_by_qubit`

    This differs from `supports_gate_lengths`/`gate_lengths` by using a different view of the same data. Instead of being keyed by gate name this is keyed by qubit and uses [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") instances to represent gates (instead of gate names)

    `gate_lengths_by_qubit` will be a dictionary in the form of `{(qubits,): [Gate, length]}`. For example:

    ```python
    {
    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],
    (0, 1): [CXGate(): 0.012012477900732316]
    }
    ```

    where the `length` value is in units of seconds.

    Do note that this dictionary might not be complete or could be empty as it depends on the target backend reporting gate lengths on every gate for each qubit.

    This defaults to False
  </Attribute>

  ### supports\_natural\_direction

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_natural_direction">
    The plugin does not support natural direction, it assumes bidirectional two qubit gates.
  </Attribute>

  ### supports\_pulse\_optimize

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_pulse_optimize">
    The plugin does not support optimization of pulses.
  </Attribute>

  ### supports\_target

  <Attribute id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.supports_target">
    Whether the plugin supports taking `target` as an option

    `target` will be a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object representing the target device for the output of the synthesis pass.

    By default this will be `False` since the plugin interface predates the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class. If a plugin returns `True` for this attribute, it is expected that the plugin will use the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") instead of the values passed if any of `supports_gate_lengths`, `supports_gate_errors`, `supports_coupling_map`, and `supports_basis_gates` are set (although ideally all those parameters should contain duplicate information).
  </Attribute>

  ## Methods

  ### run

  <Function id="qiskit.transpiler.passes.synthesis.aqc_plugin.AQCSynthesisPlugin.run" github="https://github.com/Qiskit/qiskit/tree/stable/1.1/qiskit/transpiler/passes/synthesis/aqc_plugin.py#L111-L153" signature="run(unitary, **options)">
    Run synthesis for the given unitary matrix

    **Parameters**

    *   **unitary** ([*numpy.ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.0)")) – The unitary matrix to synthesize to a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object
    *   **options** – The optional kwargs that are passed based on the output the `support_*` methods on the class. Refer to the documentation for these methods on [`UnitarySynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin") to see what the keys and values are.

    **Returns**

    The dag circuit representation of the unitary. Alternatively, you can return a tuple of the form `(dag, wires)` where `dag` is the dag circuit representation of the circuit representation of the unitary and `wires` is the mapping wires to use for [`qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag()`](qiskit.dagcircuit.DAGCircuit#substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag"). If you return a tuple and `wires` is `None` this will behave just as if only a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") was returned. Additionally if this returns `None` no substitution will be made.

    **Return type**

    [DAGCircuit](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit")
  </Function>
</Class>

