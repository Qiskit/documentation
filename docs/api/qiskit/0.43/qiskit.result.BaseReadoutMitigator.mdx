---
title: BaseReadoutMitigator
description: API reference for qiskit.result.BaseReadoutMitigator
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.result.BaseReadoutMitigator
---

# BaseReadoutMitigator

<Class id="qiskit.result.BaseReadoutMitigator" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.24/qiskit/result/mitigation/base_readout_mitigator.py" signature="BaseReadoutMitigator" modifiers="class">
  Bases: `ABC`

  Base readout error mitigator class.

  ## Methods

  <span id="qiskit-result-basereadoutmitigator-expectation-value" />

  ### expectation\_value

  <Function id="qiskit.result.BaseReadoutMitigator.expectation_value" signature="BaseReadoutMitigator.expectation_value(data, diagonal, qubits=None, clbits=None, shots=None)" modifiers="abstract">
    Calculate the expectation value of a diagonal Hermitian operator.

    **Parameters**

    *   **data** ([*Counts*](qiskit.result.Counts "qiskit.result.counts.Counts")) – Counts object to be mitigated.
    *   **diagonal** (*Callable | dict | str |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v1.25)")) – the diagonal operator. This may either be specified as a string containing I,Z,0,1 characters, or as a real valued 1D array\_like object supplying the full diagonal, or as a dictionary, or as Callable.
    *   **qubits** (*Iterable\[int] | None*) – the physical qubits measured to obtain the counts clbits. If None these are assumed to be qubits \[0, …, N-1] for N-bit counts.
    *   **clbits** (*List\[int] | None*) – Optional, marginalize counts to just these bits.
    *   **shots** (*int | None*) – Optional, the total number of shots, if None shots will be calculated as the sum of all counts.

    **Returns**

    The mean and an upper bound of the standard deviation of operator expectation value calculated from the current counts.

    **Return type**

    *Tuple*\[float, float]
  </Function>

  <span id="qiskit-result-basereadoutmitigator-quasi-probabilities" />

  ### quasi\_probabilities

  <Function id="qiskit.result.BaseReadoutMitigator.quasi_probabilities" signature="BaseReadoutMitigator.quasi_probabilities(data, qubits=None, clbits=None, shots=None)" modifiers="abstract">
    Convert counts to a dictionary of quasi-probabilities

    **Parameters**

    *   **data** ([*Counts*](qiskit.result.Counts "qiskit.result.counts.Counts")) – Counts to be mitigated.
    *   **qubits** (*Iterable\[int] | None*) – the physical qubits measured to obtain the counts clbits. If None these are assumed to be qubits \[0, …, N-1] for N-bit counts.
    *   **clbits** (*List\[int] | None*) – Optional, marginalize counts to just these bits.
    *   **shots** (*int | None*) – Optional, the total number of shots, if None shots will be calculated as the sum of all counts.

    **Returns**

    **A dictionary containing pairs of \[output, mean] where “output”**

    is the key in the dictionaries, which is the length-N bitstring of a measured standard basis state, and “mean” is the mean of non-zero quasi-probability estimates.

    **Return type**

    QuasiDistibution
  </Function>
</Class>

