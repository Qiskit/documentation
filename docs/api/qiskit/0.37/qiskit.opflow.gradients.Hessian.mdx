---
title: Hessian (v0.37)
description: API reference for qiskit.opflow.gradients.Hessian in qiskit v0.37
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.opflow.gradients.Hessian
---

# Hessian

<Class id="qiskit.opflow.gradients.Hessian" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.21/qiskit/opflow/gradients/hessian.py" signature="Hessian(hess_method='param_shift', **kwargs)" modifiers="class">
  Bases: [`qiskit.opflow.gradients.hessian_base.HessianBase`](qiskit.opflow.gradients.HessianBase "qiskit.opflow.gradients.hessian_base.HessianBase")

  Compute the Hessian of an expected value.

  **Parameters**

  *   **hess\_method** (`Union`\[`str`, [`CircuitGradient`](qiskit.opflow.gradients.CircuitGradient "qiskit.opflow.gradients.circuit_gradients.circuit_gradient.CircuitGradient")]) – The method used to compute the state/probability gradient. Can be either `'param_shift'` or `'lin_comb'` or `'fin_diff'`. Ignored for gradients w\.r.t observable parameters.
  *   **kwargs** (*dict*) – Optional parameters for a CircuitGradient

  **Raises**

  **ValueError** – If method != `fin_diff` and `epsilon` is not None.

  ## Methods Defined Here

  <span id="qiskit-opflow-gradients-hessian-convert" />

  ### convert

  <Function id="qiskit.opflow.gradients.Hessian.convert" signature="Hessian.convert(operator, params=None)">
    **Parameters**

    *   **operator** ([`OperatorBase`](qiskit.opflow.OperatorBase "qiskit.opflow.operator_base.OperatorBase")) – The operator for which we compute the Hessian
    *   **params** (`Union`\[`Tuple`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], `List`\[`Tuple`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")]], `List`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.parametervector.ParameterVector"), `None`]) – The parameters we are computing the Hessian with respect to Either give directly the tuples/list of tuples for which the second order derivative is to be computed or give a list of parameters to build the full Hessian for those parameters. If not explicitly passed, the full Hessian is constructed. The parameters are then inferred from the operator and sorted by name.

    **Returns**

    An operator whose evaluation yields the Hessian

    **Return type**

    [OperatorBase](qiskit.opflow.OperatorBase "qiskit.opflow.OperatorBase")
  </Function>

  <span id="qiskit-opflow-gradients-hessian-get-hessian" />

  ### get\_hessian

  <Function id="qiskit.opflow.gradients.Hessian.get_hessian" signature="Hessian.get_hessian(operator, params=None)">
    Get the Hessian for the given operator w\.r.t. the given parameters

    **Parameters**

    *   **operator** ([`OperatorBase`](qiskit.opflow.OperatorBase "qiskit.opflow.operator_base.OperatorBase")) – Operator w\.r.t. which we take the Hessian.
    *   **params** (`Union`\[`Tuple`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], `List`\[`Tuple`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")]], `List`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.parametervector.ParameterVector"), `None`]) – Parameters w\.r.t. which we compute the Hessian. If not explicitly passed, the full Hessian is constructed. The parameters are then inferred from the operator and sorted by name.

    **Return type**

    [`OperatorBase`](qiskit.opflow.OperatorBase "qiskit.opflow.operator_base.OperatorBase")

    **Returns**

    Operator which represents the gradient w\.r.t. the given params.

    **Raises**

    *   **ValueError** – If `params` contains a parameter not present in `operator`.
    *   **ValueError** – If `operator` is not parameterized.
    *   [**OpflowError**](qiskit.opflow.OpflowError "qiskit.opflow.OpflowError") – If the coefficient of the operator could not be reduced to 1.
    *   [**OpflowError**](qiskit.opflow.OpflowError "qiskit.opflow.OpflowError") – If the differentiation of a combo\_fn requires JAX but the package is not installed.
    *   **TypeError** – If the operator does not include a StateFn given by a quantum circuit
    *   **TypeError** – If the parameters were given in an unsupported format.
    *   **Exception** – Unintended code is reached
    *   **MissingOptionalLibraryError** – jax not installed
  </Function>

  ## Attributes

  ### hess\_method

  <Attribute id="qiskit.opflow.gradients.Hessian.hess_method">
    Returns `CircuitGradient`.

    **Return type**

    [`CircuitGradient`](qiskit.opflow.gradients.CircuitGradient "qiskit.opflow.gradients.circuit_gradients.circuit_gradient.CircuitGradient")

    **Returns**

    `CircuitGradient`.
  </Attribute>
</Class>

