---
title: gradients (v0.37)
description: API reference for qiskit.opflow.gradients in qiskit v0.37
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit.opflow.gradients
---

<span id="module-qiskit.opflow.gradients" />

<span id="qiskit-opflow-gradients" />

# qiskit.opflow\.gradients

<span id="gradients-qiskit-opflow-gradients" />

## Gradients

`qiskit.opflow.gradients`

Given an operator that represents either a quantum state resp. an expectation value, the gradient framework enables the evaluation of gradients, natural gradients, Hessians, as well as the Quantum Fisher Information.

Suppose a parameterized quantum state |ψ(θ)〉 = V(θ)|ψ〉 with input state |ψ〉 and parameterized Ansatz V(θ), and an Operator O(ω).

**Gradients**

We want to compute one of: \* $d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dω$ \* $d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ$ \* $d⟨ψ(θ)|i〉⟨i|ψ(θ)〉/ dθ$

The last case corresponds to the gradient w\.r.t. the sampling probabilities of |ψ(θ). These gradients can be computed with different methods, i.e. a parameter shift, a linear combination of unitaries and a finite difference method.

**Examples**

```python
x = Parameter('x')
ham = x * X
a = Parameter('a')

q = QuantumRegister(1)
qc = QuantumCircuit(q)
qc.h(q)
qc.p(params[0], q[0])
op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)

value_dict = {x: 0.1, a: np.pi / 4}

ham_grad = Gradient(grad_method='param_shift').convert(operator=op, params=[x])
ham_grad.assign_parameters(value_dict).eval()

state_grad = Gradient(grad_method='lin_comb').convert(operator=op, params=[a])
state_grad.assign_parameters(value_dict).eval()

prob_grad = Gradient(grad_method='fin_diff').convert(
   operator=CircuitStateFn(primitive=qc, coeff=1.), params=[a]
)
prob_grad.assign_parameters(value_dict).eval()
```

**Hessians**

We want to compute one of: \* $d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dω^2$ \* $d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ^2$ \* $d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ dω$ \* $d^2⟨ψ(θ)|i〉⟨i|ψ(θ)〉/ dθ^2$

The last case corresponds to the Hessian w\.r.t. the sampling probabilities of |ψ(θ)〉. Just as the first order gradients, the Hessians can be evaluated with different methods, i.e. a parameter shift, a linear combination of unitaries and a finite difference method. Given a tuple of parameters `Hessian().convert(op, param_tuple)` returns the value for the second order derivative. If a list of parameters is given `Hessian().convert(op, param_list)` returns the full Hessian for all the given parameters according to the given parameter order.

**QFI**

The Quantum Fisher Information QFI is a metric tensor which is representative for the representation capacity of a parameterized quantum state |ψ(θ)〉 = V(θ)|ψ〉 generated by an input state |ψ〉 and a parameterized Ansatz V(θ). The entries of the QFI for a pure state read $\mathrm{QFI}_{kl} = 4 \mathrm{Re}[〈∂kψ|∂lψ〉−〈∂kψ|ψ〉〈ψ|∂lψ〉]$.

Just as for the previous derivative types, the QFI can be computed using different methods: a full representation based on a linear combination of unitaries implementation, a block-diagonal and a diagonal representation based on an overlap method.

**Examples**

```python
q = QuantumRegister(1)
qc = QuantumCircuit(q)
qc.h(q)
qc.p(params[0], q[0])
op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)

value_dict = {x: 0.1, a: np.pi / 4}

qfi = QFI('lin_comb_full').convert(
      operator=CircuitStateFn(primitive=qc, coeff=1.), params=[a]
)
qfi.assign_parameters(value_dict).eval()
```

**NaturalGradients**

The natural gradient is a special gradient method which re-scales a gradient w\.r.t. a state parameter with the inverse of the corresponding Quantum Fisher Information (QFI) $\mathrm{QFI}^{-1} d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ$. Hereby, we can choose a gradient as well as a QFI method and a regularization method which is used together with a least square solver instead of exact inversion of the QFI:

**Examples**

```python
op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)
nat_grad = NaturalGradient(grad_method='lin_comb,
                           qfi_method='lin_comb_full',
                           regularization='ridge').convert(operator=op, params=params)
```

The derivative classes come with a gradient\_wrapper() function which returns the corresponding callable and are thus compatible with the optimizers.

### Base Classes

|                                                                                                                |                                                  |
| -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| [`DerivativeBase`](qiskit.opflow.gradients.DerivativeBase "qiskit.opflow.gradients.DerivativeBase")()          | Base class for differentiating opflow objects.   |
| [`GradientBase`](qiskit.opflow.gradients.GradientBase "qiskit.opflow.gradients.GradientBase")(\[grad\_method]) | Base class for first-order operator gradient.    |
| [`HessianBase`](qiskit.opflow.gradients.HessianBase "qiskit.opflow.gradients.HessianBase")(\[hess\_method])    | Base class for the Hessian of an expected value. |
| [`QFIBase`](qiskit.opflow.gradients.QFIBase "qiskit.opflow.gradients.QFIBase")(\[qfi\_method])                 | Base class for Quantum Fisher Information (QFI). |

### Converters

|                                                                                                          |                                                           |
| -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| [`CircuitGradient`](qiskit.opflow.gradients.CircuitGradient "qiskit.opflow.gradients.CircuitGradient")() | Circuit to gradient operator converter.                   |
| [`CircuitQFI`](qiskit.opflow.gradients.CircuitQFI "qiskit.opflow.gradients.CircuitQFI")()                | Circuit to Quantum Fisher Information operator converter. |

### Derivatives

|                                                                                                                                           |                                                             |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [`Gradient`](qiskit.opflow.gradients.Gradient "qiskit.opflow.gradients.Gradient")(\[grad\_method])                                        | Convert an operator expression to the first-order gradient. |
| [`Hessian`](qiskit.opflow.gradients.Hessian "qiskit.opflow.gradients.Hessian")(\[hess\_method])                                           | Compute the Hessian of an expected value.                   |
| [`NaturalGradient`](qiskit.opflow.gradients.NaturalGradient "qiskit.opflow.gradients.NaturalGradient")(\[grad\_method, qfi\_method, ...]) | Convert an operator expression to the first-order gradient. |
| [`QFI`](qiskit.opflow.gradients.QFI "qiskit.opflow.gradients.QFI")(\[qfi\_method])                                                        | Compute the Quantum Fisher Information (QFI).               |

