---
title: VQC
description: API reference for qiskit.aqua.algorithms.VQC
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.aqua.algorithms.VQC
---

# qiskit.aqua.algorithms.VQC

<Class id="qiskit.aqua.algorithms.VQC" isDedicatedPage={true} github="https://github.com/qiskit-community/qiskit-aqua/tree/stable/0.9/qiskit/aqua/algorithms/classifiers/vqc.py" signature="VQC(optimizer, feature_map, var_form, training_dataset, test_dataset=None, datapoints=None, max_evals_grouped=1, minibatch_size=- 1, callback=None, use_sigmoid_cross_entropy=False, quantum_instance=None)" modifiers="class">
  The Variational Quantum Classifier algorithm.

  Similar to [`QSVM`](qiskit.aqua.algorithms.QSVM "qiskit.aqua.algorithms.QSVM"), the VQC algorithm also applies to classification problems. VQC uses the variational method to solve such problems in a quantum processor. Specifically, it optimizes a parameterized quantum circuit to provide a solution that cleanly separates the data.

  <Admonition title="Note" type="note">
    The VQC stores the parameters of var\_form and feature\_map sorted by name to map the values provided by the optimizer to the circuit. This is done to ensure reproducible results, for example such that running the optimization twice with same random seeds yields the same result.
  </Admonition>

  **Parameters**

  *   **optimizer** (`Optimizer`) – The classical optimizer to use.
  *   **feature\_map** (`Union`\[`QuantumCircuit`, `FeatureMap`]) – The FeatureMap instance to use.
  *   **var\_form** (`Union`\[`QuantumCircuit`, `VariationalForm`]) – The variational form instance.
  *   **training\_dataset** (`Dict`\[`str`, `ndarray`]) – The training dataset, in the format \{‘A’: np.ndarray, ‘B’: np.ndarray, …}.
  *   **test\_dataset** (`Optional`\[`Dict`\[`str`, `ndarray`]]) – The test dataset, in same format as training\_dataset.
  *   **datapoints** (`Optional`\[`ndarray`]) – NxD array, N is the number of data and D is data dimension.
  *   **max\_evals\_grouped** (`int`) – The maximum number of evaluations to perform simultaneously.
  *   **minibatch\_size** (`int`) – The size of a mini-batch.
  *   **callback** (`Optional`\[`Callable`\[\[`int`, `ndarray`, `float`, `int`], `None`]]) – a callback that can access the intermediate data during the optimization. Four parameter values are passed to the callback as follows during each evaluation. These are: the evaluation count, parameters of the variational form, the evaluated value, the index of data batch.
  *   **use\_sigmoid\_cross\_entropy** (`bool`) – whether to use sigmoid cross entropy or not.
  *   **quantum\_instance** (`Union`\[`QuantumInstance`, `Backend`, `BaseBackend`, `None`]) – Quantum Instance or Backend

  <Admonition title="Note" type="note">
    We use label to denote numeric results and class the class names (str).
  </Admonition>

  **Raises**

  [**AquaError**](qiskit.aqua.AquaError "qiskit.aqua.AquaError") – Missing feature map or missing training dataset.

  ### \_\_init\_\_

  <Function id="qiskit.aqua.algorithms.VQC.__init__" signature="__init__(optimizer, feature_map, var_form, training_dataset, test_dataset=None, datapoints=None, max_evals_grouped=1, minibatch_size=- 1, callback=None, use_sigmoid_cross_entropy=False, quantum_instance=None)">
    **Parameters**

    *   **optimizer** (`Optimizer`) – The classical optimizer to use.
    *   **feature\_map** (`Union`\[`QuantumCircuit`, `FeatureMap`]) – The FeatureMap instance to use.
    *   **var\_form** (`Union`\[`QuantumCircuit`, `VariationalForm`]) – The variational form instance.
    *   **training\_dataset** (`Dict`\[`str`, `ndarray`]) – The training dataset, in the format \{‘A’: np.ndarray, ‘B’: np.ndarray, …}.
    *   **test\_dataset** (`Optional`\[`Dict`\[`str`, `ndarray`]]) – The test dataset, in same format as training\_dataset.
    *   **datapoints** (`Optional`\[`ndarray`]) – NxD array, N is the number of data and D is data dimension.
    *   **max\_evals\_grouped** (`int`) – The maximum number of evaluations to perform simultaneously.
    *   **minibatch\_size** (`int`) – The size of a mini-batch.
    *   **callback** (`Optional`\[`Callable`\[\[`int`, `ndarray`, `float`, `int`], `None`]]) – a callback that can access the intermediate data during the optimization. Four parameter values are passed to the callback as follows during each evaluation. These are: the evaluation count, parameters of the variational form, the evaluated value, the index of data batch.
    *   **use\_sigmoid\_cross\_entropy** (`bool`) – whether to use sigmoid cross entropy or not.
    *   **quantum\_instance** (`Union`\[`QuantumInstance`, `Backend`, `BaseBackend`, `None`]) – Quantum Instance or Backend

    <Admonition title="Note" type="note">
      We use label to denote numeric results and class the class names (str).
    </Admonition>

    **Raises**

    [**AquaError**](qiskit.aqua.AquaError "qiskit.aqua.AquaError") – Missing feature map or missing training dataset.
  </Function>

  ## Methods

  |                                                                                                                                                              |                                                                             |
  | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------- |
  | [`__init__`](#qiskit.aqua.algorithms.VQC.__init__ "qiskit.aqua.algorithms.VQC.__init__")(optimizer, feature\_map, var\_form, …)                              | **type optimizer**`Optimizer`                                               |
  | [`batch_data`](#qiskit.aqua.algorithms.VQC.batch_data "qiskit.aqua.algorithms.VQC.batch_data")(data\[, labels, minibatch\_size])                             | batch data                                                                  |
  | [`cleanup_parameterized_circuits`](#qiskit.aqua.algorithms.VQC.cleanup_parameterized_circuits "qiskit.aqua.algorithms.VQC.cleanup_parameterized_circuits")() | set parameterized circuits to None                                          |
  | [`construct_circuit`](#qiskit.aqua.algorithms.VQC.construct_circuit "qiskit.aqua.algorithms.VQC.construct_circuit")(x, theta\[, measurement])                | Construct circuit based on data and parameters in variational form.         |
  | [`find_minimum`](#qiskit.aqua.algorithms.VQC.find_minimum "qiskit.aqua.algorithms.VQC.find_minimum")(\[initial\_point, var\_form, …])                        | Optimize to find the minimum cost value.                                    |
  | [`get_optimal_circuit`](#qiskit.aqua.algorithms.VQC.get_optimal_circuit "qiskit.aqua.algorithms.VQC.get_optimal_circuit")()                                  | get optimal circuit                                                         |
  | [`get_optimal_cost`](#qiskit.aqua.algorithms.VQC.get_optimal_cost "qiskit.aqua.algorithms.VQC.get_optimal_cost")()                                           | get optimal cost                                                            |
  | [`get_optimal_vector`](#qiskit.aqua.algorithms.VQC.get_optimal_vector "qiskit.aqua.algorithms.VQC.get_optimal_vector")()                                     | get optimal vector                                                          |
  | [`get_prob_vector_for_params`](#qiskit.aqua.algorithms.VQC.get_prob_vector_for_params "qiskit.aqua.algorithms.VQC.get_prob_vector_for_params")(…\[, …])      | Helper function to get probability vectors for a set of params              |
  | [`get_probabilities_for_counts`](#qiskit.aqua.algorithms.VQC.get_probabilities_for_counts "qiskit.aqua.algorithms.VQC.get_probabilities_for_counts")(counts) | get probabilities for counts                                                |
  | [`is_gradient_really_supported`](#qiskit.aqua.algorithms.VQC.is_gradient_really_supported "qiskit.aqua.algorithms.VQC.is_gradient_really_supported")()       | returns is gradient really supported                                        |
  | [`load_model`](#qiskit.aqua.algorithms.VQC.load_model "qiskit.aqua.algorithms.VQC.load_model")(file\_path)                                                   | load model                                                                  |
  | [`predict`](#qiskit.aqua.algorithms.VQC.predict "qiskit.aqua.algorithms.VQC.predict")(data\[, quantum\_instance, …])                                         | Predict the labels for the data.                                            |
  | [`run`](#qiskit.aqua.algorithms.VQC.run "qiskit.aqua.algorithms.VQC.run")(\[quantum\_instance])                                                              | Execute the algorithm with selected backend.                                |
  | [`save_model`](#qiskit.aqua.algorithms.VQC.save_model "qiskit.aqua.algorithms.VQC.save_model")(file\_path)                                                   | save model                                                                  |
  | [`set_backend`](#qiskit.aqua.algorithms.VQC.set_backend "qiskit.aqua.algorithms.VQC.set_backend")(backend, \*\*kwargs)                                       | Sets backend with configuration.                                            |
  | [`test`](#qiskit.aqua.algorithms.VQC.test "qiskit.aqua.algorithms.VQC.test")(data, labels\[, quantum\_instance, …])                                          | Predict the labels for the data, and test against with ground truth labels. |
  | [`train`](#qiskit.aqua.algorithms.VQC.train "qiskit.aqua.algorithms.VQC.train")(data, labels\[, quantum\_instance, …])                                       | Train the models, and save results.                                         |

  ## Attributes

  |                                                                                                                  |                            |
  | ---------------------------------------------------------------------------------------------------------------- | -------------------------- |
  | [`backend`](#qiskit.aqua.algorithms.VQC.backend "qiskit.aqua.algorithms.VQC.backend")                            | Returns backend.           |
  | [`class_to_label`](#qiskit.aqua.algorithms.VQC.class_to_label "qiskit.aqua.algorithms.VQC.class_to_label")       | returns class to label     |
  | [`datapoints`](#qiskit.aqua.algorithms.VQC.datapoints "qiskit.aqua.algorithms.VQC.datapoints")                   | return data points         |
  | [`feature_map`](#qiskit.aqua.algorithms.VQC.feature_map "qiskit.aqua.algorithms.VQC.feature_map")                | Return the feature map.    |
  | [`initial_point`](#qiskit.aqua.algorithms.VQC.initial_point "qiskit.aqua.algorithms.VQC.initial_point")          | Returns initial point      |
  | [`label_to_class`](#qiskit.aqua.algorithms.VQC.label_to_class "qiskit.aqua.algorithms.VQC.label_to_class")       | returns label to class     |
  | [`optimal_params`](#qiskit.aqua.algorithms.VQC.optimal_params "qiskit.aqua.algorithms.VQC.optimal_params")       | returns optimal parameters |
  | [`optimizer`](#qiskit.aqua.algorithms.VQC.optimizer "qiskit.aqua.algorithms.VQC.optimizer")                      | Returns optimizer          |
  | [`quantum_instance`](#qiskit.aqua.algorithms.VQC.quantum_instance "qiskit.aqua.algorithms.VQC.quantum_instance") | Returns quantum instance.  |
  | [`random`](#qiskit.aqua.algorithms.VQC.random "qiskit.aqua.algorithms.VQC.random")                               | Return a numpy random.     |
  | [`ret`](#qiskit.aqua.algorithms.VQC.ret "qiskit.aqua.algorithms.VQC.ret")                                        | returns result             |
  | [`test_dataset`](#qiskit.aqua.algorithms.VQC.test_dataset "qiskit.aqua.algorithms.VQC.test_dataset")             | returns test dataset       |
  | [`training_dataset`](#qiskit.aqua.algorithms.VQC.training_dataset "qiskit.aqua.algorithms.VQC.training_dataset") | returns training dataset   |
  | [`var_form`](#qiskit.aqua.algorithms.VQC.var_form "qiskit.aqua.algorithms.VQC.var_form")                         | Returns variational form   |

  ### backend

  <Attribute id="qiskit.aqua.algorithms.VQC.backend">
    Returns backend.

    **Return type**

    `Union`\[`Backend`, `BaseBackend`]
  </Attribute>

  ### batch\_data

  <Function id="qiskit.aqua.algorithms.VQC.batch_data" signature="batch_data(data, labels=None, minibatch_size=- 1)">
    batch data
  </Function>

  ### class\_to\_label

  <Attribute id="qiskit.aqua.algorithms.VQC.class_to_label">
    returns class to label
  </Attribute>

  ### cleanup\_parameterized\_circuits

  <Function id="qiskit.aqua.algorithms.VQC.cleanup_parameterized_circuits" signature="cleanup_parameterized_circuits()">
    set parameterized circuits to None
  </Function>

  ### construct\_circuit

  <Function id="qiskit.aqua.algorithms.VQC.construct_circuit" signature="construct_circuit(x, theta, measurement=False)">
    Construct circuit based on data and parameters in variational form.

    **Parameters**

    *   **x** (*numpy.ndarray*) – 1-D array with D dimension
    *   **theta** (*list\[numpy.ndarray]*) – list of 1-D array, parameters sets for variational form
    *   **measurement** (*bool*) – flag to add measurement

    **Returns**

    the circuit

    **Return type**

    [QuantumCircuit](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")

    **Raises**

    [**AquaError**](qiskit.aqua.AquaError "qiskit.aqua.AquaError") – If `x` and `theta` share parameters with the same name.
  </Function>

  ### datapoints

  <Attribute id="qiskit.aqua.algorithms.VQC.datapoints">
    return data points
  </Attribute>

  ### feature\_map

  <Attribute id="qiskit.aqua.algorithms.VQC.feature_map">
    Return the feature map.

    **Return type**

    `Union`\[`FeatureMap`, `QuantumCircuit`, `None`]
  </Attribute>

  ### find\_minimum

  <Function id="qiskit.aqua.algorithms.VQC.find_minimum" signature="find_minimum(initial_point=None, var_form=None, cost_fn=None, optimizer=None, gradient_fn=None)">
    Optimize to find the minimum cost value.

    **Parameters**

    *   **initial\_point** (`Optional`\[`ndarray`]) – If not None will be used instead of any initial point supplied via constructor. If None and None was supplied to constructor then a random point will be used if the optimizer requires an initial point.
    *   **var\_form** (`Union`\[`QuantumCircuit`, `VariationalForm`, `None`]) – If not None will be used instead of any variational form supplied via constructor.
    *   **cost\_fn** (`Optional`\[`Callable`]) – If not None will be used instead of any cost\_fn supplied via constructor.
    *   **optimizer** (`Optional`\[`Optimizer`]) – If not None will be used instead of any optimizer supplied via constructor.
    *   **gradient\_fn** (`Optional`\[`Callable`]) – Optional gradient function for optimizer

    **Returns**

    Optimized variational parameters, and corresponding minimum cost value.

    **Return type**

    dict

    **Raises**

    **ValueError** – invalid input
  </Function>

  ### get\_optimal\_circuit

  <Function id="qiskit.aqua.algorithms.VQC.get_optimal_circuit" signature="get_optimal_circuit()">
    get optimal circuit
  </Function>

  ### get\_optimal\_cost

  <Function id="qiskit.aqua.algorithms.VQC.get_optimal_cost" signature="get_optimal_cost()">
    get optimal cost
  </Function>

  ### get\_optimal\_vector

  <Function id="qiskit.aqua.algorithms.VQC.get_optimal_vector" signature="get_optimal_vector()">
    get optimal vector
  </Function>

  ### get\_prob\_vector\_for\_params

  <Function id="qiskit.aqua.algorithms.VQC.get_prob_vector_for_params" signature="get_prob_vector_for_params(construct_circuit_fn, params_s, quantum_instance, construct_circuit_args=None)">
    Helper function to get probability vectors for a set of params
  </Function>

  ### get\_probabilities\_for\_counts

  <Function id="qiskit.aqua.algorithms.VQC.get_probabilities_for_counts" signature="get_probabilities_for_counts(counts)">
    get probabilities for counts
  </Function>

  ### initial\_point

  <Attribute id="qiskit.aqua.algorithms.VQC.initial_point">
    Returns initial point

    **Return type**

    `Optional`\[`ndarray`]
  </Attribute>

  ### is\_gradient\_really\_supported

  <Function id="qiskit.aqua.algorithms.VQC.is_gradient_really_supported" signature="is_gradient_really_supported()">
    returns is gradient really supported
  </Function>

  ### label\_to\_class

  <Attribute id="qiskit.aqua.algorithms.VQC.label_to_class">
    returns label to class
  </Attribute>

  ### load\_model

  <Function id="qiskit.aqua.algorithms.VQC.load_model" signature="load_model(file_path)">
    load model
  </Function>

  ### optimal\_params

  <Attribute id="qiskit.aqua.algorithms.VQC.optimal_params">
    returns optimal parameters
  </Attribute>

  ### optimizer

  <Attribute id="qiskit.aqua.algorithms.VQC.optimizer">
    Returns optimizer

    **Return type**

    `Optional`\[`Optimizer`]
  </Attribute>

  ### predict

  <Function id="qiskit.aqua.algorithms.VQC.predict" signature="predict(data, quantum_instance=None, minibatch_size=- 1, params=None)">
    Predict the labels for the data.

    **Parameters**

    *   **data** (*numpy.ndarray*) – NxD array, N is number of data, D is data dimension
    *   **quantum\_instance** ([*QuantumInstance*](qiskit.aqua.QuantumInstance "qiskit.aqua.QuantumInstance")) – quantum backend with all setting
    *   **minibatch\_size** (*int*) – the size of each minibatched accuracy evaluation
    *   **params** (*list*) – list of parameters to populate in the variational form

    **Returns**

    for each data point, generates the predicted probability for each class list: for each data point, generates the predicted label (that with the highest prob)

    **Return type**

    list
  </Function>

  ### quantum\_instance

  <Attribute id="qiskit.aqua.algorithms.VQC.quantum_instance">
    Returns quantum instance.

    **Return type**

    `Optional`\[`QuantumInstance`]
  </Attribute>

  ### random

  <Attribute id="qiskit.aqua.algorithms.VQC.random">
    Return a numpy random.
  </Attribute>

  ### ret

  <Attribute id="qiskit.aqua.algorithms.VQC.ret">
    returns result
  </Attribute>

  ### run

  <Function id="qiskit.aqua.algorithms.VQC.run" signature="run(quantum_instance=None, **kwargs)">
    Execute the algorithm with selected backend.

    **Parameters**

    *   **quantum\_instance** (`Union`\[`QuantumInstance`, `Backend`, `BaseBackend`, `None`]) – the experimental setting.
    *   **kwargs** (*dict*) – kwargs

    **Returns**

    results of an algorithm.

    **Return type**

    dict

    **Raises**

    [**AquaError**](qiskit.aqua.AquaError "qiskit.aqua.AquaError") – If a quantum instance or backend has not been provided
  </Function>

  ### save\_model

  <Function id="qiskit.aqua.algorithms.VQC.save_model" signature="save_model(file_path)">
    save model
  </Function>

  ### set\_backend

  <Function id="qiskit.aqua.algorithms.VQC.set_backend" signature="set_backend(backend, **kwargs)">
    Sets backend with configuration.

    **Return type**

    `None`
  </Function>

  ### test

  <Function id="qiskit.aqua.algorithms.VQC.test" signature="test(data, labels, quantum_instance=None, minibatch_size=- 1, params=None)">
    Predict the labels for the data, and test against with ground truth labels.

    **Parameters**

    *   **data** (*numpy.ndarray*) – NxD array, N is number of data and D is data dimension
    *   **labels** (*numpy.ndarray*) – Nx1 array, N is number of data
    *   **quantum\_instance** ([*QuantumInstance*](qiskit.aqua.QuantumInstance "qiskit.aqua.QuantumInstance")) – quantum backend with all setting
    *   **minibatch\_size** (*int*) – the size of each minibatched accuracy evaluation
    *   **params** (*list*) – list of parameters to populate in the variational form

    **Returns**

    classification accuracy

    **Return type**

    float
  </Function>

  ### test\_dataset

  <Attribute id="qiskit.aqua.algorithms.VQC.test_dataset">
    returns test dataset
  </Attribute>

  ### train

  <Function id="qiskit.aqua.algorithms.VQC.train" signature="train(data, labels, quantum_instance=None, minibatch_size=- 1)">
    Train the models, and save results.

    **Parameters**

    *   **data** (*numpy.ndarray*) – NxD array, N is number of data and D is dimension
    *   **labels** (*numpy.ndarray*) – Nx1 array, N is number of data
    *   **quantum\_instance** ([*QuantumInstance*](qiskit.aqua.QuantumInstance "qiskit.aqua.QuantumInstance")) – quantum backend with all setting
    *   **minibatch\_size** (*int*) – the size of each minibatched accuracy evaluation
  </Function>

  ### training\_dataset

  <Attribute id="qiskit.aqua.algorithms.VQC.training_dataset">
    returns training dataset
  </Attribute>

  ### var\_form

  <Attribute id="qiskit.aqua.algorithms.VQC.var_form">
    Returns variational form

    **Return type**

    `Union`\[`QuantumCircuit`, `VariationalForm`, `None`]
  </Attribute>
</Class>

