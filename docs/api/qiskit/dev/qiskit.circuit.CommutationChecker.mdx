---
title: CommutationChecker (dev version)
description: API reference for qiskit.circuit.CommutationChecker in the dev version of qiskit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.CommutationChecker
---

# CommutationChecker

<Class id="qiskit.circuit.CommutationChecker" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/commutation_checker.py#L24-L149" signature="qiskit.circuit.CommutationChecker(standard_gate_commutations=None, cache_max_entries=1000000, *, gates=None)" modifiers="class">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object)

  Check commutations of two operations.

  Two unitaries $A$ and $B$ on $n$ qubits commute if

$$
\frac{2^n F_{\text{process}}(AB, BA) + 1}{2^n + 1} > 1 - \varepsilon,
$$

  where

$$
F_{\text{process}}(U_1, U_2) = \left|\frac{\mathrm{Tr}(U_1 U_2^\dagger)}{2^n} \right|^2,
$$

  and we set $\varepsilon$ to $10^{-12}$ to account for round-off errors on few-qubit systems. This metric is chosen for consistency with other closeness checks in Qiskit.

  When possible, commutation relations are queried from a lookup table. This is the case for standard gates without parameters (such as [`XGate`](qiskit.circuit.library.XGate "qiskit.circuit.library.XGate") or [`HGate`](qiskit.circuit.library.HGate "qiskit.circuit.library.HGate")) or gates with free parameters (such as [`RXGate`](qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate") with a [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") as angle). Otherwise, a matrix-based check is performed, where two operations are said to commute, if the average gate fidelity of performing the commutation is above a certain threshold (see `approximation_degree`). The result of this commutation is then added to the cached lookup table.

  ## Methods

  **Parameters**

  *   **standard\_gate\_commutations** ([*dict*](https://docs.python.org/3/library/stdtypes.html#dict)) –
  *   **cache\_max\_entries** ([*int*](https://docs.python.org/3/library/functions.html#int)) –
  *   **gates** (*Optional\[Set\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str)*]]*) –

  ### check\_commutation\_entries

  <Function id="qiskit.circuit.CommutationChecker.check_commutation_entries" github="https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/commutation_checker.py#L129-L149" signature="check_commutation_entries(first_op, first_qargs, second_op, second_qargs)">
    Returns stored commutation relation if any

    **Parameters**

    *   **first\_op** ([*Operation*](qiskit.circuit.Operation "qiskit.circuit.operation.Operation")) – first operation.
    *   **first\_qargs** ([*List*](https://docs.python.org/3/library/typing.html#typing.List)) – first operation’s qubits.
    *   **second\_op** ([*Operation*](qiskit.circuit.Operation "qiskit.circuit.operation.Operation")) – second operation.
    *   **second\_qargs** ([*List*](https://docs.python.org/3/library/typing.html#typing.List)) – second operation’s qubits.

    **Returns**

    True if the gates commute and false if it is not the case.

    **Return type**

    [bool](https://docs.python.org/3/library/functions.html#bool)
  </Function>

  ### clear\_cached\_commutations

  <Function id="qiskit.circuit.CommutationChecker.clear_cached_commutations" github="https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/commutation_checker.py#L125-L127" signature="clear_cached_commutations()">
    Clears the dictionary holding cached commutations
  </Function>

  ### commute

  <Function id="qiskit.circuit.CommutationChecker.commute" github="https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/commutation_checker.py#L71-L119" signature="commute(op1, qargs1, cargs1, op2, qargs2, cargs2, max_num_qubits=None, approximation_degree=1.0, matrix_max_num_qubits=3)">
    Checks if two Operations commute. The return value of `True` means that the operations truly commute, and the return value of `False` means that either the operations do not commute or that the commutation check was skipped (for example, when the operations have conditions or have too many qubits).

    **Parameters**

    *   **op1** ([*Operation*](qiskit.circuit.Operation "qiskit.circuit.operation.Operation")) – first operation.
    *   **qargs1** ([*Sequence*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)*\[*[*Qubit*](circuit#qiskit.circuit.Qubit "qiskit.circuit.Qubit")  *|*[*int*](https://docs.python.org/3/library/functions.html#int)*]*) – first operation’s qubits.
    *   **cargs1** ([*Sequence*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)*\[*[*Qubit*](circuit#qiskit.circuit.Qubit "qiskit.circuit.Qubit")  *|*[*int*](https://docs.python.org/3/library/functions.html#int)*]*) – first operation’s clbits.
    *   **op2** ([*Operation*](qiskit.circuit.Operation "qiskit.circuit.operation.Operation")) – second operation.
    *   **qargs2** ([*Sequence*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)*\[*[*Qubit*](circuit#qiskit.circuit.Qubit "qiskit.circuit.Qubit")  *|*[*int*](https://docs.python.org/3/library/functions.html#int)*]*) – second operation’s qubits.
    *   **cargs2** ([*Sequence*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)*\[*[*Qubit*](circuit#qiskit.circuit.Qubit "qiskit.circuit.Qubit")  *|*[*int*](https://docs.python.org/3/library/functions.html#int)*]*) – second operation’s clbits.
    *   **max\_num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int) *| None*) – the maximum number of qubits to consider, the check may be skipped if the number of qubits for either operation exceeds this amount. Defaults to `None`, which means no limit. See also `matrix_max_num_qubits` to limit the dimension of matrices computed.
    *   **approximation\_degree** ([*float*](https://docs.python.org/3/library/functions.html#float)) – If the average gate fidelity in between the two operations is above this number (up to `1e-12`) they are assumed to commute.
    *   **matrix\_max\_num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int)) – the maximum number of qubits for which it is allowed to compute the matrix representation. This is needed if there is no efficient heck readily available, e.g. for custom gates.

    **Returns**

    Whether two operations commute.

    **Return type**

    [bool](https://docs.python.org/3/library/functions.html#bool)
  </Function>

  ### commute\_nodes

  <Function id="qiskit.circuit.CommutationChecker.commute_nodes" github="https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/commutation_checker.py#L61-L69" signature="commute_nodes(op1, op2, max_num_qubits=3, approximation_degree=1.0)">
    Checks if two DAGOpNodes commute.

    **Parameters**

    *   **max\_num\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int)) –
    *   **approximation\_degree** ([*float*](https://docs.python.org/3/library/functions.html#float)) –

    **Return type**

    [bool](https://docs.python.org/3/library/functions.html#bool)
  </Function>

  ### num\_cached\_entries

  <Function id="qiskit.circuit.CommutationChecker.num_cached_entries" github="https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/commutation_checker.py#L121-L123" signature="num_cached_entries()">
    Returns number of cached entries
  </Function>
</Class>

