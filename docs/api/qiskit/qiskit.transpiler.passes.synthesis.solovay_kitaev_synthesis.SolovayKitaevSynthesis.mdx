---
title: SolovayKitaevSynthesis (latest version)
description: API reference for qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis in the latest version of qiskit
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis
---

# SolovayKitaevSynthesis

<Class id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/stable/2.0/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py#L198-L303" signature="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis" modifiers="class">
  Bases: [`UnitarySynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin")

  A Solovay-Kitaev Qiskit unitary synthesis plugin.

  This plugin is invoked by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when the `unitary_synthesis_method` parameter is set to `"sk"`.

  This plugin supports customization and additional parameters can be passed to the plugin by passing a dictionary as the `unitary_synthesis_plugin_config` parameter of the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function.

  Supported parameters in the dictionary:

  **basis\_approximations (str | dict):**

  The basic approximations for the finding the best discrete decomposition at the root of the recursion. If a string, it specifies the `.npy` file to load the approximations from. If a dictionary, it contains `{label: SO(3)-matrix}` pairs. If None, a default based on the specified `basis_gates` and `depth` is generated.

  **basis\_gates (list):**

  A list of strings specifying the discrete basis gates to decompose to. If None, defaults to `["h", "t", "tdg"]`.

  **depth (int):**

  The gate-depth of the basic approximations. All possible, unique combinations of the basis gates up to length `depth` are considered. If None, defaults to 10.

  **recursion\_degree (int):**

  The number of times the decomposition is recursively improved. If None, defaults to 3.

  ## Attributes

  ### max\_qubits

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.max_qubits">
    Maximum number of supported qubits is `1`.
  </Attribute>

  ### min\_qubits

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.min_qubits">
    Minimum number of supported qubits is `1`.
  </Attribute>

  ### supported\_bases

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supported_bases">
    The plugin does not support bases for synthesis.
  </Attribute>

  ### supports\_basis\_gates

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_basis_gates">
    The plugin does not support basis gates. By default it synthesis to the `["h", "t", "tdg"]` gate basis.
  </Attribute>

  ### supports\_coupling\_map

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_coupling_map">
    The plugin does not support coupling maps.
  </Attribute>

  ### supports\_gate\_errors

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_gate_errors">
    The plugin does not support gate errors.
  </Attribute>

  ### supports\_gate\_errors\_by\_qubit

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_gate_errors_by_qubit">
    Return whether the plugin supports taking `gate_errors_by_qubit`

    This differs from `supports_gate_errors`/`gate_errors` by using a different view of the same data. Instead of being keyed by gate name this is keyed by qubit and uses [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") instances to represent gates (instead of gate names).

    `gate_errors_by_qubit` will be a dictionary in the form of `{(qubits,): [Gate, error]}`. For example:

    ```python
    {
    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],
    (0, 1): [CXGate(): 0.012012477900732316]
    }
    ```

    Do note that this dictionary might not be complete or could be empty as it depends on the target backend reporting gate errors on every gate for each qubit. The gate error rates reported in `gate_errors` are provided by the target device `Backend` object and the exact meaning might be different depending on the backend.

    This defaults to False
  </Attribute>

  ### supports\_gate\_lengths

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_gate_lengths">
    The plugin does not support gate lengths.
  </Attribute>

  ### supports\_gate\_lengths\_by\_qubit

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_gate_lengths_by_qubit">
    Return whether the plugin supports taking `gate_lengths_by_qubit`

    This differs from `supports_gate_lengths`/`gate_lengths` by using a different view of the same data. Instead of being keyed by gate name this is keyed by qubit and uses [`Gate`](qiskit.circuit.Gate "qiskit.circuit.Gate") instances to represent gates (instead of gate names)

    `gate_lengths_by_qubit` will be a dictionary in the form of `{(qubits,): [Gate, length]}`. For example:

    ```python
    {
    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],
    (0, 1): [CXGate(): 0.012012477900732316]
    }
    ```

    where the `length` value is in units of seconds.

    Do note that this dictionary might not be complete or could be empty as it depends on the target backend reporting gate lengths on every gate for each qubit.

    This defaults to False
  </Attribute>

  ### supports\_natural\_direction

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_natural_direction">
    The plugin does not support natural direction, it does not assume bidirectional two qubit gates.
  </Attribute>

  ### supports\_pulse\_optimize

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_pulse_optimize">
    The plugin does not support optimization of pulses.
  </Attribute>

  ### supports\_target

  <Attribute id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.supports_target">
    Whether the plugin supports taking `target` as an option

    `target` will be a [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") object representing the target device for the output of the synthesis pass.

    By default this will be `False` since the plugin interface predates the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") class. If a plugin returns `True` for this attribute, it is expected that the plugin will use the [`Target`](qiskit.transpiler.Target "qiskit.transpiler.Target") instead of the values passed if any of `supports_gate_lengths`, `supports_gate_errors`, `supports_coupling_map`, and `supports_basis_gates` are set (although ideally all those parameters should contain duplicate information).
  </Attribute>

  ## Methods

  ### run

  <Function id="qiskit.transpiler.passes.synthesis.solovay_kitaev_synthesis.SolovayKitaevSynthesis.run" github="https://github.com/Qiskit/qiskit/tree/stable/2.0/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py#L279-L303" signature="run(unitary, **options)">
    Run synthesis for the given unitary matrix

    **Parameters**

    *   **unitary** ([*numpy.ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The unitary matrix to synthesize to a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") object
    *   **options** – The optional kwargs that are passed based on the output the `support_*` methods on the class. Refer to the documentation for these methods on [`UnitarySynthesisPlugin`](qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin") to see what the keys and values are.

    **Returns**

    The dag circuit representation of the unitary. Alternatively, you can return a tuple of the form `(dag, wires)` where `dag` is the dag circuit representation of the circuit representation of the unitary and `wires` is the mapping wires to use for [`qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag()`](qiskit.dagcircuit.DAGCircuit#substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag"). If you return a tuple and `wires` is `None` this will behave just as if only a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") was returned. Additionally if this returns `None` no substitution will be made.

    **Return type**

    [DAGCircuit](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit")
  </Function>
</Class>

