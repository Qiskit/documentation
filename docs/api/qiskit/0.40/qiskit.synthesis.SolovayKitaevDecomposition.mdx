---
title: SolovayKitaevDecomposition (v0.40)
description: API reference for qiskit.synthesis.SolovayKitaevDecomposition in qiskit v0.40
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.synthesis.SolovayKitaevDecomposition
---

# SolovayKitaevDecomposition

<Class id="qiskit.synthesis.SolovayKitaevDecomposition" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.23/qiskit/synthesis/discrete_basis/solovay_kitaev.py" signature="SolovayKitaevDecomposition(basic_approximations=None)" modifiers="class">
  Bases: `object`

  The Solovay Kitaev discrete decomposition algorithm.

  This class is called recursively by the transpiler pass, which is why it is separeted. See [`qiskit.transpiler.passes.SolovayKitaev`](qiskit.transpiler.passes.SolovayKitaev "qiskit.transpiler.passes.SolovayKitaev") for more information.

  **Parameters**

  **basic\_approximations** – A specification of the basic SU(2) approximations in terms of discrete gates. At each iteration this algorithm, the remaining error is approximated with the closest sequence of gates in this set. If a `str`, this specifies a `.npy` filename from which to load the approximation. If a `dict`, then this contains `{gates: effective_SO3_matrix}` pairs, e.g. `{"h t": np.array([[0, 0.7071, -0.7071], [0, -0.7071, -0.7071], [-1, 0, 0]]}`. If a list, this contains the same information as the dict, but already converted to `GateSequence` objects, which contain the SO(3) matrix and gates.

  ## Methods

  <span id="qiskit-synthesis-solovaykitaevdecomposition-find-basic-approximation" />

  ### find\_basic\_approximation

  <Function id="qiskit.synthesis.SolovayKitaevDecomposition.find_basic_approximation" signature="SolovayKitaevDecomposition.find_basic_approximation(sequence)">
    Finds gate in `self._basic_approximations` that best represents `sequence`.

    **Parameters**

    **sequence** (`GateSequence`) – The gate to find the approximation to.

    **Return type**

    [`Gate`](qiskit.circuit.Gate "qiskit.circuit.gate.Gate")

    **Returns**

    Gate in basic approximations that is closest to `sequence`.
  </Function>

  <span id="qiskit-synthesis-solovaykitaevdecomposition-load-basic-approximations" />

  ### load\_basic\_approximations

  <Function id="qiskit.synthesis.SolovayKitaevDecomposition.load_basic_approximations" signature="SolovayKitaevDecomposition.load_basic_approximations(data)">
    Load basic approximations.

    **Parameters**

    **data** (*list | str | dict*) – If a string, specifies the path to the file from where to load the data. If a dictionary, directly specifies the decompositions as `{gates: matrix}`. There `gates` are the names of the gates producing the SO(3) matrix `matrix`, e.g. `{"h t": np.array([[0, 0.7071, -0.7071], [0, -0.7071, -0.7071], [-1, 0, 0]]}`.

    **Return type**

    list\[GateSequence]

    **Returns**

    A list of basic approximations as type `GateSequence`.

    **Raises**

    **ValueError** – If the number of gate combinations and associated matrices does not match.
  </Function>

  <span id="qiskit-synthesis-solovaykitaevdecomposition-run" />

  ### run

  <Function id="qiskit.synthesis.SolovayKitaevDecomposition.run" signature="SolovayKitaevDecomposition.run(gate_matrix, recursion_degree, return_dag=False, check_input=True)">
    Run the algorithm.

    **Parameters**

    *   **gate\_matrix** (*np.ndarray*) – The 2x2 matrix representing the gate. This matrix has to be SU(2) up to global phase.
    *   **recursion\_degree** (*int*) – The recursion degree, called $n$ in the paper.
    *   **return\_dag** (*bool*) – If `True` return a [`DAGCircuit`](qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit"), else a [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").
    *   **check\_input** (*bool*) – If `True` check that the input matrix is valid for the decomposition.

    **Return type**

    QuantumCircuit’ | ‘DAGCircuit

    **Returns**

    A one-qubit circuit approximating the `gate_matrix` in the specified discrete basis.
  </Function>
</Class>

