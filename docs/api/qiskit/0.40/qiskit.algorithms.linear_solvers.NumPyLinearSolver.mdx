---
title: NumPyLinearSolver (v0.40)
description: API reference for qiskit.algorithms.linear_solvers.NumPyLinearSolver in qiskit v0.40
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.algorithms.linear_solvers.NumPyLinearSolver
---

# NumPyLinearSolver

<Class id="qiskit.algorithms.linear_solvers.NumPyLinearSolver" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.23/qiskit/algorithms/linear_solvers/numpy_linear_solver.py" signature="NumPyLinearSolver" modifiers="class">
  Bases: [`qiskit.algorithms.linear_solvers.linear_solver.LinearSolver`](qiskit.algorithms.linear_solvers.LinearSolver "qiskit.algorithms.linear_solvers.linear_solver.LinearSolver")

  The deprecated Numpy Linear Solver algorithm (classical).

  This linear system solver computes the exact value of the given observable(s) or the full solution vector if no observable is specified.

  Examples:

  ```python
  import warnings
  import numpy as np
  from qiskit.algorithms import NumPyLinearSolver
  from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz
  from qiskit.algorithms.linear_solvers.observables import MatrixFunctional

  with warnings.catch_warnings():
      warnings.simplefilter('ignore')
      matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)
      right_hand_side = [1.0, -2.1, 3.2, -4.3]
      observable = MatrixFunctional(1, 1 / 2)
      rhs = right_hand_side / np.linalg.norm(right_hand_side)

  with warnings.catch_warnings():
      warnings.simplefilter('ignore')
      np_solver = NumPyLinearSolver()
      solution = np_solver.solve(matrix, rhs, observable)
  result = solution.observable
  ```

  ## Methods

  <span id="qiskit-algorithms-linear-solvers-numpylinearsolver-solve" />

  ### solve

  <Function id="qiskit.algorithms.linear_solvers.NumPyLinearSolver.solve" signature="NumPyLinearSolver.solve(matrix, vector, observable=None, observable_circuit=None, post_processing=None)">
    Solve classically the linear system and compute the observable(s)

    **Parameters**

    *   **matrix** (`Union`\[`ndarray`, [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.quantumcircuit.QuantumCircuit")]) – The matrix specifying the system, i.e. A in Ax=b.
    *   **vector** (`Union`\[`ndarray`, [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.quantumcircuit.QuantumCircuit")]) – The vector specifying the right hand side of the equation in Ax=b.
    *   **observable** (`Union`\[[`LinearSystemObservable`](qiskit.algorithms.linear_solvers.LinearSystemObservable "qiskit.algorithms.linear_solvers.observables.linear_system_observable.LinearSystemObservable"), `BaseOperator`, `List`\[`BaseOperator`], `None`]) – Optional information to be extracted from the solution. Default is the probability of success of the algorithm.
    *   **observable\_circuit** (`Union`\[[`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.quantumcircuit.QuantumCircuit"), `List`\[[`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.quantumcircuit.QuantumCircuit")], `None`]) – Optional circuit to be applied to the solution to extract information. Default is `None`.
    *   **post\_processing** (`Optional`\[`Callable`\[\[`Union`\[`float`, `List`\[`float`]]], `Union`\[`float`, `List`\[`float`]]]]) – Optional function to compute the value of the observable. Default is the raw value of measuring the observable.

    **Return type**

    [`LinearSolverResult`](qiskit.algorithms.linear_solvers.LinearSolverResult "qiskit.algorithms.linear_solvers.linear_solver.LinearSolverResult")

    **Returns**

    The result of the linear system.
  </Function>
</Class>

