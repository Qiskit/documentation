---
title: PiecewisePolynomialPauliRotations (v2.1)
description: API reference for qiskit.circuit.library.PiecewisePolynomialPauliRotations in qiskit v2.1
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.PiecewisePolynomialPauliRotations
---

# PiecewisePolynomialPauliRotations

<Class id="qiskit.circuit.library.PiecewisePolynomialPauliRotations" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/stable/2.1/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py#L28-L316" signature="qiskit.circuit.library.PiecewisePolynomialPauliRotations(num_state_qubits=None, breakpoints=None, coeffs=None, basis='Y', name='pw_poly')" modifiers="class">
  Bases: [`FunctionalPauliRotations`](qiskit.circuit.library.FunctionalPauliRotations "qiskit.circuit.library.arithmetic.functional_pauli_rotations.FunctionalPauliRotations")

  Piecewise-polynomially-controlled Pauli rotations.

  This class implements a piecewise polynomial (not necessarily continuous) function, $f(x)$, on qubit amplitudes, which is defined through breakpoints and coefficients as follows. Suppose the breakpoints $(x_0, ..., x_J)$ are a subset of $[0, 2^n-1]$, where $n$ is the number of state qubits. Further on, denote the corresponding coefficients by $[a_{j,1},...,a_{j,d}]$, where $d$ is the highest degree among all polynomials.

  Then $f(x)$ is defined as:

$$
f(x) = \begin{cases}
0, x < x_0 \\
\sum_{i=0}^{i=d}a_{j,i}/2 x^i, x_j \leq x < x_{j+1}
\end{cases}
$$

  where if given the same number of breakpoints as polynomials, we implicitly assume $x_{J+1} = 2^n$.

  <Admonition title="Note" type="note">
    Note the $1/2$ factor in the coefficients of $f(x)$, this is consistent with Qiskit’s Pauli rotations.
  </Admonition>

  **Examples**

  ```python
  >>> from qiskit import QuantumCircuit
  >>> from qiskit.circuit.library.arithmetic.piecewise_polynomial_pauli_rotations import\
  ... PiecewisePolynomialPauliRotations
  >>> qubits, breakpoints, coeffs = (2, [0, 2], [[0, -1.2],[-1, 1, 3]])
  >>> poly_r = PiecewisePolynomialPauliRotations(num_state_qubits=qubits,
  ...breakpoints=breakpoints, coeffs=coeffs)
  >>>
  >>> qc = QuantumCircuit(poly_r.num_qubits)
  >>> qc.h(list(range(qubits)));
  >>> qc.append(poly_r.to_instruction(), list(range(qc.num_qubits)));
  >>> qc.draw()
       ┌───┐┌──────────┐
  q_0: ┤ H ├┤0         ├
       ├───┤│          │
  q_1: ┤ H ├┤1         ├
       └───┘│          │
  q_2: ─────┤2         ├
            │  pw_poly │
  q_3: ─────┤3         ├
            │          │
  q_4: ─────┤4         ├
            │          │
  q_5: ─────┤5         ├
            └──────────┘
  ```

  **References**

  **\[1]: Haener, T., Roetteler, M., & Svore, K. M. (2018).**

  Optimizing Quantum Circuits for Arithmetic. [arXiv:1805.12445](http://arxiv.org/abs/1805.12445)

  **\[2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2022).**

  Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation. [ACM Transactions on Quantum Computing 3, 1, Article 2](https://doi.org/10.1145/3490631)

  **Parameters**

  *   **num\_state\_qubits** (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]*) – The number of qubits representing the state.
  *   **breakpoints** (*Optional\[List\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]]*) – The breakpoints to define the piecewise-linear function. Defaults to `[0]`.
  *   **coeffs** (*Optional\[List\[List\[*[*float*](https://docs.python.org/3/library/functions.html#float)*]]]*) – The coefficients of the polynomials for different segments of the piecewise-linear function. `coeffs[j][i]` is the coefficient of the i-th power of x for the j-th polynomial. Defaults to linear: `[[1]]`.
  *   **basis** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The type of Pauli rotation (`'X'`, `'Y'`, `'Z'`).
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The name of the circuit.

  ## Attributes

  ### breakpoints

  <Attribute id="qiskit.circuit.library.PiecewisePolynomialPauliRotations.breakpoints">
    The breakpoints of the piecewise polynomial function.

    The function is polynomial in the intervals `[point_i, point_{i+1}]` where the last point implicitly is `2**(num_state_qubits + 1)`.

    **Returns**

    The list of breakpoints.
  </Attribute>

  ### coeffs

  <Attribute id="qiskit.circuit.library.PiecewisePolynomialPauliRotations.coeffs">
    The coefficients of the polynomials.

    **Returns**

    The polynomial coefficients per interval as nested lists.
  </Attribute>

  ### contains\_zero\_breakpoint

  <Attribute id="qiskit.circuit.library.PiecewisePolynomialPauliRotations.contains_zero_breakpoint">
    Whether 0 is the first breakpoint.

    **Returns**

    True, if 0 is the first breakpoint, otherwise False.
  </Attribute>

  ### mapped\_coeffs

  <Attribute id="qiskit.circuit.library.PiecewisePolynomialPauliRotations.mapped_coeffs">
    The coefficients mapped to the internal representation, since we only compare x>=breakpoint.

    **Returns**

    The mapped coefficients.
  </Attribute>

  ### name

  <Attribute id="qiskit.circuit.library.PiecewisePolynomialPauliRotations.name" attributeTypeHint="str">
    A human-readable name for the circuit.

    **Example**

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2, 2, name="my_circuit")
    print(qc.name)
    ```

    ```text
    my_circuit
    ```
  </Attribute>

  ## Methods

  ### evaluate

  <Function id="qiskit.circuit.library.PiecewisePolynomialPauliRotations.evaluate" github="https://github.com/Qiskit/qiskit/tree/stable/2.1/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py#L202-L216" signature="evaluate(x)">
    Classically evaluate the piecewise polynomial rotation.

    **Parameters**

    **x** ([*float*](https://docs.python.org/3/library/functions.html#float)) – Value to be evaluated at.

    **Returns**

    Value of piecewise polynomial function at x.

    **Return type**

    [float](https://docs.python.org/3/library/functions.html#float)
  </Function>
</Class>

