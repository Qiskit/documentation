---
title: NaturalGradient
description: API reference for qiskit.opflow.gradients.NaturalGradient
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.opflow.gradients.NaturalGradient
---

# NaturalGradient

<Class id="qiskit.opflow.gradients.NaturalGradient" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.20/qiskit/opflow/gradients/natural_gradient.py" signature="NaturalGradient(grad_method='lin_comb', qfi_method='lin_comb_full', regularization=None, **kwargs)" modifiers="class">
  Bases: `qiskit.opflow.gradients.gradient_base.GradientBase`

  Convert an operator expression to the first-order gradient.

  Given an ill-posed inverse problem

  > x = arg min\{||Ax-C||^2} (1)

  one can use regularization schemes can be used to stabilize the system and find a numerical solution

  > x\_lambda = arg min\{||Ax-C||^2 + lambda\*R(x)} (2)

  where R(x) represents the penalization term.

  **Parameters**

  *   **grad\_method** (`Union`\[`str`, `CircuitGradient`]) – The method used to compute the state gradient. Can be either `'param_shift'` or `'lin_comb'` or `'fin_diff'`.
  *   **qfi\_method** (`Union`\[`str`, `CircuitQFI`]) – The method used to compute the QFI. Can be either `'lin_comb_full'` or `'overlap_block_diag'` or `'overlap_diag'`.
  *   **regularization** (`Optional`\[`str`]) – Use the following regularization with a least square method to solve the underlying system of linear equations Can be either None or `'ridge'` or `'lasso'` or `'perturb_diag'` `'ridge'` and `'lasso'` use an automatic optimal parameter search If regularization is None but the metric is ill-conditioned or singular then a least square solver is used without regularization
  *   **kwargs** (*dict*) – Optional parameters for a CircuitGradient

  ## Methods Defined Here

  ### convert

  <Function id="qiskit.opflow.gradients.NaturalGradient.convert" signature="NaturalGradient.convert(operator, params=None)">
    **Parameters**

    *   **operator** (`OperatorBase`) – The operator we are taking the gradient of.
    *   **params** (`Union`\[`ParameterVector`, `ParameterExpression`, `List`\[`ParameterExpression`], `None`]) – The parameters we are taking the gradient with respect to. If not explicitly passed, they are inferred from the operator and sorted by name.

    **Return type**

    `OperatorBase`

    **Returns**

    An operator whose evaluation yields the NaturalGradient.

    **Raises**

    *   **TypeError** – If `operator` does not represent an expectation value or the quantum state is not `CircuitStateFn`.
    *   **ValueError** – If `params` contains a parameter not present in `operator`.
    *   **ValueError** – If `operator` is not parameterized.
  </Function>

  ### nat\_grad\_combo\_fn

  <Function id="qiskit.opflow.gradients.NaturalGradient.nat_grad_combo_fn" signature="NaturalGradient.nat_grad_combo_fn(x, regularization=None)" modifiers="static">
    Natural Gradient Function Implementation.

    **Parameters**

    *   **x** (`tuple`) – Iterable consisting of Gradient, Quantum Fisher Information.
    *   **regularization** (`Optional`\[`str`]) – Regularization method.

    **Return type**

    `ndarray`

    **Returns**

    Natural Gradient.

    **Raises**

    **ValueError** – If the gradient has imaginary components that are non-negligible.
  </Function>

  ## Attributes

  ### grad\_method

  <Attribute id="qiskit.opflow.gradients.NaturalGradient.grad_method">
    Returns `CircuitGradient`.

    **Return type**

    `CircuitGradient`

    **Returns**

    `CircuitGradient`.
  </Attribute>

  ### qfi\_method

  <Attribute id="qiskit.opflow.gradients.NaturalGradient.qfi_method">
    Returns `CircuitQFI`.

    Returns: `CircuitQFI`.

    **Return type**

    `CircuitQFI`
  </Attribute>

  ### regularization

  <Attribute id="qiskit.opflow.gradients.NaturalGradient.regularization">
    Returns the regularization option.

    Returns: the regularization option.

    **Return type**

    `Optional`\[`str`]
  </Attribute>
</Class>

