---
title: Qiskit 0.43 release notes
description: Changes made in Qiskit 0.43
in_page_toc_max_heading_level: 4
---

# Qiskit 0.43 release notes

## 0.43.3

<span id="terra-0-24-2" />

### Terra 0.24.2

<span id="release-notes-0-24-2-prelude" />

<span id="id4" />

#### Prelude

Qiskit Terra 0.24.2 is a bugfix release, addressing some minor issues identified since the 0.24.1 release.

<span id="release-notes-0-24-2-upgrade-notes" />

<span id="id5" />

#### Upgrade Notes

*   The QPY format version emitted by `dump` has increased to 8. This new format version adds support for serializing the [`QuantumCircuit.layout`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribute.

<span id="release-notes-0-24-2-bug-fixes" />

<span id="id6" />

#### Bug Fixes

*   Fixed the deserialization of [`DiagonalGate`](/api/qiskit/0.45/qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate") instances through QPY. Fixed [#10364](https://github.com/Qiskit/qiskit-terra/issues/10364)

*   Fixed an issue with the `qs_decomposition()` function, which does quantum Shannon decomposition, when it was called on trivial numeric unitaries that do not benefit from this decomposition, an unexpected error was raised. This error has been fixed so that such unitaries are detected and the equivalent circuit is returned. Fixed [#10036](https://github.com/Qiskit/qiskit-terra/issues/10036)

*   Fixed an issue in the the [`BasicSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.BasicSwap "qiskit.transpiler.passes.BasicSwap") class that prevented the [`BasicSwap.run()`](/api/qiskit/0.45/qiskit.transpiler.passes.BasicSwap#run "qiskit.transpiler.passes.BasicSwap.run") method from functioning if the `fake_run` keyword argument was set to `True` when the class was instantiated. Fixed [#10147](https://github.com/Qiskit/qiskit-terra/issues/10147)

*   Fixed an issue with copying circuits with new-style [`Clbit`](/api/qiskit/0.45/qiskit.circuit.Clbit "qiskit.circuit.Clbit")s and [`Qubit`](/api/qiskit/0.45/qiskit.circuit.Qubit "qiskit.circuit.Qubit")s (bits without registers) where references to these bits from the containing circuit could be broken, causing issues with serialization and circuit visualization. Fixed [#10409](https://github.com/Qiskit/qiskit-terra/issues/10409)

*   The [`CheckMap`](/api/qiskit/0.45/qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap") transpiler pass will no longer spuriously error when dealing with nested conditional structures created by the control-flow builder interface. See [#10394](https://github.com/Qiskit/qiskit-terra/issues/10394).

*   Fixed an failure of the [Pulse Builder](/api/qiskit/0.45/pulse#pulse-builder) when the context is initialized with [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

*   Fixed the output of pulse [`measure()`](/api/qiskit/0.45/pulse#qiskit.pulse.builder.measure "qiskit.pulse.builder.measure") and [`measure_all()`](/api/qiskit/0.45/pulse#qiskit.pulse.builder.measure_all "qiskit.pulse.builder.measure_all") when functions are called with the [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend.

*   Fixed the dimensions of the output density matrix from [`DensityMatrix.partial_transpose()`](/api/qiskit/0.45/qiskit.quantum_info.DensityMatrix#partial_transpose "qiskit.quantum_info.DensityMatrix.partial_transpose") so they match the dimensions of the corresponding input density matrix.

*   Importing [`qiskit.primitives`](/api/qiskit/0.45/primitives#module-qiskit.primitives "qiskit.primitives") will no longer cause deprecation warnings stemming from the deprecated [`qiskit.opflow`](/api/qiskit/0.45/opflow#module-qiskit.opflow "qiskit.opflow") module. These warnings would have been hidden to users by the default Python filters, but triggered the eager import of [`opflow`](/api/qiskit/0.45/opflow#module-qiskit.opflow "qiskit.opflow"), which meant that a subsequent import by a user would not trigger the warnings. Fixed [#10245](https://github.com/Qiskit/qiskit-terra/issues/10245)

*   Fixed the OpenQASM 2 output of [`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") when a custom gate object contained a gate with the same name. Ideally this shouldn’t happen for most gates, but complex algorithmic operations like the [`GroverOperator`](/api/qiskit/0.45/qiskit.circuit.library.GroverOperator "qiskit.circuit.library.GroverOperator") class could produce such structures accidentally. See [#10162](https://github.com/Qiskit/qiskit-terra/issues/10162).

*   Fixed a regression in the LaTeX drawer of [`QuantumCircuit.draw()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") when temporary files are placed on a separate filesystem to the working directory. See [#10211](https://github.com/Qiskit/qiskit-terra/issues/10211).

*   Fixed an issue with [`UnitarySynthesis`](/api/qiskit/0.45/qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") when using the `target` parameter where circuits with control flow were not properly mapped to the target.

*   Fixed bug in [`VQD`](/api/qiskit/0.45/qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") where `result.optimal_values` was a copy of `result.optimal_points`. It now returns the corresponding values. Fixed [#10263](https://github.com/Qiskit/qiskit-terra/issues/10263)

*   Improved the error messages returned when an attempt to convert a fully bound [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") into a concrete `float` or `int` failed, for example because the expression was naturally a complex number. Fixed [#9187](https://github.com/Qiskit/qiskit-terra/issues/9187)

*   Fixed `float` conversions for [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") values which had, at some point in their construction history, an imaginary component that had subsequently been cancelled. When using Sympy as a backend, these conversions would usually already have worked. When using Symengine as the backend, these conversions would often fail with type errors, despite the result having been symbolically evaluated to be real, and [`ParameterExpression.is_real()`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression#is_real "qiskit.circuit.ParameterExpression.is_real") being true. Fixed [#10191](https://github.com/Qiskit/qiskit-terra/issues/10191)

*   Fixed the [`qpy`](/api/qiskit/0.45/qpy#module-qiskit.qpy "qiskit.qpy") serialization of [`QuantumCircuit.layout`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribue. Previously, the [`layout`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout") attribute would have been dropped when serializing a circuit to QPY. Fixed [#10112](https://github.com/Qiskit/qiskit-terra/issues/10112)

<span id="aer-0-12-2" />

<span id="release-notes-aer-0-12-2" />

### Aer 0.12.2

<span id="release-notes-aer-0-12-2-prelude" />

<span id="id7" />

#### Prelude

Qiskit Aer 0.12.2 is the second patch release to 0.12.0. This fixes some bugs that have been discovered since the release of 0.12.1.

<span id="release-notes-aer-0-12-2-upgrade-notes" />

<span id="id8" />

#### Upgrade Notes

*   Qiskit Aer now requires CUDA version for GPU simulator to 11.2 or higher. Previously, CUDA 10.1 was the minimum supported version. This change was necessary because of changes in the upstream CUDA ecosystem, including cuQuantum support. To support users running with different versions of CUDA there is now a separate package available for running with CUDA 11: `qiskit-aer-gpu-cu11` and using the `qiskit-aer-gpu` package now requires CUDA 12. If you’re an existing user of the `qiskit-aer-gpu` package and want to use CUDA 11 you will need to run:

    ```python
    pip uninstall qiskit-aer-gpu && pip install -U qiskit-aer-gpu-cu11
    ```

    to go from the previously CUDA 10.x compatible `qiskit-aer-gpu` package’s releases to upgrade to the new CUDA 11 compatible package. If you’re running CUDA 12 locally already you can upgrade the `qiskit-aer-gpu` package as normal.

<span id="release-notes-aer-0-12-2-bug-fixes" />

<span id="id9" />

#### Bug Fixes

*   If a circuit has conditional and parameters, the circuit was not be correctly simulated because parameter bindings of Aer used wrong positions to apply parameters. This is from a lack of consideration of bfunc operations injected by conditional. With this commit, parameters are set to correct positions with consideration of injected bfun operations.

*   Parameters for global phases were not correctly set in #1814. [https://github.com/Qiskit/qiskit-aer/pull/1814](https://github.com/Qiskit/qiskit-aer/pull/1814) Parameter values for global phases were copied to a template circuit and not to actual circuits to be simulated. This commit correctly copies parameter values to circuits to be simulated.

*   Results of `backend.run()` were not serializable because they include `AerCircuit`s. This commit makes the results serializable by removing `AerCircuit`s from metadata.

*   :meth:`QuantumCircuit.save_statevector()` does not work if the circuit is generated from OpenQASM3 text because its quantum registers have duplicated qubit instances. With this commit, :meth:`QuantumCircuit.save_statevector()` uses :data:`QuantumCircuit.qubits` to get qubits to be saved.

<span id="ibm-q-provider-0-20-2" />

### IBM Q Provider 0.20.2

No change.

<span id="qiskit-0-43-2" />

## 0.43.2

As a reminder, [Qiskit Aer](https://qiskit.org/ecosystem/aer/)’s inclusion in the `qiskit` package is deprecated. The next minor version of Qiskit Aer (0.13) will not be included in any release of the `qiskit` package, and you should immediately begin installing Aer separately by:

```python
pip install qiskit-aer
```

and importing it as:

```python
import qiskit_aer
```

Starting from Qiskit 0.44, the command `pip install qiskit` will no longer install Qiskit Aer, or the obsolete IBM Q Provider that has already been replaced by the new [IBM Provider](../../qiskit-ibm-provider).

<span id="terra-0-24-1" />

<span id="release-notes-0-24-2" />

### Terra 0.24.1

No change

<span id="aer-0-12-1" />

### Aer 0.12.1

<span id="release-notes-aer-0-12-1-prelude" />

<span id="id10" />

#### Prelude

Qiskit Aer 0.12.1 is the first patch release to 0.12.0. This fixes some bugs that have been discovered since the release of 0.12.0.

<span id="release-notes-aer-0-12-1-known-issues" />

<span id="id11" />

#### Known Issues

*   Fix a bug that returns wrong expectation values in `Estimator` when `abelian_grouping=True`.

<span id="release-notes-aer-0-12-1-upgrade-notes" />

<span id="id12" />

#### Upgrade Notes

*   Improved performance when the same circuits and multiple parameters are passed to [`Estimator`](/api/qiskit/0.45/qiskit.primitives.Estimator "qiskit.primitives.Estimator") with `approximation=True`.

<span id="release-notes-aer-0-12-1-deprecation-notes" />

<span id="id13" />

#### Deprecation Notes

*   Options of meth:\~.AerSimulator.run need to use correct types.

<span id="release-notes-aer-0-12-1-bug-fixes" />

<span id="id14" />

#### Bug Fixes

*   Performance regression due to introduction of `AER::Config` is fixed. This class has many fields but is frequently copied in `AER::Transpile::CircuitOptimization`. Originally `json_t` (former class for configuration) was also frequently copied but it does have entries in most cases and then this copy overhead is not a problem. With this fix, `AER::Transpile::CircuitOptimization` does not copy `AER::Config`.

*   When BLAS calls are failed, because omp threads do not handle exceptions, Aer crashes without any error messages. This fix is for omp threads to catch exceptions correctly and then rethrow them outside of omp loops.

*   Previously, parameters for gates are not validate in C++. If parameters are shorter than expected (due to custom gate), segmentaion faults are thrown. This commit adds checks whether parameter lenght is expceted. This commit will fix issues reported in #1612. [https://github.com/Qiskit/qiskit-aer/issues/1612](https://github.com/Qiskit/qiskit-aer/issues/1612)

*   Since 0.12.0, parameter values in circuits are temporarily replaced with constant values and parameter values are assigned in C++ library. Therefore, if parameter\_binds is specified, simulator returns results with the constnat values as paramter values. With this commit, Aer raises an error if parameter\_binds is not specified though circuits have parameters.

*   Available devices and methods are no longer queried when importing Aer.

*   Previously `AerSimulator` modifies circuit metadata to maintain consistency between input and output of simulation with side effect of unexpected view of metadata from applicatiln in simiulation. This fix avoids using circuit metadata to maintain consistency internaly and then always provides consistent view of metadata to application.

*   Fixed a bug where the variance in metadata in EstimatorResult was complex and now returns float.

*   Fixed a build break to compile Qiskit Aer with cuQuautum support (AER\_ENABLE\_CUQUANTUM=true). This change does not affect build for CPU and normal GPU binaries.

*   Fixed a bug in `from_backend()` that raised an error when the backend has no T1 and T2 values (i.e. None) for a qubit in its qubit properties. This commit updates `NoiseModel.from_backend()` and `basic_device_gate_errors()` so that they add an identity `QuantumError` (i.e. effectively no thermal relaxation error) to a qubit with no T1 and T2 values for all gates acting on qubits including the qubit. Fixed [#1779](https://github.com/Qiskit/qiskit-aer/issues/1779) and [#1815](https://github.com/Qiskit/qiskit-aer/issues/1815).

*   Fix an issue even if the number of qubits is set by a coupling map or device’s configuration, when the simulation method is configured, the number of qubits is overwritten in accordance with the method. Fixed [#1769](https://github.com/Qiskit/qiskit-aer/issues/1769)

*   This is fix for library path setting in CMakeLists.txt for cuQuantum SDK. Because the latest cuQuantum includes libraries for CUDA 11.x and 12.x, this fix uses CUDA version returned from FindCUDA to the path of libraries of cuQuantum and cuTENSOR.

*   This is fix for static link libraries of cuQuantum when building with CUQUANTUM\_STATIC=true.

*   MPI parallelization was not enabled since we have not used qobj. This fix sets the number of processes and MPI rank correctly.

*   `AerCircuit` is created from a circuit by iterating its operations while skipping barrier instructions. However, skipping barrier instructions make wrong positionings of parameter bindings. This fix adds `barrier()` and keeps parametr bindings correct.

*   Aer still supports Qobj as an argument of `run()` though it was deprecated. However, since 0.12.0, it always fails if no `run_options` is specified. This fix enables simulation of Qobj without `run_options`.

*   Since 0.12.0, `AerConfig` is used for simulation configuration while performing strict type checking for arguments of meth:\~.AerSimulator.run. This commit adds casting if argument types are not expected.

*   :meth:`QuantumCircuit.initialize()` with int value was not processed correctly as reported in #1821 \<[https://github.com/Qiskit/qiskit-aer/issues/1821](https://github.com/Qiskit/qiskit-aer/issues/1821)>. This commit enables such initialization by decomposing initialize instructions.

*   [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") supports parameterization for its global\_phase. However, Aer has not allowed such parameterization and failed when transpiler generates parameterized global phases. This commit supports parameterization of global\_phase and resolve issues related to [https://github.com/Qiskit/qiskit-aer/issues/1795](https://github.com/Qiskit/qiskit-aer/issues/1795), [https://github.com/Qiskit/qiskit-aer/issues/1781](https://github.com/Qiskit/qiskit-aer/issues/1781), and [https://github.com/Qiskit/qiskit-aer/issues/1798](https://github.com/Qiskit/qiskit-aer/issues/1798).

*   Aer will now use `omp_set_max_active_levels()` instead of the deprecated `omp_set_nested()` when compiled against recent versions of OpenMP.

<span id="id15" />

### IBM Q Provider 0.20.2

No change.

<span id="qiskit-0-43-1" />
## 0.43.1

<span id="release-notes-terra-0-24-1" />

<span id="id16" />

### Terra 0.24.1

<span id="release-notes-terra-0-24-1-prelude" />

<span id="id17" />

#### Prelude

Qiskit Terra 0.24.1 is the first patch release to 0.24.0. This fixes some bugs that have been discovered since the release of 0.24.0.

<span id="release-notes-terra-0-24-1-upgrade-notes" />

<span id="id18" />

#### Upgrade Notes

*   Changed [`QuantumCircuit.assign_parameters()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to bind assigned integer and float values directly into the parameters of [`Instruction`](/api/qiskit/0.45/qiskit.circuit.Instruction "qiskit.circuit.Instruction") instances in the circuit rather than binding the values wrapped within a [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"). This change should have little user impact as `float(QuantumCircuit.data[i].operation.params[j])` still produces a `float` (and is the only way to access the value of a [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")). Also, [`Instruction()`](/api/qiskit/0.45/qiskit.circuit.Instruction "qiskit.circuit.Instruction") parameters could already be `float` as well as a [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"), so code dealing with instruction parameters should already handle both cases. The most likely chance for user impact is in code that uses `isinstance` to check for [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") and behaves differently depending on the result. Additionally, qpy serializes the numeric value in a bound [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") at a different precision than a `float` (see also the related bug fix note about [`QuantumCircuit.assign_parameters()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters")).

<span id="release-notes-terra-0-24-1-bug-fixes" />

<span id="id19" />

#### Bug Fixes

*   Updated [`plot_gate_map()`](/api/qiskit/0.45/qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map"), [`plot_error_map()`](/api/qiskit/0.45/qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map"), and [`plot_circuit_layout()`](/api/qiskit/0.45/qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout") to support 433 qubit heavy-hex coupling maps. This allows coupling map visualizations for IBM Quantum’s `ibm_seattle` backend.

*   Changed the binding of numeric values with [`QuantumCircuit.assign_parameters()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") to avoid a mismatch between the values of circuit instruction parameters and corresponding parameter keys in the circuit’s calibration dictionary. Fixed [#9764](https://github.com/Qiskit/qiskit-terra/issues/9764) and [#10166](https://github.com/Qiskit/qiskit-terra/issues/10166). See also the related upgrade note regarding [`QuantumCircuit.assign_parameters()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters").

*   Fixed a bug in `BlockCollapser` where classical bits were ignored when collapsing a block of nodes.

*   Fixed a bug in [`replace_block_with_op()`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit#replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op") and [`replace_block_with_op()`](/api/qiskit/0.45/qiskit.dagcircuit.DAGDependency#replace_block_with_op "qiskit.dagcircuit.DAGDependency.replace_block_with_op") that led to ignoring classical bits.

*   Fixed a bug in [`QuantumCircuit.compose()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") where the `SwitchCaseOp.target` attribute in the subcircuit was not correctly mapped to a register in the base circuit.

*   Fix a bug in [`RZXCalibrationBuilder`](/api/qiskit/0.45/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") where calling calibration with wrong parameters would crash instead of raising an exception.

*   Fixed an issue with the [`BooleanExpression.from_dimacs_file()`](/api/qiskit/0.45/qiskit.circuit.classicalfunction.BooleanExpression#from_dimacs_file "qiskit.circuit.classicalfunction.BooleanExpression.from_dimacs_file") constructor method where the exception type raised when tweedledum wasn’t installed was not the expected `MissingOptionalLibrary`. Fixed [#10079](https://github.com/Qiskit/qiskit-terra/issues/10079)

*   Using `initial_layout` in calls to [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will no longer error if the circuit contains qubits not in any registers, or qubits that exist in more than one register. See [#10125](https://github.com/Qiskit/qiskit-terra/issues/10125).

*   Fixed the gate decomposition of multi-controlled Z rotation gates added via [`QuantumCircuit.mcrz()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#mcrz "qiskit.circuit.QuantumCircuit.mcrz"). Previously, this method implemented a multi-controlled phase gate, which has a relative phase difference to the Z rotation. To obtain the previous [`QuantumCircuit.mcrz()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#mcrz "qiskit.circuit.QuantumCircuit.mcrz") behaviour, use [`QuantumCircuit.mcp()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#mcp "qiskit.circuit.QuantumCircuit.mcp").

*   Fixed an issue with the [`PassManagerConfig.from_backend()`](/api/qiskit/0.45/qiskit.transpiler.PassManagerConfig#from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor when building a [`PassManagerConfig`](/api/qiskit/0.45/qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object from a [`BackendV1`](/api/qiskit/0.45/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance that didn’t have a coupling map attribute defined. Previously, the constructor would incorrectly create a [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object with 0 qubits instead of using `None`. Fixed [#10171](https://github.com/Qiskit/qiskit-terra/issues/10171)

*   Fixes a bug introduced in Qiskit 0.24.0 where numeric rotation angles were no longer substituted for symbolic ones before preparing for two-qubit synthesis. This caused an exception to be raised because the synthesis routines require numberic matrices.

*   Fix a bug in which running [`Optimize1qGatesDecomposition`](/api/qiskit/0.45/qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") in parallel would raise an error due to OneQubitGateErrorMap not being picklable.

*   Fix a bug in the [`VF2Layout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") passes where the passes were failing to account for the 1 qubit error component when evaluating a potential layout.

<span id="aer-0-12-0" />

### Aer 0.12.0

No change

<span id="id22" />

### IBM Q Provider 0.20.2

No change

<span id="qiskit-0-43-0" />
## 0.43.0

<span id="terra-0-24-0" />

<span id="release-notes-terra-0-24-0" />

### Terra 0.24.0

<span id="release-notes-0-24-0-prelude" />

<span id="id23" />

#### Prelude

This is a major feature release that includes numerous new features and bugfixes.

This release is the final release with support for running Qiskit with Python 3.7. Starting in the next minor version release Python >=3.8 will be required to run Qiskit.

The highlights of this release:

##### QuantumInstance, OpFlow, and algorithms usage deprecation

This release officially deprecates the [`QuantumInstance`](/api/qiskit/0.45/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") class (and its associated helper methods and classes), the [`qiskit.opflow`](/api/qiskit/0.45/opflow#module-qiskit.opflow "qiskit.opflow") module, and any usage of those in [`qiskit.algorithms`](/api/qiskit/0.45/algorithms#module-qiskit.algorithms "qiskit.algorithms"). This deprecation comes from a long thread of work that started in Qiskit Terra 0.21.0 to refactor the [`qiskit.algorithms`](/api/qiskit/0.45/algorithms#module-qiskit.algorithms "qiskit.algorithms") module to be based on the computational [`primitives`](/api/qiskit/0.45/primitives#module-qiskit.primitives "qiskit.primitives"). There are associated migration guides for any existing users to migrate to the new workflow:

> *   `QuantumInstance` migration guide: [https://qisk.it/qi\_migration](https://qisk.it/qi_migration)
> *   `Opflow` migration guide: [https://qisk.it/opflow\_migration](https://qisk.it/opflow_migration)
> *   Algorithms migration guide: [https://qisk.it/algo\_migration](https://qisk.it/algo_migration)

##### OpenQASM2 improvements

This release includes a major refactoring for the OpenQASM 2.0 support in Qiskit. The first change is the introduction of a new parser for OpenQASM 2.0 in the [`qiskit.qasm2`](/api/qiskit/0.45/qasm2#module-qiskit.qasm2 "qiskit.qasm2") module. This new module replaces the existing [`qiskit.qasm`](/api/qiskit/0.45/qasm#module-qiskit.qasm "qiskit.qasm") module. The new parser is more explicit and correct with respect to the language specification. It is also implemented in Rust and is significantly faster than the previous parser. Paired with the new parser the OpenQASM 2.0 exporter underwent a large refactor that improved the correctness of the output when using the [`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm") method to generate QASM output from a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object.

##### Transpiler support for devices with disjoint connectivity

The transpiler now supports targeting backends with disjoint connectivity. Previously, the transpiler only supported backends which were fully connected (where there is a path to run operations between all pairs of qubits in the backend). Now, if a backend has disconnected connectivity the transpiler is able to reason about how to apply layout ([Layout Stage](/api/qiskit/0.45/transpiler#layout-stage)) and routing ([Routing Stage](/api/qiskit/0.45/transpiler#routing-stage)) for the backend. If the input circuit is not able to be executed on the hardware given the lack of connectivity between connected components, a descriptive error will be returned.

For example, the Heron device outlined in IBM Quantum’s [hardware roadmap](https://research.ibm.com/blog/ibm-quantum-roadmap-2025) describes a future backend which will have shared control hardware and real-time classical communication between separate quantum processors. This support enables the [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") to accurately model these types of future devices or other hardware with similar constraints.

##### Switch Operation

This release adds a new control flow operation, the switch statement. This is implemented using a new operation class [`SwitchCaseOp`](/api/qiskit/0.45/qiskit.circuit.SwitchCaseOp "qiskit.circuit.SwitchCaseOp") and the [`QuantumCircuit.switch()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#switch "qiskit.circuit.QuantumCircuit.switch") method. This allows switching on a numeric input (such as a classical register or bit) and executing the circuit that corresponds to the matching value.

<span id="release-notes-0-24-0-new-features" />

<span id="id24" />

#### New Features

*   Added the functions [`add_deprecation_to_docstring()`](/api/qiskit/0.45/utils#qiskit.utils.add_deprecation_to_docstring "qiskit.utils.add_deprecation_to_docstring"), [`deprecate_arg()`](/api/qiskit/0.45/utils#qiskit.utils.deprecate_arg "qiskit.utils.deprecate_arg"), and [`deprecate_func()`](/api/qiskit/0.45/utils#qiskit.utils.deprecate_func "qiskit.utils.deprecate_func") to the [`qiskit.utils`](/api/qiskit/0.45/utils#module-qiskit.utils "qiskit.utils") module.

    [`add_deprecation_to_docstring()`](/api/qiskit/0.45/utils#qiskit.utils.add_deprecation_to_docstring "qiskit.utils.add_deprecation_to_docstring") will rewrite the function’s docstring to include a Sphinx `.. deprecated::` directive so that the deprecation shows up in docs and with `help()`. The deprecation decorators from [`qiskit.utils`](/api/qiskit/0.45/utils#module-qiskit.utils "qiskit.utils") call [`add_deprecation_to_docstring()`](/api/qiskit/0.45/utils#qiskit.utils.add_deprecation_to_docstring "qiskit.utils.add_deprecation_to_docstring") already for you; but you can call it directly if you are using different mechanisms for deprecations.

    `@deprecate_func` replaces `@deprecate_function` and is used to deprecate an entire function. It will auto-generate most of the deprecation message for you.

    `@deprecate_arg` replaces `@deprecate_arguments` and is used to deprecate an argument on a function. It will generate a more useful message than the previous function. It is also more flexible, for example it allows setting a `predicate` so that you only deprecate certain situations, such as using a deprecated value or data type.

<span id="release-notes-0-24-0-transpiler-features" />

<span id="id25" />

##### Transpiler Features

*   Added an alternative way to specify in `HLSConfig` the list of synthesis methods used for a given high-level object. As before, a synthesis method can be specified as a tuple consisting of the name of the method and additional arguments. Additionally, a synthesis method can be specified as a tuple consisting of an instance of [`HighLevelSynthesisPlugin`](/api/qiskit/0.45/qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin") and additional arguments. Moreover, when there are no additional arguments, a synthesis method can be specified simply by name or by an instance of [`HighLevelSynthesisPlugin`](/api/qiskit/0.45/qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin"). The following example illustrates the new functionality:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit.library.generalized_gates import PermutationGate
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig, HighLevelSynthesis
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import ACGSynthesisPermutation

    qc = QuantumCircuit(6)
    qc.append(PermutationGate([1, 2, 3, 0]), [1, 2, 3, 4])

    # All of the ways to specify hls_config are equivalent
    hls_config = HLSConfig(permutation=[("acg", {})])
    hls_config = HLSConfig(permutation=["acg"])
    hls_config = HLSConfig(permutation=[(ACGSynthesisPermutation(), {})])
    hls_config = HLSConfig(permutation=[ACGSynthesisPermutation()])

    # The hls_config can then be passed as an argument to HighLevelSynthesis
    pm = PassManager(HighLevelSynthesis(hls_config=hls_config))
    qc_synthesized = pm.run(qc)
    ```

*   Added support to the [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object to have a disjoint connectivity. Previously, a [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") could only be constructed if the graph was connected. This will enable using [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") to represent hardware with disjoint qubits, such as hardware with qubits on multiple separate chips.

*   Added a new method [`CouplingMap.connected_components()`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap#connected_components "qiskit.transpiler.CouplingMap.connected_components") which is used to get a list of [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") component subgraphs for a disjoint [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"). If the [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") object is connected this will just return a single [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") equivalent to the original.

*   Added new rules to the built-in [`EquivalenceLibrary`](/api/qiskit/0.45/qiskit.circuit.EquivalenceLibrary "qiskit.circuit.EquivalenceLibrary") instance: `qiskit.circuit.equivalence_library.SessionEquivalenceLibrary`. The new rules added are:

    > *   [`CXGate`](/api/qiskit/0.45/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") into [`ECRGate`](/api/qiskit/0.45/qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") and 1-qubit Clifford gates (up to a global phase).
    > *   [`HGate`](/api/qiskit/0.45/qiskit.circuit.library.HGate "qiskit.circuit.library.HGate") into [`SXGate`](/api/qiskit/0.45/qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") and [`SGate`](/api/qiskit/0.45/qiskit.circuit.library.SGate "qiskit.circuit.library.SGate") (up to a global phase).
    > *   [`HGate`](/api/qiskit/0.45/qiskit.circuit.library.HGate "qiskit.circuit.library.HGate") into [`SXdgGate`](/api/qiskit/0.45/qiskit.circuit.library.SXdgGate "qiskit.circuit.library.SXdgGate") and [`SdgGate`](/api/qiskit/0.45/qiskit.circuit.library.SdgGate "qiskit.circuit.library.SdgGate") (up to a global phase).

*   Added high-level-synthesis plugins for [`LinearFunction`](/api/qiskit/0.45/qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") and for [`qiskit.quantum_info.Clifford`](/api/qiskit/0.45/qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), extending the set of synthesis methods that can be called from [`HighLevelSynthesis`](/api/qiskit/0.45/qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass.

    For [`LinearFunction`](/api/qiskit/0.45/qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") the available plugins are listed below:

    | Plugin name | High-level synthesis plugin      |
    | ----------- | -------------------------------- |
    | `default`   | `DefaultSynthesisLinearFunction` |
    | `kms`       | `KMSSynthesisLinearFunction`     |
    | `pmh`       | `PMHSynthesisLinearFunction`     |

    For [`qiskit.quantum_info.Clifford`](/api/qiskit/0.45/qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") the available plugins are listed below:

    | Plugin name | High-level synthesis plugin |
    | ----------- | --------------------------- |
    | `default`   | `DefaultSynthesisClifford`  |
    | `ag`        | `AGSynthesisClifford`       |
    | `bm`        | `BMSynthesisClifford`       |
    | `greedy`    | `GreedySynthesisClifford`   |
    | `layers`    | `LayerSynthesisClifford`    |
    | `lnn`       | `LayerLnnSynthesisClifford` |

    Please refer to [`qiskit.synthesis`](/api/qiskit/0.45/synthesis#module-qiskit.synthesis "qiskit.synthesis") documentation for more information about each individual method.

    The following example illustrates some of the new plugins:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import LinearFunction
    from qiskit.quantum_info import Clifford
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig, HighLevelSynthesis

    # Create a quantum circuit with one linear function and one clifford
    qc1 = QuantumCircuit(3)
    qc1.cx(0, 1)
    qc1.swap(0, 2)
    lin_fun = LinearFunction(qc1)

    qc2 = QuantumCircuit(3)
    qc2.h(0)
    qc2.cx(0, 2)
    cliff = Clifford(qc2)

    qc = QuantumCircuit(4)
    qc.append(lin_fun, [0, 1, 2])
    qc.append(cliff, [1, 2, 3])

    # Choose synthesis methods that adhere to linear-nearest-neighbour connectivity
    hls_config = HLSConfig(linear_function=["kms"], clifford=["lnn"])

    # Synthesize
    qct = HighLevelSynthesis(hls_config)(qc)
    print(qct.decompose())
    ```

*   Added a new transpiler pass, [`MinimumPoint`](/api/qiskit/0.45/qiskit.transpiler.passes.MinimumPoint "qiskit.transpiler.passes.MinimumPoint") which is used primarily as a pass to check a loop condition in a [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). This pass will track the state of fields in the property set over its past executions and set a boolean field when either a fixed point is reached over the backtracking depth or selecting the minimum value found if the backtracking depth is reached. This is an alternative to the [`FixedPoint`](/api/qiskit/0.45/qiskit.transpiler.passes.FixedPoint "qiskit.transpiler.passes.FixedPoint") which simply checks for a fixed value in a property set field between subsequent executions.

*   Added a new method, [`swap_nodes()`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit#swap_nodes "qiskit.dagcircuit.DAGCircuit.swap_nodes"), to the [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to allow swapping nodes which are partially connected. Partially connected here means that the two nodes share at least one edge (which represents a qubit or clbit). If the nodes do not share any edges a [`DAGCircuitError`](/api/qiskit/0.45/dagcircuit#qiskit.dagcircuit.DAGCircuitError "qiskit.dagcircuit.DAGCircuitError") is raised.

*   Add a new synthesis algorithm [`synth_cz_depth_line_mr()`](/api/qiskit/0.45/synthesis#qiskit.synthesis.synth_cz_depth_line_mr "qiskit.synthesis.synth_cz_depth_line_mr") of a CZ circuit for linear nearest neighbor (LNN) connectivity in 2-qubit depth of 2n+2 using CX and phase gates (S, Sdg or Z). The synthesized circuit reverts the order of the qubits. The synthesis algorithm is based on the paper of Maslov and Roetteler ([https://arxiv.org/abs/1705.09176](https://arxiv.org/abs/1705.09176)).

*   Add a new synthesis algorithm [`synth_clifford_depth_lnn()`](/api/qiskit/0.45/synthesis#qiskit.synthesis.synth_clifford_depth_lnn "qiskit.synthesis.synth_clifford_depth_lnn") of a Clifford circuit for LNN connectivity in 2-qubit depth of 9n+4 (which is still not optimal), using the layered Clifford synthesis ([`synth_clifford_layers()`](/api/qiskit/0.45/synthesis#qiskit.synthesis.synth_clifford_layers "qiskit.synthesis.synth_clifford_layers")), [`synth_cnot_depth_line_kms()`](/api/qiskit/0.45/synthesis#qiskit.synthesis.synth_cnot_depth_line_kms "qiskit.synthesis.synth_cnot_depth_line_kms") to synthesize the CX layer in depth 5n, and [`synth_cz_depth_line_mr()`](/api/qiskit/0.45/synthesis#qiskit.synthesis.synth_cz_depth_line_mr "qiskit.synthesis.synth_cz_depth_line_mr") to synthesize each of the CZ layers in depth 2n+2. This PR will be followed by another PR based on the recent paper of Maslov and Yang ([https://arxiv.org/abs/2210.16195](https://arxiv.org/abs/2210.16195)), that synthesizes the CX-CZ layers in depth 5n for LNN connectivity and performs further optimization, and hence reduces the depth of a Clifford circuit to 7n-4 for LNN connectivity.

*   Equivalences between the controlled Pauli rotations and translations to two-Pauli rotations are now available in the equivalence library for Qiskit standard gates. This allows, for example, to translate a [`CRZGate`](/api/qiskit/0.45/qiskit.circuit.library.CRZGate "qiskit.circuit.library.CRZGate") to a [`RZZGate`](/api/qiskit/0.45/qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") plus [`RZGate`](/api/qiskit/0.45/qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate") or a [`CRYGate`](/api/qiskit/0.45/qiskit.circuit.library.CRYGate "qiskit.circuit.library.CRYGate") to a single [`RZXGate`](/api/qiskit/0.45/qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate") plus single qubit gates:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.compiler import transpile

    angle = 0.123
    circuit = QuantumCircuit(2)
    circuit.cry(angle, 0, 1)

    basis = ["id", "sx", "x", "rz", "rzx"]
    transpiled = transpile(circuit, basis_gates=basis)
    print(transpiled.draw())
    ```

*   Added a new option, `copy_operations`, to [`circuit_to_dag()`](/api/qiskit/0.45/converters#qiskit.converters.circuit_to_dag "qiskit.converters.circuit_to_dag") to enable optionally disabling deep copying the operations from the input [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") to the output [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). In cases where the input :class\`\~.QuantumCircuit\` is not used anymore after conversion this deep copying is unnecessary overhead as any shared references wouldn’t have any potential unwanted side effects if the input [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") is discarded.

*   Added a new option, `copy_operations`, to [`dag_to_circuit()`](/api/qiskit/0.45/converters#qiskit.converters.dag_to_circuit "qiskit.converters.dag_to_circuit") to enable optionally disabling deep copying the operations from the input [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to the output [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). In cases where the input [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is not used anymore after conversion this deep copying is unnecessary overhead as any shared references wouldn’t have any potential unwanted side effects if the input [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is discarded.

*   Added a new function [`passmanager_stage_plugins()`](/api/qiskit/0.45/transpiler_plugins#qiskit.transpiler.preset_passmanagers.plugin.passmanager_stage_plugins "qiskit.transpiler.preset_passmanagers.plugin.passmanager_stage_plugins") to the [`qiskit.transpiler.preset_passmanagers.plugin`](/api/qiskit/0.45/transpiler_plugins#module-qiskit.transpiler.preset_passmanagers.plugin "qiskit.transpiler.preset_passmanagers.plugin") module. This function is used to obtain a mapping from plugin names to their their class type. This enables identifying and querying any defined pass manager stage plugin’s documentation. For example:

    ```python
    >>> from qiskit.transpiler.preset_passmanagers.plugin import passmanager_stage_plugins
    >>> passmanager_stage_plugins('routing')['lookahead'].__class__

    qiskit.transpiler.preset_passmanagers.builtin_plugins.LookaheadSwapPassManager

    >>> help(passmanager_stage_plugins('routing')['lookahead'])
    Help on BasicSwapPassManager in module qiskit.transpiler.preset_passmanagers.builtin_plugins object:

    class BasicSwapPassManager(qiskit.transpiler.preset_passmanagers.plugin.PassManagerStagePlugin)
    |  Plugin class for routing stage with :class:`~.BasicSwap`
    ...
    ```

*   The transpiler pass `Error` now also accepts callable inputs for its `msg` parameter. If used these input callables will be passed the `property_set` attribute of the pass and are expected to return a string which will be used for the error message when the pass is run. For example:

    ```python
    from qiskit.transpiler.passes import Error

    def error_message(property_set):

        size = property_set["size']
        return f"The circuit size is: {size}"

    error_pass = Error(error_message)
    ```

    When `error_pass` is included in a pass manager it will error using the message `"The circuit size is: n"` where `n` is the circuit size set in the property set (typically from the previous execution of the [`Size`](/api/qiskit/0.45/qiskit.transpiler.passes.Size "qiskit.transpiler.passes.Size") pass).

*   The [`build_coupling_map()`](/api/qiskit/0.45/qiskit.transpiler.Target#build_coupling_map "qiskit.transpiler.Target.build_coupling_map") method has a new keyword argument, `filter_idle_qubits` which when set to `True` will remove any qubits from the output [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") that don’t support any operations.

*   The [`GateDirection`](/api/qiskit/0.45/qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") transpiler pass can now correctly handle [`SwapGate`](/api/qiskit/0.45/qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") instances that may be present in the circuit when executing on a circuit. In these cases if the swap gate’s qubit arguments are on the non-native direction of an edge, the pass will flip the argument order.

*   The [`RZXCalibrationBuilder`](/api/qiskit/0.45/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") and [`RZXCalibrationBuilderNoEcho`](/api/qiskit/0.45/qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") transpiler passes now will correctly use an [`ECRGate`](/api/qiskit/0.45/qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate") for the entangling gate if the backend’s native entangling gate is [`ECRGate`](/api/qiskit/0.45/qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate"). Previously, the passes would only function correctly if the entangling gate was [`CXGate`](/api/qiskit/0.45/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate").

*   Added a new constructor for the [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") class, [`Target.from_configuration()`](/api/qiskit/0.45/qiskit.transpiler.Target#from_configuration "qiskit.transpiler.Target.from_configuration"), which lets you construct a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object from the separate object types for describing the constraints of a backend (e.g. basis gates, [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"), [`BackendProperties`](/api/qiskit/0.45/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties"), etc). For example:

    ```python
    target = Target.from_configuration(
        basis_gates=["u", "cx", "measure"],
        coupling_map=CouplingMap.from_line(25),
    )
    ```

    This will construct a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object that has [`UGate`](/api/qiskit/0.45/qiskit.circuit.library.UGate "qiskit.circuit.library.UGate"), [`CXGate`](/api/qiskit/0.45/qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate"), and [`Measure`](/api/qiskit/0.45/qiskit.circuit.library.Measure "qiskit.circuit.library.Measure") globally available on 25 qubits which are connected in a line.

*   Added a new function `synth_cnot_phase_aam()` which is used to synthesize cnot phase circuits for all-to-all architectures using the Amy, Azimzadeh, and Mosca method. This function is identical to the available `qiskit.transpiler.synthesis.graysynth()` function but has a more descriptive name and is more logically placed in the package tree. This new function supersedes the legacy function which will likely be deprecated in a future release.

*   Internal tweaks to the routing algorithm in [`SabreSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"), used in transpilation of non-dynamic circuits at all non-zero optimization levels, have sped up routing for very large circuits. For example, the time to route a depth-5 [`QuantumVolume`](/api/qiskit/0.45/qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") circuit for a 1081-qubit heavy-hex coupling map is approximately halved.

*   The runtime performance of the [`Optimize1qGatesDecomposition`](/api/qiskit/0.45/qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") transpiler pass has been significantly improved. This was done by both rewriting all the computation for the pass in Rust and also decreasing the amount of intermediate objects created as part of the pass’s execution. This should also correspond to a similar improvement in the runtime performance of [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with the `optimization_level` keyword argument set to `1`, `2`, or `3`.

*   Add a new synthesis method [`synth_stabilizer_layers()`](/api/qiskit/0.45/synthesis#qiskit.synthesis.synth_stabilizer_layers "qiskit.synthesis.synth_stabilizer_layers") of a stabilizer state into layers. It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov, (arxiv:2003.09412) without the initial Hadamard-free sub-circuit which does not affect the stabilizer state.

*   Add a new synthesis method `synth_stabilizer_lnn()` of a stabilizer state for linear nearest neighbor connectivity in 2-qubit depth of 2n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z). The synthesis algorithm is based on the paper of Maslov and Roetteler ([https://arxiv.org/abs/1705.09176](https://arxiv.org/abs/1705.09176)).

*   The [`SabreLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") pass now supports running against a target with a disjoint [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"). When targeting a disjoint coupling the input [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is split into its connected components of virtual qubits, each component is mapped to the connected components of the [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"), layout is run on each connected component in isolation, and then all layouts are combined and returned. Note when the `routing_pass` argument is set the pass doesn’t support running with disjoint connectivity.

*   The following layout and routing transpiler passes from the [`qiskit.transpiler.passes`](/api/qiskit/0.45/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") modules now will support accepting a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object which is used to model the constraints of a target backend via the first positional argument (currently named either `coupling_map` or `backend_properties`).

    The list of passes with the new support for [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") input are:

    > *   [`CSPLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout")
    > *   [`FullAncillaAllocation`](/api/qiskit/0.45/qiskit.transpiler.passes.FullAncillaAllocation "qiskit.transpiler.passes.FullAncillaAllocation")
    > *   [`Layout2qDistance`](/api/qiskit/0.45/qiskit.transpiler.passes.Layout2qDistance "qiskit.transpiler.passes.Layout2qDistance")
    > *   [`NoiseAdaptiveLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.NoiseAdaptiveLayout "qiskit.transpiler.passes.NoiseAdaptiveLayout")
    > *   [`SabreLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout")
    > *   [`TrivialLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.TrivialLayout "qiskit.transpiler.passes.TrivialLayout")
    > *   [`BasicSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.BasicSwap "qiskit.transpiler.passes.BasicSwap")
    > *   `BIPMapping`
    > *   `LayoutTransformation`
    > *   [`LookaheadSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap")
    > *   [`SabreSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")
    > *   [`StochasticSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap")
    > *   [`CheckMap`](/api/qiskit/0.45/qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap")

*   The pass manager construction helper function [`generate_embed_passmanager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.common.generate_embed_passmanager "qiskit.transpiler.preset_passmanagers.common.generate_embed_passmanager") will now also accept a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") for it’s sole positional argument (currently named `coupling_map`). This can be used to construct a layout embedding [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") from a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object instead of from a [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap").

*   The following layout and routing transpiler passes from the [`qiskit.transpiler.passes`](/api/qiskit/0.45/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") modules have a new keyword argument, `target` which takes in a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object which is used to model the constraints of a target backend. If the `target` keyword argument is specified it will be used as the source of truth for any hardware constraints used in the operation of the transpiler pass. It will supersede any other arguments for specifying hardware constraints, typically those arguments which take a [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap"), [`InstructionScheduleMap`](/api/qiskit/0.45/qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap") or a basis gate list. The list of these passes with the new `target` argument are:

    > *   [`Unroller`](/api/qiskit/0.45/qiskit.transpiler.passes.Unroller "qiskit.transpiler.passes.Unroller")
    > *   `PulseGate`
    > *   [`RZXCalibrationBuilder`](/api/qiskit/0.45/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder")
    > *   [`CommutativeCancellation`](/api/qiskit/0.45/qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation")
    > *   [`EchoRZXWeylDecomposition`](/api/qiskit/0.45/qiskit.transpiler.passes.EchoRZXWeylDecomposition "qiskit.transpiler.passes.EchoRZXWeylDecomposition")
    > *   [`Optimize1qGatesSimpleCommutation`](/api/qiskit/0.45/qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation "qiskit.transpiler.passes.Optimize1qGatesSimpleCommutation")
    > *   [`Optimize1qGates`](/api/qiskit/0.45/qiskit.transpiler.passes.Optimize1qGates "qiskit.transpiler.passes.Optimize1qGates")
    > *   `CheckCXDirection`
    > *   [`ALAPSchedule`](/api/qiskit/0.45/qiskit.transpiler.passes.ALAPSchedule "qiskit.transpiler.passes.ALAPSchedule")
    > *   [`ASAPSchedule`](/api/qiskit/0.45/qiskit.transpiler.passes.ASAPSchedule "qiskit.transpiler.passes.ASAPSchedule")
    > *   [`ALAPScheduleAnalysis`](/api/qiskit/0.45/qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis")
    > *   [`ASAPScheduleAnalysis`](/api/qiskit/0.45/qiskit.transpiler.passes.ASAPScheduleAnalysis "qiskit.transpiler.passes.ASAPScheduleAnalysis")
    > *   [`DynamicalDecoupling`](/api/qiskit/0.45/qiskit.transpiler.passes.DynamicalDecoupling "qiskit.transpiler.passes.DynamicalDecoupling")
    > *   [`PadDynamicalDecoupling`](/api/qiskit/0.45/qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling")
    > *   [`TimeUnitConversion`](/api/qiskit/0.45/qiskit.transpiler.passes.TimeUnitConversion "qiskit.transpiler.passes.TimeUnitConversion")

*   The pass manager construction helper function [`generate_scheduling()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.common.generate_scheduling "qiskit.transpiler.preset_passmanagers.common.generate_scheduling") has a new keyword argument `target` which is used to specify a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object to model the constraints of the target backend being compiled for when generating a new [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager"). If specified this new argument will supersede the other argument `inst_map`.

*   The `default` plugin used by the [`UnitarySynthesis`](/api/qiskit/0.45/qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass now chooses one and two-qubit unitary synthesis based on the error rates reported in the [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target"). In particular, it runs all possible synthesis methods supported by the plugin and chooses the option which will result in the lowest error. For a one-qubit decomposition, it can target Pauli basis (e.g. RZ-RX-RZ or RZ-RY-RZ), generic unitary basis (e.g. U), and a few others. For a two-qubit decomposition, it can target any supercontrolled basis (e.g. CNOT, iSWAP, B) or multiple controlled basis (e.g. CZ, CH, ZZ^.5, ZX^.2, etc.).

*   The interface for [`UnitarySynthesisPlugin`](/api/qiskit/0.45/qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin") has two new optional properties `supports_gate_lengths_by_qubit` and `supports_gate_errors_by_qubit` which when set will add the fields `gate_lengths_by_qubit` and `gate_errors_by_qubit` respectively to the input options to the plugin’s `run()` method. These new fields are an alternative view of the data provided by `gate_lengths` and `gate_errors` but instead have the form: `{(qubits,): [Gate, length]}` (where `Gate` is the instance of [`Gate`](/api/qiskit/0.45/qiskit.circuit.Gate "qiskit.circuit.Gate") for that definition). This allows plugins to reason about working with gates of the same type but but that have different parameters set.

*   Added a new transpiler pass, [`UnrollForLoops`](/api/qiskit/0.45/qiskit.transpiler.passes.UnrollForLoops "qiskit.transpiler.passes.UnrollForLoops"), which is used to unroll any [`ForLoopOp`](/api/qiskit/0.45/qiskit.circuit.ForLoopOp "qiskit.circuit.ForLoopOp") operations in a circuit. This pass unrolls for-loops when possible, if there are no [`ContinueLoopOp`](/api/qiskit/0.45/qiskit.circuit.ContinueLoopOp "qiskit.circuit.ContinueLoopOp") or [`BreakLoopOp`](/api/qiskit/0.45/qiskit.circuit.BreakLoopOp "qiskit.circuit.BreakLoopOp") inside the body block of the loop. For example:

    ```python
    from qiskit.transpiler.passes import UnrollForLoops
    from qiskit import QuantumCircuit

    unroll_pass = UnrollForLoops()

    qc = QuantumCircuit(1)
    # For loop over range 5
    with qc.for_loop(range(5)) as i:
        qc.rx(i, 0)
    # Unroll loop into 5 rx gates
    unroll_pass(qc).draw("mpl")
    ```

    ![\_images/legacy\_release\_notes-1.png](/images/api/qiskit/legacy_release_notes-1.png)

*   Added a new parameter `max_trials` to pass [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") which, when specified, limits the number of layouts discovered and compared when searching for the best layout. This differs from existing parameters `call_limit` and `time_limit` (which are used to limit the number of state visits performed by the VF2 algorithm and the total time spent by pass [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout"), respectively) in that it is used to place an upper bound on the time spent scoring potential layouts, which may be useful for larger devices.

*   The [`CheckMap`](/api/qiskit/0.45/qiskit.transpiler.passes.CheckMap "qiskit.transpiler.passes.CheckMap") transpiler pass has a new keyword argument on its constructor, `property_set_field`. This argument can be used to specify a field in the property set to store the results of the analysis. Previously, it was only possible to store the result in the field `"is_swap_mapped"` (which is the default). This enables you to store the result of multiple instances of the pass in a [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") in different fields.

<span id="release-notes-0-24-0-circuits-features" />

<span id="id26" />

##### Circuits Features

*   Added a new gate class, [`GlobalPhaseGate`](/api/qiskit/0.45/qiskit.circuit.library.GlobalPhaseGate "qiskit.circuit.library.GlobalPhaseGate"), which can be used to add a global phase on the [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance.

*   Added a new attribute, [`layout`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#layout "qiskit.circuit.QuantumCircuit.layout"), to the [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class. This attribute is typically populated by [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`PassManager.run()`](/api/qiskit/0.45/qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") (when the [Layout Stage](/api/qiskit/0.45/transpiler#layout-stage) and [Routing Stage](/api/qiskit/0.45/transpiler#routing-stage) are run in the [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager")) and contains a [`TranspileLayout`](/api/qiskit/0.45/qiskit.transpiler.TranspileLayout "qiskit.transpiler.TranspileLayout") which contains the information about the permutation of the input circuit during [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   Added a new argument, `var_order`, to the [`PhaseOracle`](/api/qiskit/0.45/qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") class’s constructor to enable setting the order in which the variables in the logical expression are being considered. For example:

    ```python
    from qiskit.tools.visualization import plot_histogram
    from qiskit.primitives import Sampler
    from qiskit.circuit.library import PhaseOracle
    from qiskit.algorithms import Grover, AmplificationProblem

    oracle = PhaseOracle('((A & C) | (B & D)) & ~(C & D)', var_order=['A', 'B', 'C', 'D'])
    problem = AmplificationProblem(oracle=oracle, is_good_state=oracle.evaluate_bitstring)
    grover = Grover(sampler=Sampler())
    result = grover.amplify(problem)
    print(result.circuit_results[0])
    ```

*   A new OpenQASM 2 parser is available in [`qiskit.qasm2`](/api/qiskit/0.45/qasm2#module-qiskit.qasm2 "qiskit.qasm2"). This has two entry points: [`qasm2.load()`](/api/qiskit/0.45/qasm2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](/api/qiskit/0.45/qasm2#qiskit.qasm2.loads "qiskit.qasm2.loads"), for reading the source code from a file and from a string, respectively:

    ```python
    import qiskit.qasm2
    program = """
      OPENQASM 2.0;
      include "qelib1.inc";
      qreg q[2];
      h q[0];
      cx q[0], q[1];
    """
    bell = qiskit.qasm2.loads(program)
    ```

    This new parser is approximately 10x faster than the existing ones at [`QuantumCircuit.from_qasm_file()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#from_qasm_file "qiskit.circuit.QuantumCircuit.from_qasm_file") and [`QuantumCircuit.from_qasm_str()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str") for large files, and has less overhead on each call as well. The new parser is more extensible, customisable and generally also more type-safe; it will not attempt to output custom Qiskit objects when the definition in the OpenQASM 2 file clashes with the Qiskit object, unlike the current exporter. See the [`qiskit.qasm2`](/api/qiskit/0.45/qasm2#module-qiskit.qasm2 "qiskit.qasm2") module documentation for full details and more examples.

*   Improve the decomposition of multi-controlled Pauli-X and Pauli-Y rotations with [`QuantumCircuit.mcrx()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#mcrx "qiskit.circuit.QuantumCircuit.mcrx") and ``QuantumCircuit.mcry on :math:`n()`` controls to $16n - 40$ CX gates, for $n \geq 4$. This improvement is based on [arXiv:2302.06377](https://arxiv.org/abs/2302.06377).

*   Qiskit now supports the representation of `switch` statements, using the new [`SwitchCaseOp`](/api/qiskit/0.45/qiskit.circuit.SwitchCaseOp "qiskit.circuit.SwitchCaseOp") instruction and the [`QuantumCircuit.switch()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#switch "qiskit.circuit.QuantumCircuit.switch") method. This allows switching on a numeric input (such as a classical register or bit) and executing the circuit that corresponds to the matching value. Multiple values can point to the same circuit, and [`CASE_DEFAULT`](/api/qiskit/0.45/circuit#control-flow-operations "qiskit.circuit.CASE_DEFAULT") can be used as an always-matching label.

    You can also use a builder interface, similar to the other control-flow constructs to build up these switch statements:

    ```python
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

    qreg = QuantumRegister(2)
    creg = ClassicalRegister(2)
    qc = QuantumCircuit(qreg, creg)

    qc.h([0, 1])
    qc.measure([0, 1], [0, 1])
    with qc.switch(creg) as case:
      with case(0):  # if the register is '00'
        qc.z(0)
      with case(1, 2):  # if the register is '01' or '10'
        qc.cx(0, 1)
      with case(case.DEFAULT):  # the default case
        qc.h(0)
    ```

    The `switch` statement has support throughout the Qiskit compiler stack; you can [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") circuits containing it (if the backend advertises its support for the construct), and it will serialize to QPY.

    The `switch` statement is not currently a feature of OpenQASM 3, but [it is under active design and consideration](https://github.com/openqasm/openqasm/pull/463), which is expected to be adopted in the near future. Qiskit Terra has experimental support for exporting this statement to the OpenQASM 3 syntax proposed in the linked pull request, using an experimental feature flag. To export a `switch` statement circuit (such as the one created above) to OpenQASM 3 using this speculative support, do:

    ```python
    from qiskit import qasm3

    qasm3.dumps(qc, experimental=qasm3.ExperimentalFeatures.SWITCH_CASE_V1)
    ```

<span id="release-notes-0-24-0-algorithms-features" />

<span id="id27" />

##### Algorithms Features

*   Added a new attribute [`eigenvalue_threshold`](/api/qiskit/0.45/qiskit.algorithms.minimum_eigensolvers.AdaptVQE#eigenvalue_threshold "qiskit.algorithms.minimum_eigensolvers.AdaptVQE.eigenvalue_threshold") to the [`AdaptVQE`](/api/qiskit/0.45/qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") class for configuring a new kind of threshold to terminate the algorithm once the eigenvalue changes less than a set value.

*   Added a new attribute [`gradient_threshold`](/api/qiskit/0.45/qiskit.algorithms.minimum_eigensolvers.AdaptVQE#gradient_threshold "qiskit.algorithms.minimum_eigensolvers.AdaptVQE.gradient_threshold") to the [`AdaptVQE`](/api/qiskit/0.45/qiskit.algorithms.minimum_eigensolvers.AdaptVQE "qiskit.algorithms.minimum_eigensolvers.AdaptVQE") class which will replace the [`threshold`](/api/qiskit/0.45/qiskit.algorithms.minimum_eigensolvers.AdaptVQE#threshold "qiskit.algorithms.minimum_eigensolvers.AdaptVQE.threshold") in the future. This new attribute behaves the same as the existing `threshold` attribute but has a more accurate name, given the introduction of additional threshold options in the class.

*   Added the [`EstimationProblem.has_good_state`](/api/qiskit/0.45/qiskit.algorithms.EstimationProblem#has_good_state "qiskit.algorithms.EstimationProblem.has_good_state") attribute, which allows to check whether an [`EstimationProblem`](/api/qiskit/0.45/qiskit.algorithms.EstimationProblem "qiskit.algorithms.EstimationProblem") has a custom [`EstimationProblem.is_good_state`](/api/qiskit/0.45/qiskit.algorithms.EstimationProblem#is_good_state "qiskit.algorithms.EstimationProblem.is_good_state") or if it is the default. This is useful for checks in amplitude estimators, such as [`AmplitudeEstimation`](/api/qiskit/0.45/qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation"), which only support the default implementation.

*   Adds a flag `local` to the [`ComputeUncompute`](/api/qiskit/0.45/qiskit.algorithms.state_fidelities.ComputeUncompute "qiskit.algorithms.state_fidelities.ComputeUncompute") state fidelity class that allows to compute the local fidelity, which is defined by averaging over single-qubit projectors.

*   Gradient classes rearrange the gradient result according to the order of the input parameters now.

    Example:

    ```python
    from qiskit.algorithms.gradients import ParamShiftEstimatorGradient
    from qiskit.circuit import QuantumCircuit, Parameter
    from qiskit.primitives import Estimator
    from qiskit.quantum_info import SparsePauliOp

    # Create a circuit with a parameter
    p = {i: Parameter(f'p{i}') for i in range(3)}
    qc = QuantumCircuit(1)
    qc.rx(p[0], 0)
    qc.ry(p[1], 0)
    qc.rz(p[2], 0)
    op = SparsePauliOp.from_list([("Z", 1)])
    param_values = [0.1, 0.2, 0.3]

    # Create a gradient object
    estimator = Estimator()
    grad = ParamShiftEstimatorGradient(estimator)
    result = grad.run(qc, op, [param_values]).result()
    # would produce a gradient of the form [df/dp0, df/dp1, df/dp2]
    result = grad.run(qc, op, [param_values], parameters=[[p[2], p[0]]]).result()
    # would produce a gradient of the form [df/dp2, df/dp0]
    ```

*   Added support for handling time-dependent Hamiltonians (i.e. singly parametrized operators) to the [`TrotterQRTE`](/api/qiskit/0.45/qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") class. To facilitate working with this, added the [`num_timesteps`](/api/qiskit/0.45/qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE#num_timesteps "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE.num_timesteps") attribute and a matching keyword argument to the [`TrotterQRTE`](/api/qiskit/0.45/qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") constructor to control the number of time steps to divide the full evolution.

*   Added support for observable evaluations at every time-step during the execution of the [`TrotterQRTE`](/api/qiskit/0.45/qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE") class. The [`TimeEvolutionProblem.aux_operators`](/api/qiskit/0.45/qiskit.algorithms.TimeEvolutionProblem#aux_operators "qiskit.algorithms.TimeEvolutionProblem.aux_operators") is evaluated at every time step if the `ProductFormula.reps` attribute of the input `product_formula` argument in the constructor is set to 1.

*   Added extensions to the [`VQD`](/api/qiskit/0.45/qiskit.algorithms.eigensolvers.VQD "qiskit.algorithms.eigensolvers.VQD") algorithm, which allow to pass a list of optimizers and initial points for the different minimization runs. For example, the `k`-th initial point and `k`-th optimizer will be used for the optimization of the `k-1`-th exicted state.

<span id="release-notes-0-24-0-quantum-information-features" />

<span id="id28" />

##### Quantum Information Features

*   Added two new constructor methods, [`Clifford.from_matrix()`](/api/qiskit/0.45/qiskit.quantum_info.Clifford#from_matrix "qiskit.quantum_info.Clifford.from_matrix") and [`Clifford.from_operator()`](/api/qiskit/0.45/qiskit.quantum_info.Clifford#from_operator "qiskit.quantum_info.Clifford.from_operator"), that create a [`Clifford`](/api/qiskit/0.45/qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") object from its unitary matrix and operator representation respectively.

*   The constructor of [`Clifford`](/api/qiskit/0.45/qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") now can take any Clifford gate object up to 3 qubits as long it implements a `to_matrix` method, including parameterized gates such as `Rz(pi/2)`, which were not convertible before.

*   Added new utility functions: [`commutator()`](/api/qiskit/0.45/quantum_info#qiskit.quantum_info.commutator "qiskit.quantum_info.commutator"), [`anti_commutator()`](/api/qiskit/0.45/quantum_info#qiskit.quantum_info.anti_commutator "qiskit.quantum_info.anti_commutator"), and [`double_commutator()`](/api/qiskit/0.45/quantum_info#qiskit.quantum_info.double_commutator "qiskit.quantum_info.double_commutator") which are used to compute commutators for any object implementing the `LinearOp` abstract base class such as `QuantumChannel`, [`SparsePauliOp`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"), or [`ScalarOp`](/api/qiskit/0.45/qiskit.quantum_info.ScalarOp "qiskit.quantum_info.ScalarOp").

*   Added the method `StabilizerState.equiv`, that checks if the generating sets of two stabilizer states generate the same stabilizer group. For example, the stabilizer group of the two-qubit Bell state contains the four elements $\{II, XX, -YY, ZZ\}$ and hence can be generated by either $[XX, ZZ]$, $[XX, -YY]$ or $[-YY, ZZ]$.

*   Added a new method, [`partial_transpose()`](/api/qiskit/0.45/qiskit.quantum_info.DensityMatrix#partial_transpose "qiskit.quantum_info.DensityMatrix.partial_transpose"), to the [`qiskit.quantum_info`](/api/qiskit/0.45/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module’s [`DensityMatrix`](/api/qiskit/0.45/qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix") class. This method is used to compute the partial transposition of a density matrix, which is necessary for detecting entanglement between bipartite quantum systems.

*   Added a method [`qiskit.quantum_info.Operator.apply_permutation()`](/api/qiskit/0.45/qiskit.quantum_info.Operator#apply_permutation "qiskit.quantum_info.Operator.apply_permutation") that pre-composes or post-composes an Operator with a Permutation. This method works for general qudits.

    Here is an example to calculate $P^\dagger.O.P$ which reorders Operator’s bits:

    ```python
    import numpy as np
    from qiskit.quantum_info.operators import Operator

    op = Operator(np.array(range(576)).reshape((24, 24)), input_dims=(2, 3, 4), output_dims=(2, 3, 4))
    perm = [1, 2, 0]
    inv_perm = [2, 0, 1]
    conjugate_op = op.apply_permutation(inv_perm, front=True).apply_permutation(perm, front=False)
    ```

    The conjugate operator has dimensions (4, 2, 3) x (4, 2, 3), which is consistent with permutation moving qutrit to position 0, qubit to position 1, and the 4-qudit to position 2.

*   Natively support the construction of [`SparsePauliOp`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") objects with [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") coefficients, without requiring the explicit construction of an object-array. Now the following is supported:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    x = Parameter("x")
    op = SparsePauliOp(["Z", "X"], coeffs=[1, x])
    ```

*   Added the [`SparsePauliOp.assign_parameters()`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp#assign_parameters "qiskit.quantum_info.SparsePauliOp.assign_parameters") method and [`SparsePauliOp.parameters`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp#parameters "qiskit.quantum_info.SparsePauliOp.parameters") attribute to assign and query unbound parameters inside a [`SparsePauliOp`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"). This function can for example be used as:

    ```python
    from qiskit.circuit import Parameter
    from qiskit.quantum_info import SparsePauliOp

    x = Parameter("x")
    op = SparsePauliOp(["Z", "X"], coeffs=[1, x])

    # free_params will be: ParameterView([x])
    free_params = op.parameters

    # assign the value 2 to the parameter x
    bound = op.assign_parameters([2])
    ```

<span id="release-notes-0-24-0-pulse-features" />

<span id="id29" />

##### Pulse Features

*   Added new [`SymbolicPulse`](/api/qiskit/0.45/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") classes to the pulse library ([`qiskit.pulse.library`](/api/qiskit/0.45/pulse#module-qiskit.pulse.library "qiskit.pulse.library")) The new pulses in the library are:

    > *   [`Sin`](/api/qiskit/0.45/qiskit.pulse.library.Sin_class.rst#qiskit.pulse.library.Sin "qiskit.pulse.library.Sin")
    > *   [`Cos`](/api/qiskit/0.45/qiskit.pulse.library.Cos_class.rst#qiskit.pulse.library.Cos "qiskit.pulse.library.Cos")
    > *   [`Sawtooth`](/api/qiskit/0.45/qiskit.pulse.library.Sawtooth_class.rst#qiskit.pulse.library.Sawtooth "qiskit.pulse.library.Sawtooth")
    > *   [`Triangle`](/api/qiskit/0.45/qiskit.pulse.library.Triangle_class.rst#qiskit.pulse.library.Triangle "qiskit.pulse.library.Triangle")

    These new classes are instances of `ScalableSymbolicPulse`. With the exception of the `Sawtooth` phase, behavior is identical to that of the corresponding waveform generator function (e.g. [`sin()`](/api/qiskit/0.45/pulse#qiskit.pulse.library.sin "qiskit.pulse.library.sin")). The phase for the `Sawtooth` class is defined such that a phase of $2\pi$ shifts by a full cycle.

*   Added support to QPY ([`qiskit.qpy`](/api/qiskit/0.45/qpy#module-qiskit.qpy "qiskit.qpy")) for working with pulse [`ScheduleBlock`](/api/qiskit/0.45/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") instances with unassigned references, and preserving the data structure for the reference to subroutines. This feature allows users to serialize and deserialize a template pulse program for tasks such as pulse calibration. For example:

    ```python
    from qiskit import pulse
    from qiskit import qpy

    with pulse.build() as schedule:
        pulse.reference("cr45p", "q0", "q1")
        pulse.reference("x", "q0")
        pulse.reference("cr45p", "q0", "q1")

    with open('template_ecr.qpy', 'wb') as fd:
        qpy.dump(schedule, fd)
    ```

*   A new method `CalibrationEntry.user_provided()` has been added to calibration entries. This method can be called to check whether the entry is defined by an end user or backend.

*   Added a new method [`Target.get_calibration()`](/api/qiskit/0.45/qiskit.transpiler.Target#get_calibration "qiskit.transpiler.Target.get_calibration") which provides convenient access to the calibration of an instruction in a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object This method can be called with parameter args and kwargs, and it returns a pulse schedule built with parameters when the calibration is templated with parameters.

<span id="release-notes-0-24-0-providers-features" />

##### Providers Features

*   The [`BackendV2Converter`](/api/qiskit/0.45/qiskit.providers.BackendV2Converter "qiskit.providers.BackendV2Converter") class has a new keyword argument, `filter_faulty`, on its constructor. When this argument is set to `True` the converter class will filter out any qubits or operations listed as non-operational in the [`BackendProperties`](/api/qiskit/0.45/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") payload for the input [`BackendV1`](/api/qiskit/0.45/qiskit.providers.BackendV1 "qiskit.providers.BackendV1"). While not extensively used a [`BackendProperties`](/api/qiskit/0.45/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") object supports annotating both qubits and gates as being non-operational. Previously, if a backend had set that flag on any qubits or gates the output `BackendV2` instance and its [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") would include all operations whether they were listed as operational or not. By leveraging the new flag you can filter out these non-operational qubits and gates from the [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target"). When the flag is set the output backend will still be listed as the full width (e.g. a 24 qubit backend with 4 qubits listed as not operational will still show it has 24 qubits) but the faulty qubits will not have any operations listed as being supported in the [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target").

*   The [`Options`](/api/qiskit/0.45/qiskit.providers.Options "qiskit.providers.options.Options") class now implements the the `Mapping` protocol and `__setitem__` method. This means that [`Options`](/api/qiskit/0.45/qiskit.providers.Options "qiskit.providers.Options") instances now offer the same interface as standard dictionaries, except for the deletion methods (\_\_delitem\_\_, pop, clear). Key assignments are validated by the validators, if any are registered.

<span id="release-notes-0-24-0-visualization-features" />

<span id="id30" />

##### Visualization Features

*   Added a new function, `staged_pass_manager_drawer()`, which is used for visualizing a [`StagedPassManager`](/api/qiskit/0.45/qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager") instance. It draws the full pass manager with each stage represented as an outer box.

    For example:

    ```python
    from qiskit.visualization import staged_pass_manager_drawer
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit.providers.fake_provider import FakeSherbrooke

    backend = FakeSherbrooke()
    pm = generate_preset_pass_manager(3, backend)
    staged_pass_manager_drawer(pm)
    ```

*   The [`StagedPassManager.draw()`](/api/qiskit/0.45/qiskit.transpiler.StagedPassManager#draw "qiskit.transpiler.StagedPassManager.draw") method has been updated to include visualization of the stages in addition to the overall pass manager. The stages are represented by outer boxes in the visualization. In previous releases the stages were not included in the visualization. For example:

    ```python
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit.providers.fake_provider import FakeSherbrooke

    backend = FakeSherbrooke()
    pm = generate_preset_pass_manager(3, backend)
    pm.draw(pm)
    ```

*   Added a new keyword argument, `figsize`, to the [`plot_bloch_multivector()`](/api/qiskit/0.45/qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") function. This argument can be used to set a size for individual Bloch sphere sub-plots. For example, if there are $n$ qubits and `figsize` is set to `(w, h)`, then the overall figure width is set to $n \cdot w$, while the overall height is set to $h$.

*   Added a new keyword argument, `font_size`, to the [`plot_bloch_multivector()`](/api/qiskit/0.45/qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") function. This argument can be used to control the font size in the output visualization.

*   Added two new keyword arguments, `title_font_size` and `title_pad`, to the [`plot_bloch_multivector()`](/api/qiskit/0.45/qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") function. These arguments can be used to control the font size of the overall title and its padding respectively.

<span id="release-notes-0-24-0-upgrade-notes" />

<span id="id31" />

#### Upgrade Notes

*   The minimum supported Rust version (MSRV) has been increased from 1.56.1 to 1.61.0. If you’re are building Qiskit from source you will now need to ensure that you have at least Rust 1.61.0 installed to be able to build Qiskit. This change was made because several upstream dependencies have increased their MSRVs.

*   Removed the usage of primitives with the context manager and the initialization with circuits, (observables only for Estimator), and parameters which was deprecated in the Qiskit Terra 0.22.0 release in October 2022.

*   `PrimitiveJob.submit()` no longer blocks on execution finishing. As a result, [`Sampler.run()`](/api/qiskit/0.45/qiskit.primitives.Sampler#run "qiskit.primitives.Sampler.run"), [`BackendSampler.run()`](/api/qiskit/0.45/qiskit.primitives.BackendSampler#run "qiskit.primitives.BackendSampler.run"), [`Estimator.run()`](/api/qiskit/0.45/qiskit.primitives.Estimator#run "qiskit.primitives.Estimator.run") and [`BaseEstimator.run()`](/api/qiskit/0.45/qiskit.primitives.BaseEstimator#run "qiskit.primitives.BaseEstimator.run") do not block until `PrimitiveJob.result()` method is called.

<span id="release-notes-0-24-0-transpiler-upgrade-notes" />

<span id="id32" />

##### Transpiler Upgrade Notes

*   The maximum number of trials evaluated when searching for the best layout using [`VF2Layout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is now limited in [`level_1_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") to `2 500`, `25 000`, and `250 000`, respectively. Previously, all found possible layouts were evaluated. This change was made to prevent transpilation from hanging during layout scoring for circuits with many connected components on larger devices, which scales combinatorially since each connected component would be evaluated in all possible positions on the device. To perform a full search as before, manually run [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") over the transpiled circuit in strict mode, specifying `0` for `max_trials`.

*   The previously deprecated `condition` attribute of the [`DAGDepNode`](/api/qiskit/0.45/qiskit.dagcircuit.DAGDepNode "qiskit.dagcircuit.DAGDepNode") class has been removed. It was marked as deprecated in the 0.18 release (07-2021). Instead you should use the [`condition`](/api/qiskit/0.45/qiskit.circuit.Instruction#condition "qiskit.circuit.Instruction.condition") attribute of the `op` attribute to access the condition of an operation node. For other node types there is no condition to access.

*   The default value of `metadata` in both [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and [`DAGDependency`](/api/qiskit/0.45/qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") has been changed from `None` to `{}` for compatibility with the matching `metadata` attribute of [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   The ``CouplingMap.__eq__`()`` method has been updated to check that the edge lists of the underlying graphs contain the same elements. Under the assumption that the underlying graphs are connected, this check additionally ensures that the graphs have the same number of nodes with the same labels. Any code using `CouplingMap() == CouplingMap()` to check object equality should be updated to `CouplingMap() is CouplingMap()`.

*   When running the [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function with a [`BackendV1`](/api/qiskit/0.45/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") based backend or a [`BackendProperties`](/api/qiskit/0.45/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") via the `backend_properties` keyword argument that has any qubits or gates flagged as faulty the function will no longer try to automatically remap the qubits based on this information. The method by which [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") attempted to do this remapping was fundamentally flawed and in most cases of such a backend it would result an internal error being raised. In practice very few backends ever set the fields in [`BackendProperties`](/api/qiskit/0.45/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") to flag a qubit or gate as faulty. If you were relying on [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") to do this re-mapping for you, you will now need to manually do that and pass a mapped input to the `coupling_map` and `backend_properties` arguments which has filtered out the faulty qubits and gates and then manually re-map the output.

*   The result of transpilations for fixed seeds may have changed compared to previous versions of Qiskit Terra. This is because of internal tweaks to the routing algorithm used by [`SabreSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") and [`SabreLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout"), which are the default routing and layout passes respectively, to make them significantly faster for large circuits.

<span id="release-notes-0-24-0-circuits-upgrade-notes" />

<span id="id33" />

##### Circuits Upgrade Notes

*   The [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") [`metadata`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute now always returns a dictionary, and can only be set to a dictionary. Previously, its default value was `None`, and could be manually set to `None` or a dictionary.

<span id="release-notes-0-24-0-algorithms-upgrade-notes" />

##### Algorithms Upgrade Notes

*   The deprecated modules `factorizers` and `linear_solvers`, containing `HHL` and `Shor` have been removed from [`qiskit.algorithms`](/api/qiskit/0.45/algorithms#module-qiskit.algorithms "qiskit.algorithms"). These functionalities were originally deprecated as part of the 0.22.0 release (released on October 13, 2022). You can access the code through the Qiskit Textbook instead: [Linear Solvers (HHL)](https://github.com/Qiskit/textbook/blob/main/notebooks/ch-applications/hhl_tutorial.ipynb), [Factorizers (Shor)](https://github.com/Qiskit/textbook/blob/main/notebooks/ch-algorithms/shor.ipynb)

<span id="release-notes-0-24-0-pulse-upgrade-notes" />

##### Pulse Upgrade Notes

*   [`Target.update_from_instruction_schedule_map()`](/api/qiskit/0.45/qiskit.transpiler.Target#update_from_instruction_schedule_map "qiskit.transpiler.Target.update_from_instruction_schedule_map") no longer raises `KeyError` nor `ValueError` when qubits are missing in the target instruction or `inst_name_map` is not provided for the undefined instruction. In the former case, it just ignores the input [`InstructionScheduleMap`](/api/qiskit/0.45/qiskit.pulse.InstructionScheduleMap "qiskit.pulse.InstructionScheduleMap")'s definition for undefined qubits. In the latter case, a gate mapping is pulled from the standard Qiskit gates and finally, a custom opaque [`Gate`](/api/qiskit/0.45/qiskit.circuit.Gate "qiskit.circuit.Gate") object is defined from the schedule name if no mapping is found.

<span id="release-notes-0-24-0-providers-upgrade-notes" />

##### Providers Upgrade Notes

*   The deprecated `max_credits` argument to [`execute()`](/api/qiskit/0.45/execute#qiskit.execute_function.execute "qiskit.execute_function.execute"), [`assemble()`](/api/qiskit/0.45/compiler#qiskit.compiler.assemble "qiskit.compiler.assemble") and all of the `Qobj` configurations (e.g. [`QasmQobjConfig`](/api/qiskit/0.45/qiskit.qobj.QasmQobjConfig "qiskit.qobj.QasmQobjConfig") and [`PulseQobjConfig`](/api/qiskit/0.45/qiskit.qobj.PulseQobjConfig "qiskit.qobj.PulseQobjConfig")) has been removed. This argument dates back to early versions of Qiskit which was tied more closely to the IBM Quantum service offering. At that time the `max_credits` field was part of the “credit system” used by IBM Quantum’s service offering. However, that credit system has not been in use on IBM Quantum backends for nearly three years and also Qiskit is not tied to IBM Quantum’s service offerings anymore (and hasn’t been for a long time). If you were relying on this option in some way for a backend you will need to ensure that your [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") implementation exposes a `max_credits` field in its [`Options`](/api/qiskit/0.45/qiskit.providers.Options "qiskit.providers.Options") object.

*   The [`name`](/api/qiskit/0.45/qiskit.providers.BackendV2#name "qiskit.providers.BackendV2.name") attribute on the [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based fake backend classes in [`qiskit.providers.fake_provider`](/api/qiskit/0.45/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") have changed from earlier releases. Previously, the names had a suffix `"_v2"` to differentiate the class from the [`BackendV1`](/api/qiskit/0.45/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") version. This suffix has been removed as having the suffix could lead to inconsistencies with other snapshotted data used to construct the backend object.

<span id="release-notes-0-24-0-deprecation-notes" />

<span id="id34" />

#### Deprecation Notes

*   The modules [`qiskit.opflow`](/api/qiskit/0.45/opflow#module-qiskit.opflow "qiskit.opflow"), `qiskit.utils.backend_utils`, [`qiskit.utils.mitigation`](/api/qiskit/0.45/utils_mitigation#module-qiskit.utils.mitigation "qiskit.utils.mitigation"), `qiskit.utils.measurement_error_mitigation`, class [`qiskit.utils.QuantumInstance`](/api/qiskit/0.45/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") and methods `find_regs_by_name()`, `run_circuits()` have been deprecated and will be removed in a future release. Using [`QuantumInstance`](/api/qiskit/0.45/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") is superseded by [`BaseSampler`](/api/qiskit/0.45/qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler"). See [Opflow Migration](https://qisk.it/opflow_migration). See [QuantumInstance Migration](https://qisk.it/qi_migration).

<span id="release-notes-0-24-0-transpiler-deprecations" />

<span id="id35" />

##### Transpiler Deprecations

*   The transpiler routing pass, `BIPMapping` has been deprecated and will be removed in a future release. It has been replaced by an external plugin package: `qiskit-bip-mapper`. Details for this new package can be found at the package’s github repository:

    [https://github.com/qiskit-community/qiskit-bip-mapper](https://github.com/qiskit-community/qiskit-bip-mapper)

    The pass was made into a separate plugin package for two reasons, first the dependency on CPLEX makes it harder to use and secondly the plugin packge more cleanly integrates with [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   Misspelled `aquire_alignment` in the class [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") has been replaced by correct spelling `acquire_alignment`. The old constructor argument aquire\_alignment and [`Target.aquire_alignment`](/api/qiskit/0.45/qiskit.transpiler.Target#aquire_alignment "qiskit.transpiler.Target.aquire_alignment") are deprecated and will be removed in a future release. Use [`Target.acquire_alignment`](/api/qiskit/0.45/qiskit.transpiler.Target#acquire_alignment "qiskit.transpiler.Target.acquire_alignment") instead to get and set the alignment constraint value.

<span id="release-notes-0-24-0-circuits-deprecations" />

<span id="id36" />

##### Circuits Deprecations

*   Setting the [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") [`metadata`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") attribute to `None` has been deprecated and will no longer be supported in a future release. Instead, users should set it to an empty dictionary if they want it to contain no data.

<span id="release-notes-0-24-0-algorithms-deprecations" />

<span id="id37" />

##### Algorithms Deprecations

*   All of the following features are now deprecated, after having been made pending deprecation since 0.22.0. More information is available at [https://qisk.it/algo\_migration](https://qisk.it/algo_migration).

    *   Module `qiskit.algorithms.minimum_eigen_solvers` is deprecated and superseded by [`qiskit.algorithms.minimum_eigensolvers`](/api/qiskit/0.45/qiskit.algorithms.minimum_eigensolvers#module-qiskit.algorithms.minimum_eigensolvers "qiskit.algorithms.minimum_eigensolvers").

    *   Module `qiskit.algorithms.eigen_solvers` is deprecated and superseded by [`qiskit.algorithms.eigensolvers`](/api/qiskit/0.45/qiskit.algorithms.eigensolvers#module-qiskit.algorithms.eigensolvers "qiskit.algorithms.eigensolvers").

    *   Module `qiskit.algorithms.evolvers` is deprecated and superseded by `qiskit.algorithms.time_evolvers`.

    *   Class [`qiskit.algorithms.TrotterQRTE`](/api/qiskit/0.45/qiskit.algorithms.TrotterQRTE "qiskit.algorithms.TrotterQRTE") is deprecated and superseded by [`qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE`](/api/qiskit/0.45/qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE "qiskit.algorithms.time_evolvers.trotterization.TrotterQRTE").

    *   Using [`QuantumInstance`](/api/qiskit/0.45/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") or [`Backend`](/api/qiskit/0.45/qiskit.providers.Backend "qiskit.providers.Backend") is deprecated and superseded by [`BaseSampler`](/api/qiskit/0.45/qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") in the following classes:

        > *   [`Grover`](/api/qiskit/0.45/qiskit.algorithms.Grover "qiskit.algorithms.Grover")
        > *   [`AmplitudeEstimation`](/api/qiskit/0.45/qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation")
        > *   [`FasterAmplitudeEstimation`](/api/qiskit/0.45/qiskit.algorithms.FasterAmplitudeEstimation "qiskit.algorithms.FasterAmplitudeEstimation")
        > *   [`IterativePhaseEstimation`](/api/qiskit/0.45/qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation")
        > *   [`MaximumLikelihoodAmplitudeEstimation`](/api/qiskit/0.45/qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation "qiskit.algorithms.MaximumLikelihoodAmplitudeEstimation")
        > *   [`HamiltonianPhaseEstimation`](/api/qiskit/0.45/qiskit.algorithms.HamiltonianPhaseEstimation "qiskit.algorithms.HamiltonianPhaseEstimation")
        > *   [`IterativePhaseEstimation`](/api/qiskit/0.45/qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation")
        > *   [`PhaseEstimation`](/api/qiskit/0.45/qiskit.algorithms.PhaseEstimation "qiskit.algorithms.PhaseEstimation")

    *   Using [`QuantumInstance`](/api/qiskit/0.45/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") or [`Backend`](/api/qiskit/0.45/qiskit.providers.Backend "qiskit.providers.Backend") or `ExpectationBase` is deprecated and superseded by [`BaseSampler`](/api/qiskit/0.45/qiskit.primitives.BaseSampler "qiskit.primitives.BaseSampler") in the following static method: [`get_fidelity()`](/api/qiskit/0.45/qiskit.algorithms.optimizers.QNSPSA#get_fidelity "qiskit.algorithms.optimizers.QNSPSA.get_fidelity")

    *   Function `eval_observables()` is deprecated and superseded by `estimate_observables()` function.

<span id="release-notes-0-24-0-quantum-information-deprecations" />

##### Quantum Information Deprecations

*   The `PauliTable` and `StabilizerTable` are deprecated and will be removed in a future release. Instead, the [`PauliList`](/api/qiskit/0.45/qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") should be used. With this change, `table()` has been deprecated so that you should operate directly from `tableau()` without it.

<span id="release-notes-0-24-0-pulse-deprecations" />

<span id="id38" />

##### Pulse Deprecations

*   Assignment of complex values to `ParameterExpression` in any Qiskit Pulse object now raises a `PendingDeprecationWarning`. This will align the Pulse module with other modules where such assignment wasn’t possible to begin with. The typical use case for complex parameters in the module was the SymbolicPulse library. As of Qiskit-Terra 0.23.0 all library pulses were converted from complex amplitude representation to real representation using two floats (amp,angle), as used in the `ScalableSymbolicPulse` class. This eliminated the need for complex parameters. Any use of complex parameters (and particularly custom-built pulses) should be converted in a similar fashion to avoid the use of complex parameters.

<span id="release-notes-0-24-0-bug-fixes" />

<span id="id39" />

#### Bug Fixes

*   The [`AmplitudeEstimation`](/api/qiskit/0.45/qiskit.algorithms.AmplitudeEstimation "qiskit.algorithms.AmplitudeEstimation") class now correctly warns if an [`EstimationProblem`](/api/qiskit/0.45/qiskit.algorithms.EstimationProblem "qiskit.algorithms.EstimationProblem") with a set `is_good_state` property is passed as input, as it is not supported and ignored. Previously, the algorithm would silently ignore this option leading to unexpected results.

*   [`QuantumCircuit.append()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#append "qiskit.circuit.QuantumCircuit.append") will now correctly raise an error if given an incorrect number of classical bits to apply to an operation. Fix [#9385](https://github.com/Qiskit/qiskit-terra/issues/9385).

*   The [`BarrierBeforeFinalMeasurements`](/api/qiskit/0.45/qiskit.transpiler.passes.BarrierBeforeFinalMeasurements "qiskit.transpiler.passes.BarrierBeforeFinalMeasurements") and [`MergeAdjacentBarriers`](/api/qiskit/0.45/qiskit.transpiler.passes.MergeAdjacentBarriers "qiskit.transpiler.passes.MergeAdjacentBarriers") transpiler passes previously had a non-deterministic order of their emitted [`Barrier`](/api/qiskit/0.45/qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier") instructions. This did not change the semantics of circuits but could, in limited cases where there were non-full-width barriers, cause later stochastic transpiler passes to see a different topological ordering of the circuit and consequently have different outputs for fixed seeds. The passes have been made deterministic to avoid this.

*   The return type of [`run()`](/api/qiskit/0.45/qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") will now always be the same as that of its first argument. Passing a single circuit returns a single circuit, passing a list of circuits, even of length 1, returns a list of circuits. See [#9798](https://github.com/Qiskit/qiskit-terra/issues/9798).

*   Fixed a bug where [`PauliOp.adjoint()`](/api/qiskit/0.45/qiskit.opflow.primitive_ops.PauliOp#adjoint "qiskit.opflow.primitive_ops.PauliOp.adjoint") did not return a correct value for Paulis with complex coefficients, like `PauliOp(Pauli("iX"))`. Fixed [#9433](https://github.com/Qiskit/qiskit-terra/issues/9433).

*   Fixed an issue with the circuit drawer function [`circuit_drawer()`](/api/qiskit/0.45/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`QuantumCircuit.draw()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when displaying instruction parameters that type [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which would result in an illegible drawing. Fixed [#9908](https://github.com/Qiskit/qiskit-terra/issues/9908)

*   Fixed an issue with the circuit drawer function [`circuit_drawer()`](/api/qiskit/0.45/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`QuantumCircuit.draw()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when using the `text` method and the argument `vertical_compression="low"` where it would use an incorrect character for the top-right corner of boxes used to represent gates in the circuit.

*   Fixed an issue with the [`Gate.control()`](/api/qiskit/0.45/qiskit.circuit.Gate#control "qiskit.circuit.Gate.control") method where it previously would incorrectly handle `str` or `None` input types for the `ctrl_state` argument.

*   Fixed an edge case in the construction of [`Pauli`](/api/qiskit/0.45/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") instances; a string with an optional phase and no qubits is now a valid label, making an operator with no qubits (such as `Pauli("-i")`). This was already possible when using the array forms, or empty slices. Fixed [#9720](https://github.com/Qiskit/qiskit-terra/issues/9720).

*   Fixed an issue when using the [`pulse`](/api/qiskit/0.45/pulse#module-qiskit.pulse "qiskit.pulse") macro `measure()` when working with a [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based backend. Previously, trying to use `qiskit.pulse.macros.measure()` with a [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") based backend would have resulted in an error. Fixed [#9488](https://github.com/Qiskit/qiskit-terra/issues/9488)

*   Fixed an issue with the [`marginal_distribution()`](/api/qiskit/0.45/result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") function where it would incorrectly raise an error when an input counts dictionary was using a numpy integer type instead of the Python int type. The underlying function always would handle the different types correctly, but the input type checking was previously incorrectly raising a `TypeError` in this case.

*   Fixed a bug where [`Parameter.is_real()`](/api/qiskit/0.45/qiskit.circuit.Parameter#is_real "qiskit.circuit.Parameter.is_real") did not return `None` when the parameter is not bound. Fixed [#8619](https://github.com/Qiskit/qiskit-terra/issues/8619).

*   Circuits containing [`C3SXGate`](/api/qiskit/0.45/qiskit.circuit.library.C3SXGate "qiskit.circuit.library.C3SXGate") can now be output and read in again safely from the OpenQASM 2.0 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) and parser ([`QuantumCircuit.from_qasm_str()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#from_qasm_str "qiskit.circuit.QuantumCircuit.from_qasm_str")).

*   Fixed a bug in QPY ([`qiskit.qpy`](/api/qiskit/0.45/qpy#module-qiskit.qpy "qiskit.qpy")) where circuits containing gates of class [`MCXGate`](/api/qiskit/0.45/qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate"), [`MCXGrayCode`](/api/qiskit/0.45/qiskit.circuit.library.MCXGrayCode "qiskit.circuit.library.MCXGrayCode"), and `MCXRecursive`, and [`MCXVChain`](/api/qiskit/0.45/qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain") would fail to serialize. See [#9390](https://github.com/Qiskit/qiskit-terra/issues/9390).

*   Fixed the transpiler routing passes [`StochasticSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.StochasticSwap "qiskit.transpiler.passes.StochasticSwap"), [`SabreSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"), [`LookaheadSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap"), and [`BasicSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.BasicSwap "qiskit.transpiler.passes.BasicSwap") so that they consistently raise a [`TranspilerError`](/api/qiskit/0.45/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") when their respective `.run()` method is called if the passes were initialized with `coupling_map=None`. Previously, these passes would raise errors in this case but they were all caused by side effects and the specific exception was not predictable. Fixed [#7127](https://github.com/Qiskit/qiskit-terra/issues/7127)

*   Manually setting an item in [`QuantumCircuit.data`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") will now correctly allow the operation to be any object that implements [`Operation`](/api/qiskit/0.45/qiskit.circuit.Operation "qiskit.circuit.Operation"), not just a [`circuit.Instruction`](/api/qiskit/0.45/qiskit.circuit.Instruction "qiskit.circuit.Instruction"). Note that any manual mutation of [`QuantumCircuit.data`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") is discouraged; it is not *usually* any more efficient than building a new circuit object, as checking the invariants surrounding parametrised objects can be surprisingly expensive.

*   Fixed a bug when constructing [`DAGDependency`](/api/qiskit/0.45/qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") from within the [`TemplateOptimization`](/api/qiskit/0.45/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") transpiler pass, which could lead to incorrect optimizations.

*   Fixed a bug in [`TensoredOp.to_matrix()`](/api/qiskit/0.45/qiskit.opflow.list_ops.TensoredOp#to_matrix "qiskit.opflow.list_ops.TensoredOp.to_matrix") where the global coefficient of the operator was multiplied to the final matrix more than once. Now, the global coefficient is correclty applied, independent of the number of tensored operators or states. Fixed [#9398](https://github.com/Qiskit/qiskit-terra/issues/9398).

*   Fixed global-phase handling in the [`UnrollCustomDefinitions`](/api/qiskit/0.45/qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions") transpiler pass if the instruction in question had a global phase, but no instructions in its definition field.

*   Fixed the the type annotations for the [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function. The return type is now narrowed correctly depending on whether a single circuit or a list of circuits was passed.

*   Fixed a bug where [`IterativePhaseEstimation`](/api/qiskit/0.45/qiskit.algorithms.IterativePhaseEstimation "qiskit.algorithms.IterativePhaseEstimation") was generating the wrong circuit, causing the algorithm to fail for simple cases. Fixed [#9280](https://github.com/Qiskit/qiskit-terra/issues/9280).

*   A bug has been fixed which had allowed broadcasting when a [`PauliList`](/api/qiskit/0.45/qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") is initialized from [`Pauli`](/api/qiskit/0.45/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli")s or labels. For instance, the code `PauliList(["XXX", "Z"])` now raises a `ValueError` rather than constructing the equivalent of `PauliList(["XXX", "ZZZ"])`.

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will no longer emit duplicate definitions for gates that appear in other gates’ definitions. See [#7771](https://github.com/Qiskit/qiskit-terra/issues/7771), [#8086](https://github.com/Qiskit/qiskit-terra/issues/8086), [#8402](https://github.com/Qiskit/qiskit-terra/issues/8402), [#8558](https://github.com/Qiskit/qiskit-terra/issues/8558), and [#9805](https://github.com/Qiskit/qiskit-terra/issues/9805).

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now handle multiple and nested definitions of [`UnitaryGate`](/api/qiskit/0.45/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate"). See [#4623](https://github.com/Qiskit/qiskit-terra/issues/4623), [#6712](https://github.com/Qiskit/qiskit-terra/issues/6712), [#7772](https://github.com/Qiskit/qiskit-terra/issues/7772), and [#8222](https://github.com/Qiskit/qiskit-terra/issues/8222).

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now output definitions for gates used only in other gates’ definitions in a correct order. See [#7769](https://github.com/Qiskit/qiskit-terra/issues/7769) and [#7773](https://github.com/Qiskit/qiskit-terra/issues/7773).

*   Standard gates defined by Qiskit, such as [`RZXGate`](/api/qiskit/0.45/qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate"), will now have properly parametrised definitions when exported using the OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")). See [#7172](https://github.com/Qiskit/qiskit-terra/issues/7172).

*   Quantum volume circuits ([`QuantumVolume`](/api/qiskit/0.45/qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume")) are now supported by the OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")). See [#6466](https://github.com/Qiskit/qiskit-terra/issues/6466) and [#7051](https://github.com/Qiskit/qiskit-terra/issues/7051).

*   The OpenQASM 2 exporter will now output gates with no known definition with `opaque` statements, rather than failing. See [#5036](https://github.com/Qiskit/qiskit-terra/issues/5036).

*   An issue that prevented `transpile()` from working when passed a list of [`CouplingMap`](/api/qiskit/0.45/qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") objects was fixed. Note that passing such a list of coupling maps is deprecated and will not be possible starting with Qiskit Terra 0.25. Fixes [#9885](https://github.com/Qiskit/qiskit-terra/issues/9885).

*   Previous to this release, the `figsize` argument of [`plot_bloch_multivector()`](/api/qiskit/0.45/qiskit.visualization.plot_bloch_multivector "qiskit.visualization.plot_bloch_multivector") was not used by the visualization, making it impossible to change its size (e.g. to shrink it for single-qubit states). This release fixes it by introducing a use for the `figsize` argument.

*   Fixed an issue in [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") with `optimization_level=1` (as well as in the preset pass managers returned by [`generate_preset_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") and [`level_1_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager")) where previously if the `routing_method` and `layout_method` arguments were not set and no control flow operations were present in the circuit then in cases where routing was required the [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") transpiler pass would not be run. This was the opposite of the expected behavior because [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is intended to find a potentially better performing layout after a heuristic layout pass and routing are run. Fixed [#9936](https://github.com/Qiskit/qiskit-terra/issues/9936)

*   Construction of a [`Statevector`](/api/qiskit/0.45/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") from a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") containing zero-qubit operations will no longer raise an error. These operations impart a global phase on the resulting statevector.

*   Fixed an issue in tranpiler passes for padding delays, which did not respect target’s constraints and inserted delays even for qubits not supporting [`Delay`](/api/qiskit/0.45/qiskit.circuit.Delay "qiskit.circuit.Delay") instruction. [`PadDelay`](/api/qiskit/0.45/qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") and [`PadDynamicalDecoupling`](/api/qiskit/0.45/qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") are fixed so that they do not pad any idle time of qubits such that the target does not support `Delay` instructions for the qubits. Also legacy scheduling passes `ASAPSchedule` and `ALAPSchedule`, which pad delays internally, are fixed in the same way. In addition, `transpile()` is fixed to call `PadDelay` with a `target` object so that it works correctly when called with `scheduling_method` option. Fixed [#9993](https://github.com/Qiskit/qiskit-terra/issues/9993)

*   Fixed the type annotations on the [`QuantumCircuit.assign_parameters()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") method to correctly reflect the change in return type depending on the value of the `inplace` argument.

*   Fixed a performance scaling issue with the [`VF2Layout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") passes in the preset pass managers and [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), which would occur when transpiling circuits with many connected components on large devices. Now the transpiler passes set upper bounds on the number of potential layouts that will be evaluated.

*   Fixed an issue in the `state_to_latex()` function where it would potentially produce invalid LaTeX due to unintended coefficient rounding. This could also result in errors when the `state_drawer()` was called. Fixed [#9297](https://github.com/Qiskit/qiskit-terra/issues/9297).

<span id="id41" />

### Aer 0.12.0

No change

<span id="id42" />

### IBM Q Provider 0.20.2

No change

<span id="qiskit-0-42-1" />