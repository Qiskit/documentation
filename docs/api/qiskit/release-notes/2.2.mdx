---
title: Qiskit SDK 2.2 release notes
description: Changes made in Qiskit SDK 2.2
in_page_toc_max_heading_level: 3
---

<span id="qiskit-version-release-notes" />

<span id="release-notes" />

# Qiskit SDK 2.2 release notes

<span id="relnotes-2-2-0" />

<span id="id1" />

## 2.2.2

<span id="relnotes-2-2-2-prelude" />

### Prelude

Qiskit 2.2.2 is a bugfix release for the v2.2 minor version series.

<span id="relnotes-2-2-2-bug-fixes" />

### Bug Fixes

*   Fixed the implementation of [`__deepcopy__()`](https://docs.python.org/3/library/copy.html#object.__deepcopy__ "(in Python v3.14)") in [`QuantumCircuit`](/docs/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which did not deep-copy circuit parameters. As a consequence, mutating a [`BoxOp`](/docs/api/qiskit/qiskit.circuit.BoxOp "qiskit.circuit.BoxOp") in a copied circuit no longer affects the original circuit.

*   Fixed an issue in the [`Optimize1qGatesDecomposition`](/docs/api/qiskit/qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") pass when the pass is initialized with a [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") containing 1-qubit gates with fixed angle parameters. Previously, the pass would potentially output gates not included in the target as it did not check whether the gates in the target supported arbitrary parameter values. Fixed [#14743](https://github.com/Qiskit/qiskit/issues/14743).

*   Fixed incorrect behavior in the [`BasisTranslator`](/docs/api/qiskit/qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") pass where a multi-qubit gate within a [`ControlFlowOp`](/docs/api/qiskit/qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") block would track using its local qubit indices instead of using the absolute indices from the source circuit.

*   The [`ConsolidateBlocks`](/docs/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") transpiler pass will now correctly evaluate whether a given gate is hardware-supported while recursing into control-flow operations.

*   [`qpy.dump()`](/docs/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump") can now handle writing out to `.gz` files opened using the standard-library [`gzip`](https://docs.python.org/3/library/gzip.html#module-gzip "(in Python v3.14)") module with QPY versions 16 or greater. See [#15157](https://github.com/Qiskit/qiskit/pull/15157) for details.

*   Fixed the method [`MCPhaseGate.inverse()`](/docs/api/qiskit/qiskit.circuit.library.MCPhaseGate#inverse "qiskit.circuit.library.MCPhaseGate.inverse") to preserve the control states of open-controlled gates when computing their inverses.

*   [`ConsolidateBlocks`](/docs/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") will now return a Python-space exception instead of panicking when it detects invalid or out-of-date analysis in the legacy `run_list` or `block_list` [`PropertySet`](/docs/api/qiskit/qiskit.passmanager.PropertySet "qiskit.passmanager.PropertySet") keys. Fixed [#14646](https://github.com/Qiskit/qiskit/issues/14646).

*   [`Optimize1qGatesDecomposition`](/docs/api/qiskit/qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") will now raise a [`TranspilerError`](/docs/api/qiskit/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") instead of a Rust-space panic when attempting to run on a circuit that is too large for the [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target"). Fixed [#15116](https://github.com/Qiskit/qiskit/issues/15116).

*   The scheduling passes, [`ALAPScheduleAnalysis`](/docs/api/qiskit/qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis") and [`ASAPScheduleAnalysis`](/docs/api/qiskit/qiskit.transpiler.passes.ASAPScheduleAnalysis "qiskit.transpiler.passes.ASAPScheduleAnalysis"), will now correctly handle circuits with no operations in them. Previously they raised a [`TranspilerError`](/docs/api/qiskit/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") falsely claiming “No durations provided”. Fixed [#15145](https://github.com/Qiskit/qiskit/issues/15145).

*   Fixed a failure in the circuit text drawer, which could occur when circuit blocks inside control flow operations were defined on different registers than the outer circuit. This situation could for example happen when appending [`ControlFlowOp`](/docs/api/qiskit/qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") operations directly, or for circuits after transpilation.

<span id="relnotes-2-2-1" />

<span id="id2" />

## 2.2.1

<span id="relnotes-2-2-1-prelude" />

<span id="id3" />

### Prelude

Qiskit 2.2.1 is a small patch release that fixes several bugs identified in the 2.2.0 release.

<span id="relnotes-2-2-1-transpiler-upgrade-notes" />

### Transpiler Upgrade Notes

*   The maximum call and trial limits for the exact-matching run of [`VF2PostLayout`](/docs/api/qiskit/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") at `optimization_level=3` have been reduced to avoid excessive runtimes for highly symmetric trial circuits being mapped to large coupling maps.

<span id="relnotes-2-2-1-bug-fixes" />

<span id="id4" />

### Bug Fixes

*   [`DAGCircuit.apply_operation_back()`](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit#apply_operation_back "qiskit.dagcircuit.DAGCircuit.apply_operation_back"), [`apply_operation_back()`](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit#apply_operation_back "qiskit.dagcircuit.DAGCircuit.apply_operation_back") and `circuit_to_dag()` will now add new edges in a deterministic order. The previous behavior could cause certain transpiler passes (such as [`SabreSwap`](/docs/api/qiskit/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap")) to traverse the DAG in non-deterministic orders.

*   [`DAGCircuit.apply_operation_front()`](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit#apply_operation_front "qiskit.dagcircuit.DAGCircuit.apply_operation_front") can no longer insert invalid self loops when handling nodes that include classical conditions.

*   Fixed an issue with [`pickle`](https://docs.python.org/3/library/pickle.html#module-pickle "(in Python v3.14)") support for the [`SabreSwap`](/docs/api/qiskit/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") where a [`SabreSwap`](/docs/api/qiskit/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") instance would error when being pickled after the [`SabreSwap.run()`](/docs/api/qiskit/qiskit.transpiler.passes.SabreSwap#run "qiskit.transpiler.passes.SabreSwap.run") method was run. Fixed [#15071](https://github.com/Qiskit/qiskit/issues/15071).

*   Fixed an issue where [`is_unitary()`](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp#is_unitary "qiskit.quantum_info.SparsePauliOp.is_unitary") was not properly respecting the input tolerance values when checking if an operator is unitary. The method now correctly uses the provided `atol` and `rtol` parameters when simplifying the operator and checking if it equals the identity. This fixes [#14107](https://github.com/Qiskit/qiskit/issues/14107).

<span id="relnotes-2-2-0" />

<span id="id5" />

## 2.2.0

<span id="relnotes-2-2-0-prelude" />

<span id="id6" />

### Prelude

The Qiskit v2.2 adds several enhancements for the C API and the transpiler as well as many other improvements and bug fixes. The major features of this new release are:

> *   **C API transpile function:** The C API now includes a function for transpiling a quantum circuit: [`qk_transpile()`](/docs/api/qiskit-c/qk-transpiler). This function is equivalent to the Python [`transpile()`](/docs/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function for a standalone C context.
> *   **Litinski transformation pass:** A new transformation pass [`LitinskiTransformation`](/docs/api/qiskit/qiskit.transpiler.passes.LitinskiTransformation "qiskit.transpiler.passes.LitinskiTransformation") that implements the transform described [arXiv:1808.02892](https://arxiv.org/abs/1808.02892). This is pass is typically used in compilation for fault tolerant architectures.
> *   **Angle bound support for targets:** The [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") class now supports specifying bounds for the allowed values for parameterized operations added to the target. When an instruction is added to the [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") you can add the optional argument angle\_bounds to specify the higher and lower bounds for parameterized rotation gates. A new transpiler pass [`WrapAngles`](/docs/api/qiskit/qiskit.transpiler.passes.WrapAngles "qiskit.transpiler.passes.WrapAngles") was added to enforce the angle constraints as part of a transpilation pipeline.

The v2.2 release series is the final minor release series with support Python 3.9. The minimum supported Rust version use to build Qiskit from source is now Rust v1.85, raised from 1.79 in 2.1.0. For more information about the above and other changes made, please see the release notes below and review the updated documentation.

<span id="relnotes-2-2-0-c-api-features" />

### C API Features

*   Added new standalone transpiler pass functions to the C API. These functions take in a `QkCircuit` to run the pass on and are equivalent to calling an instantiated pass.

    > | Transpiler pass                                                                                                                                             | C API Counterpart                                                                                                                                                                                                                                              |
    > | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    > | [`BasisTranslator`](/docs/api/qiskit/qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator")                                                    | [`qk_transpiler_pass_standalone_basis_translator()`](/docs/api/qiskit-c/qk-transpiler-passes)                                           |
    > | [`CommutativeCancellation`](/docs/api/qiskit/qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation")                            | [`qk_transpiler_pass_standalone_commutative_cancellation()`](/docs/api/qiskit-c/qk-transpiler-passes)                         |
    > | [`ConsolidateBlocks`](/docs/api/qiskit/qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks")                                              | [`qk_transpiler_pass_standalone_consolidate_blocks()`](/docs/api/qiskit-c/qk-transpiler-passes)                                          |
    > | [`ElidePermutations`](/docs/api/qiskit/qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations")                                              | [`qk_transpiler_pass_standalone_elide_permutations()`](/docs/api/qiskit-c/qk-transpiler-passes)                                                       |
    > | [`CheckGateDirection`](/docs/api/qiskit/qiskit.transpiler.passes.CheckGateDirection "qiskit.transpiler.passes.CheckGateDirection")                                           | [`qk_transpiler_pass_standalone_check_gate_direction()`](/docs/api/qiskit-c/qk-transpiler-passes)                                     |
    > | [`GateDirection`](/docs/api/qiskit/qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection")                                                          | [`qk_transpiler_pass_standalone_gate_direction()`](/docs/api/qiskit-c/qk-transpiler-passes)                                                        |
    > | [`InverseCancellation`](/docs/api/qiskit/qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation")                                        | [`qk_transpiler_pass_standalone_inverse_cancellation()`](/docs/api/qiskit-c/qk-transpiler-passes)                                                 |
    > | [`Optimize1qGatesDecomposition`](/docs/api/qiskit/qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition")             | [`qk_transpiler_standalone_optimize_1q_sequences()`](/docs/api/qiskit-c/qk-transpiler-passes)                                                  |
    > | [`RemoveDiagonalGatesBeforeMeasure`](/docs/api/qiskit/qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure "qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure") | [`qk_transpiler_pass_standalone_remove_diagonal_gates_before_measure()`](/docs/api/qiskit-c/qk-transpiler-passes) |
    > | [`RemoveIdentityEquivalent`](/docs/api/qiskit/qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent")                         | [`qk_transpiler_pass_standalone_remove_identity_equivalent()`](/docs/api/qiskit-c/qk-transpiler-passes)                   |
    > | [`SabreLayout`](/docs/api/qiskit/qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout")                                                                | [`qk_transpiler_pass_standalone_sabre_layout()`](/docs/api/qiskit-c/qk-transpiler-passes)                                      |
    > | [`Split2QUnitaries`](/docs/api/qiskit/qiskit.transpiler.passes.Split2QUnitaries "qiskit.transpiler.passes.Split2QUnitaries")                                                 | [`qk_transpiler_pass_standalone_split_2q_unitaries()`](/docs/api/qiskit-c/qk-transpiler-passes)                                                     |
    > | [`UnitarySynthesis`](/docs/api/qiskit/qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis")                                                 | [`qk_transpiler_pass_standalone_unitary_synthesis()`](/docs/api/qiskit-c/qk-transpiler-passes)                                       |
    > | [`VF2Layout`](/docs/api/qiskit/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout")                                                                      | [`qk_transpiler_pass_standalone_vf2_layout()`](/docs/api/qiskit-c/qk-transpiler-passes)                                                 |

*   Added [`qk_obs_apply_layout()`](/docs/api/qiskit-c/qk-obs) to apply new qubit layouts to a `QkObs` observable. This function takes the observable, the new qubit indices, and an output number of qubits. Importantly, this function allows applying transpile layouts, usually given as `QkTranspileLayout` by a transpiler pass, to an observable. For example:

    ```c
    // get the number of output qubits -- transpile_layout is a QkTranspileLayout*
    uint32_t num_output_qubits = qk_transpile_layout_num_output_qubits(transpile_layout);

    // get the layout including the ancillas (hence the ``false`` in the function call)
    uint32_t *layout = malloc(sizeof(uint32_t) * num_output_qubits);
    qk_transpile_layout_final_layout(transpile_layout, false, layout);

    // apply the layout -- obs is a QkObs*
    int exit = qk_obs_apply_layout(obs, layout, num_output_qubits);

    // free the layout array
    free(layout);
    ```

<span id="relnotes-2-2-0-circuits-features" />

### Circuits Features

*   A new fast-path method [`ParameterExpression.bind_all()`](/docs/api/qiskit/qiskit.circuit.ParameterExpression#bind_all "qiskit.circuit.ParameterExpression.bind_all") is added to support the use-case of binding many different [`ParameterExpression`](/docs/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") instances to numeric values using the same mappings dictionary. The existing [`bind()`](/docs/api/qiskit/qiskit.circuit.ParameterExpression#bind "qiskit.circuit.ParameterExpression.bind") method has a large amount of overhead and unnecessary allocations, since it always returns a [`ParameterExpression`](/docs/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") for typing consistency.

<span id="relnotes-2-2-0-openqasm-features" />

### OpenQASM Features

*   Added partial support for `defcal` symbols in the OpenQASM3 exporter. This enables downstream packages to export custom instructions that operate on both quantum and classical bits using [`qiskit.qasm3.dumps()`](/docs/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps"). Users can now define custom instructions (e.g., a `CustomMeasure` that acts on a qubit and returns a classical bit) and specify their behavior using `DefcalInstruction`. These defcals are passed to the exporter via the `implicit_defcals` argument in [`qiskit.qasm3.dumps()`](/docs/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps").

    For example:

    ```python
    from qiskit.circuit import Instruction, QuantumCircuit
    from qiskit.qasm3 import dumps
    from qiskit.qasm3.exporter import DefcalInstruction, types

    custom_measure = Instruction("measure_2", 1, 1, [])
    qc = QuantumCircuit(1, 1)
    qc.h(0)
    qc.append(custom_measure, [0], [0])
    qc.measure(0, 0)

    defcals = {
        "measure_2": DefcalInstruction("measure_2", 0, 1, types.Bool()),
    }

    out_qasm = dumps(qc, implicit_defcals=defcals)
    print(out_qasm)
    ```

    Would output the following valid OpenQASM3 string:

    ```python
    OPENQASM 3.0;
    bit[1] c;
    qubit[1] q;
    h q[0];
    c[0] = measure_2 q[0];
    c[0] = measure q[0];
    ```

    This approach assumes that the grammar definition for the defcal is provided externally (e.g., in a header file), although such a file is not strictly required for the exporter to function.

*   The functions [`qasm3.loads()`](/docs/api/qiskit/qasm3#qiskit.qasm3.loads "qiskit.qasm3.loads") and [`qasm3.load()`](/docs/api/qiskit/qasm3#qiskit.qasm3.load "qiskit.qasm3.load") now have an extra argument called `num_qubits`. If provided, the functions will return circuits that will have qubits equal to `num_qubits`. If not provided, the returned circuit will have qubits equal to the maximum index seen in the serialized circuit. Refer to [#14435](https://github.com/Qiskit/qiskit/issues/14435) for more details

<span id="relnotes-2-2-0-quantum-information-features" />

### Quantum Information Features

*   Added methods [`QubitSparsePauli.to_pauli()`](/docs/api/qiskit/qiskit.quantum_info.QubitSparsePauli#to_pauli "qiskit.quantum_info.QubitSparsePauli.to_pauli") and [`QubitSparsePauliList.to_pauli_list()`](/docs/api/qiskit/qiskit.quantum_info.QubitSparsePauliList#to_pauli_list "qiskit.quantum_info.QubitSparsePauliList.to_pauli_list"), which convert the sparse objects into the corresponding dense versions, [`Pauli`](/docs/api/qiskit/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") and [`PauliList`](/docs/api/qiskit/qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList"), respectively.

*   Added the [`PhasedQubitSparsePauli`](/docs/api/qiskit/qiskit.quantum_info.PhasedQubitSparsePauli "qiskit.quantum_info.PhasedQubitSparsePauli") and [`PhasedQubitSparsePauliList`](/docs/api/qiskit/qiskit.quantum_info.PhasedQubitSparsePauliList "qiskit.quantum_info.PhasedQubitSparsePauliList") classes. These classes represent a single Pauli operator and a list of Pauli operators respectively stored in qubit-sparse format. These classes are very similar to [`QubitSparsePauli`](/docs/api/qiskit/qiskit.quantum_info.QubitSparsePauli "qiskit.quantum_info.QubitSparsePauli") and [`QubitSparsePauliList`](/docs/api/qiskit/qiskit.quantum_info.QubitSparsePauliList "qiskit.quantum_info.QubitSparsePauliList"), except they additionally contain phase information.

*   Added the method [`QubitSparsePauliList.to_dense_array()`](/docs/api/qiskit/qiskit.quantum_info.QubitSparsePauliList#to_dense_array "qiskit.quantum_info.QubitSparsePauliList.to_dense_array"). This returns the list as an array of integers with the values of [`Pauli`](/docs/api/qiskit/qiskit.quantum_info.QubitSparsePauli#pauli "qiskit.quantum_info.QubitSparsePauli.Pauli").

<span id="relnotes-2-2-0-transpiler-features" />

### Transpiler Features

*   Added support for a [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") to specify angle bounds on instructions. Prior to this release a [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") could specify that an operation that took a parameter either would allow any valid value or a specific value. For example, if `RZGate(Parameter("theta"))` were added to the target that would indicate an [`RZGate`](/docs/api/qiskit/qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate") with any value for theta were allowed. While if `RZGate(math.pi)` were added to the target that would indicate [`RZGate`](/docs/api/qiskit/qiskit.circuit.library.RZGate "qiskit.circuit.library.RZGate") that only $\pi$ is the only allowed value on the target. This new feature enables restricting the allowed angles to be any `float` value between a an inclusive bound. For example, you can add `RZGate(math.pi)` to a [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") and restrict the angle value between the values 0 and $2\pi$.

    There are several methods available for working with the angle bounds on the target. The first is [`Target.add_instruction()`](/docs/api/qiskit/qiskit.transpiler.Target#add_instruction "qiskit.transpiler.Target.add_instruction") which has a new `angle_bounds` keyword argument that is used to add an angle bound to an instruction in the [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target"). To work with angle bounds you will also want to register a callback function to the global [`WRAP_ANGLE_REGISTRY`](/docs/api/qiskit/transpiler_passes#qiskit.transpiler.passes.qiskit.transpiler.passes.utils.wrap_angles.WRAP_ANGLE_REGISTRY "qiskit.transpiler.passes.qiskit.transpiler.passes.utils.wrap_angles.WRAP_ANGLE_REGISTRY") registry that will tell the transpiler and [`WrapAngles`](/docs/api/qiskit/qiskit.transpiler.passes.WrapAngles "qiskit.transpiler.passes.WrapAngles") pass how to adjust gates for angle bounds. The callback function will take a list of arbitrary `float` values representing the gate angles from the circuit, as well as the qubit indices in the circuit the gate was operating on and it will return a [`DAGCircuit`](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") that represents an equivalent circuit for the gate with that angle but respecting the angle bounds and other [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") constraints. For example:

    ```python
    import math

    from qiskit.dagcircuit import DAGCircuit
    from qiskit.transpiler import Target
    from qiskit.transpiler.passes.utils.wrap_angles import WRAP_ANGLE_REGISTRY

    target = Target(num_qubits=1)
    target.add_instruction(RZGate(Parameter("theta")), angle_bounds=[(-math.pi, math.pi)])

    def callback(angles: List[float], qubits: List[int]) -> DAGCircuit:
        """Callback function to wrap RZ gate angles

        Args:
            angles: The list of floating point parameter values for the instance of RZGate in
                the circuit
            qubits: The physical qubit indices that this gate is operating on

        Returns:
            The DAGCircuit of the equivalent circuit"""

        angle = angles[0]
        dag = DAGCircuit()
        dag.add_qubits([Qubit()])
        if angle > 0:
            divisor = math.pi
        else:
            divisor = -math.pi
        gate_counts = int(angles[0] // divisor)
        rem = angles[0] % divisor
        for _ in range(gate_counts):
            dag.apply_operation_back(RZGate(math.pi), [dag.qubits[0]], check=True)
        dag.apply_operation_back(rem, [dag.qubits[0]], check=True)

    WRAP_ANGLE_REGISTRY.add_wrapper("rz", callback)
    ```

    [`Target.has_angle_bounds()`](/docs/api/qiskit/qiskit.transpiler.Target#has_angle_bounds "qiskit.transpiler.Target.has_angle_bounds") can be used to check whether there are any angle bounds set in the target, and [`Target.gate_has_angle_bounds()`](/docs/api/qiskit/qiskit.transpiler.Target#gate_has_angle_bounds "qiskit.transpiler.Target.gate_has_angle_bounds").

    If you want to apply the angle bounds from a target to any gates in a circuit the [`WrapAngles`](/docs/api/qiskit/qiskit.transpiler.passes.WrapAngles "qiskit.transpiler.passes.WrapAngles") transpiler pass should be used to do this.

*   Added a new kwarg `check_angle_bounds` to the [`Target.instruction_supported()`](/docs/api/qiskit/qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported") method. When set to `True` (the default) the method will check if the specified `parameters` also conforms to any angle bounds that may exist for the instruction being queried.

*   Added a new transpiler pass [`WrapAngles`](/docs/api/qiskit/qiskit.transpiler.passes.WrapAngles "qiskit.transpiler.passes.WrapAngles") which is used to apply angle constraints on gates in the [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target"). If a [`Target`](/docs/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") has defined angle bounds this pass will analyze all the parameters for the gates in the circuit and check that against the bounds specified in the target. For example, if a target contains a custom gate that has angle bounds the pass will decompose that gate into a gate which conforms to the bounds:

    ```python
    from qiskit.circuit import Gate, Parameter, QuantumCircuit, Qubit
    from qiskit.dagcircuit import DAGCircuit
    from qiskit.transpiler import Target, WrapAngleRegistry
    from qiskit.transpiler.passes import WrapAngles

    class MyCustomGate(Gate):

        def __init__(self, angle):
            super().__init__("my_custom", 1, [angle])

    param = Parameter("a")
    circuit = QuantumCircuit(1)
    circuit.append(MyCustomGate(6.0), [0])
    target = Target(num_qubits=1)
    target.add_instruction(MyCustomGate(param), angle_bounds=[(0, 0.5)])

    def callback(angles, _qubits):
        angle = angles[0]
        if angle > 0:
            number_of_gates = angle / 0.5
        else:
            number_of_gates = (6.28 - angle) / 0.5
        dag = DAGCircuit()
        dag.add_qubits([Qubit()])
        for _ in range(int(number_of_gates)):
            dag.apply_operation_back(MyCustomGate(0.5), [dag.qubits[0]])
        return dag

    registry = WrapAngleRegistry()
    registry.add_wrapper("my_custom", callback)
    wrap_pass = WrapAngles(target, registry)
    res = wrap_pass(circuit)
    res.draw('mpl')
    ```

    ![\_images/release\_notes-1.png](/docs/images/api/qiskit/release_notes-1.avif)

*   [`DAGCircuit`](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") now has a manual implementation of [`__deepcopy__()`](https://docs.python.org/3/library/copy.html#object.__deepcopy__ "(in Python v3.14)"). This is orders of magnitude faster than the previous implicit implementation from the pickle protocol, especially for large circuits. This also directly benefits compilation performance when running [`transpile()`](/docs/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or running the preset pass managers returned by [`generate_preset_pass_manager()`](/docs/api/qiskit/qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") at `optimization_level=3` as optimization level 3 internally deep copies the [`DAGCircuit`](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") for each iteration of the optimization loop in the `optimization` stage.

*   Added a new class [`OptimizationMetric`](/docs/api/qiskit/qiskit.transpiler.OptimizationMetric "qiskit.transpiler.OptimizationMetric") which specifies the optimization criterion in the [`HighLevelSynthesis`](/docs/api/qiskit/qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") pass. Currently the two supported metrics are:

    *   `COUNT_2Q`: optimizes the number of two-qubit gates.
    *   `COUNT_T`: optimizes the number of T-gates, when transpiling into a Clifford+T basis set.

    The transpiler automatically selects the target metric based on the basis gate set, e.g. it will use `COUNT_T` if a Clifford+T basis set is detected. However, this class can not be currently set manually when running [`transpile()`](/docs/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or running a preset pass manager generated by [`generate_preset_pass_manager()`](/docs/api/qiskit/qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager").

*   Added a new argument `optimization_metric` to the constructor for [`HighLevelSynthesis`](/docs/api/qiskit/qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass which takes an [`OptimizationMetric`](/docs/api/qiskit/qiskit.transpiler.OptimizationMetric "qiskit.transpiler.OptimizationMetric") object. When set to `COUNT_T`, the pass chooses decompositions that are more suitable for the Clifford+T gate set.

*   The default high-level synthesis plugins for [`ModularAdderGate`](/docs/api/qiskit/qiskit.circuit.library.ModularAdderGate "qiskit.circuit.library.ModularAdderGate") and [`MultiplierGate`](/docs/api/qiskit/qiskit.circuit.library.MultiplierGate "qiskit.circuit.library.MultiplierGate") produce better T-counts when transpiling into Clifford+T basis set.

*   The default high-level synthesis plugin for [`MCXGate`](/docs/api/qiskit/qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") produces better T-counts when transpiling into Clifford+T basis set, provided at least 1 ancilla qubit is available.

*   Re-enabled running [`VF2PostLayout`](/docs/api/qiskit/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") transpiler pass in the `optimization` stage for `optimization_level=3` with the [`transpile()`](/docs/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function and the generated pass manager objects returned by the [`generate_preset_pass_manager()`](/docs/api/qiskit/qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") function. The pass runs with `strict_direction=True` after all the physical optimizations performed in the stage to attempt and improve the layout one final time with the exact output circuit. This was previously enabled in Qiskit v2.1.0 but was reverted in 2.1.2 due to issues with the initial implementation. These issues have been fixed and the layout will be properly applied if a better one is found.

<span id="relnotes-2-2-0-visualization-features" />

### Visualization Features

*   A new option, `measure_arrows`, has been added to the `mpl` and `text` backends for the circuit drawer [`qiskit.visualization.circuit_drawer()`](/docs/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") and [`qiskit.circuit.QuantumCircuit.draw()`](/docs/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw"). When this option is set to `True`, the drawer will draw an arrow from the `measure` box to the classical bits below. This was the previous behavior in the drawers. If it is set to `False`, no arrows will be drawn and instead the classical register and bit being used by the `measure` will be indicated inside the `measure` box. This allows `measure` boxes to be stacked within a vertical layer.

    If no option is set, the default is `True`. The user can change the default in the user config file, by default in the `~/.qiskit` directory, in the file `settings.conf`. Under the `[Default]` heading, a user can enter `circuit_measure_arrows = False` to change the default.

<span id="relnotes-2-2-0-quantum-information-upgrade-notes" />

### Quantum Information Upgrade Notes

*   [`SparsePauliOp.assign_parameters()`](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp#assign_parameters "qiskit.quantum_info.SparsePauliOp.assign_parameters") will now set the dtype of the output [`coeffs`](/docs/api/qiskit/qiskit.quantum_info.SparsePauliOp#coeffs "qiskit.quantum_info.SparsePauliOp.coeffs") array to [`complex`](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)") if all parameters are fully bound to numeric values.

<span id="relnotes-2-2-0-bug-fixes" />

<span id="id7" />

### Bug Fixes

*   Fixed a problem in [`CommutationChecker`](/docs/api/qiskit/qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker"), where standard controlled gates were not handled correctly if they were controlled on something other than the all-ones state. Fixed [#14974](https://github.com/Qiskit/qiskit/issues/14974)

*   [`QuantumCircuit.compose()`](/docs/api/qiskit/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") will now correctly remap anyway variables and stretches used in [`Delay`](/docs/api/qiskit/circuit#qiskit.circuit.Delay "qiskit.circuit.Delay") instructions when the `var_remap` argument is specified.

*   Fixed an issue in the [`VF2PostLayout`](/docs/api/qiskit/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") transpiler pass. In certain situations when the pass is being run with the argument `strict_direction=True` there was a potential runtime scaling issue when the interaction graph of the circuit contained any qubits that only had 1 qubit operations. These mapping problems result in a combinatorial complexity for scoring that would lead to the pass almost always hitting the scoring timeout and typically not improving the layout. In `strict_direction=False` mode there is an optimized search implementation for these problems, but the additional constraints for `strict_direction=True` don’t make this approach viable. Instead in these cases [`VF2PostLayout`](/docs/api/qiskit/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") will now skip the search since the layout problem isn’t viable for the pass.

