---
title: Qiskit 0.37 release notes
description: Changes made in Qiskit 0.37
in_page_toc_max_heading_level: 4
---

# Qiskit 0.37 release notes

## 0.37.2

<span id="release-notes-terra-0-21-2" />

<span id="id106" />

### Terra 0.21.2

<span id="release-notes-terra-0-21-2-prelude" />

<span id="id107" />

#### Prelude

Qiskit Terra 0.21.2 is a primarily a bugfix release, and also comes with several improved documentation pages.

<span id="release-notes-terra-0-21-2-bug-fixes" />

<span id="id108" />

#### Bug Fixes

*   `aer_simulator_statevector_gpu` will now be recognized correctly as statevector method in some function when using Qiskit Aer’s GPU simulators in [`QuantumInstance`](/api/qiskit/0.45/qiskit.utils.QuantumInstance "qiskit.utils.QuantumInstance") and other algorithm runners.

*   Fixed the [`UCGate.inverse()`](/api/qiskit/0.45/qiskit.circuit.library.UCGate#inverse "qiskit.circuit.library.UCGate.inverse") method which previously did not invert the global phase.

*   [`QuantumCircuit.compose()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") will now function correctly when used with the `inplace=True` argument within control-flow builder contexts. Previously the instructions would be added outside the control-flow scope. Fixed [#8433](https://github.com/Qiskit/qiskit-terra/issues/8433).

*   Fixed a bug where a bound [`ParameterExpression`](/api/qiskit/0.45/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") was not identified as real if `symengine` was installed and the bound expression was not a plain `1j`. For example:

    ```python
    from qiskit.circuit import Parameter

    x = Parameter("x")
    expr = 1j * x
    bound = expr.bind({x: 2})
    print(bound.is_real())  # used to be True, but is now False
    ```

*   Fixed QPY serialisation and deserialisation of [`ControlledGate`](/api/qiskit/0.45/qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") with open controls (*i.e.* those whose `ctrl_state` is not all ones). Fixed [#8549](https://github.com/Qiskit/qiskit-terra/issues/8549).

*   All fake backends in `qiskit.providers.fake_provider.backends` have been updated to return the corresponding pulse channel objects with the method call of `drive_channel()`, `measure_channel()`, `acquire_channel()`, `control_channel()`.

*   Fixed support for running `Z2Symmetries.taper()` on larger problems. Previously, the method would require a large amount of memory which would typically cause failures for larger problem. As a side effect of this fix the performance has significantly improved.

<span id="aer-0-10-4" />

### Aer 0.10.4

No change

<span id="id109" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-37-1" />

## 0.37.1

<span id="terra-0-21-1" />

<span id="release-notes-terra-0-21-1" />

### Terra 0.21.1

<span id="release-notes-terra-0-21-1-bug-fixes" />

<span id="id110" />

#### Bug Fixes

*   Fixed an issue in [`QuantumCircuit.decompose()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose") method when passing in a list of `Gate` classes for the `gates_to_decompose` argument. If any gates in the circuit had a label set this argument wouldn’t be handled correctly and caused the output decomposition to incorrectly skip gates explicitly in the `gates_to_decompose` list.

*   Fix [`to_instruction()`](/api/qiskit/0.45/qiskit.opflow.evolutions.EvolvedOp#to_instruction "qiskit.opflow.evolutions.EvolvedOp.to_instruction") which previously tried to create a [`UnitaryGate`](/api/qiskit/0.45/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") without exponentiating the operator to evolve. Since this operator is generally not unitary, this raised an error (and if the operator would have been unitary by chance, it would not have been the expected result).

    Now calling [`to_instruction()`](/api/qiskit/0.45/qiskit.opflow.evolutions.EvolvedOp#to_instruction "qiskit.opflow.evolutions.EvolvedOp.to_instruction") correctly produces a gate that implements the time evolution of the operator it holds:

    ```python
    >>> from qiskit.opflow import EvolvedOp, X
    >>> op = EvolvedOp(0.5 * X)
    >>> op.to_instruction()
    Instruction(
        name='unitary', num_qubits=1, num_clbits=0,
        params=[array([[0.87758256+0.j, 0.-0.47942554j], [0.-0.47942554j, 0.87758256+0.j]])]
    )
    ```

*   Fixed an issue with the [`marginal_distribution()`](/api/qiskit/0.45/result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") function: when a numpy array was passed in for the `indices` argument the function would raise an error. Fixed [#8283](https://github.com/Qiskit/qiskit-terra/issues/8283)

*   Previously it was not possible to adjoint a [`CircuitStateFn`](/api/qiskit/0.45/qiskit.opflow.state_fns.CircuitStateFn "qiskit.opflow.state_fns.CircuitStateFn") that has been constructed from a [`VectorStateFn`](/api/qiskit/0.45/qiskit.opflow.state_fns.VectorStateFn "qiskit.opflow.state_fns.VectorStateFn"). That’s because the statevector has been converted to a circuit with the `Initialize` instruction, which is not unitary. This problem is now fixed by instead using the [`StatePreparation`](/api/qiskit/0.45/qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") instruction, which can be used since the state is assumed to start out in the all 0 state.

    For example we can now do:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.opflow import StateFn

    left = StateFn([0, 1])
    left_circuit = left.to_circuit_op().primitive

    right_circuit = QuantumCircuit(1)
    right_circuit.x(0)

    overlap = left_circuit.inverse().compose(right_circuit)  # this line raised an error before!
    ```

*   Fix a bug in the [`Optimizer`](/api/qiskit/0.45/qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") classes where re-constructing a new optimizer instance from a previously exisiting [`settings`](/api/qiskit/0.45/qiskit.algorithms.optimizers.Optimizer#settings "qiskit.algorithms.optimizers.Optimizer.settings") reset both the new and previous optimizer settings to the defaults. This notably led to a bug if [`Optimizer`](/api/qiskit/0.45/qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") objects were send as input to Qiskit Runtime programs.

    Now optimizer objects are correctly reconstructed:

    ```python
    >>> from qiskit.algorithms.optimizers import COBYLA
    >>> original = COBYLA(maxiter=1)
    >>> reconstructed = COBYLA(**original.settings)
    >>> reconstructed._options["maxiter"]
    1  # used to be 1000!
    ```

*   Fixed an issue where the `limit_amplitude` argument on an individual [`SymbolicPulse`](/api/qiskit/0.45/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") or [`Waveform`](/api/qiskit/0.45/qiskit.pulse.library.Waveform "qiskit.pulse.library.Waveform") instance was not properly reflected by parameter validation. In addition, QPY schedule [`dump()`](/api/qiskit/0.45/qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been fixed to correctly store the `limit_amplitude` value tied to the instance, rather than saving the global class variable.

*   Fix the pairwise entanglement structure for [`NLocal`](/api/qiskit/0.45/qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") circuits. This led to a bug in the [`ZZFeatureMap`](/api/qiskit/0.45/qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap"), where using `entanglement="pairwise"` raised an error. Now it correctly produces the desired feature map:

    ```python
    from qiskit.circuit.library import ZZFeatureMap
    encoding = ZZFeatureMap(4, entanglement="pairwise", reps=1)
    print(encoding.decompose().draw())
    ```

    The above prints:

    ```python
         ┌───┐┌─────────────┐
    q_0: ┤ H ├┤ P(2.0*x[0]) ├──■────────────────────────────────────■────────────────────────────────────────────
         ├───┤├─────────────┤┌─┴─┐┌──────────────────────────────┐┌─┴─┐
    q_1: ┤ H ├┤ P(2.0*x[1]) ├┤ X ├┤ P(2.0*(π - x[0])*(π - x[1])) ├┤ X ├──■────────────────────────────────────■──
         ├───┤├─────────────┤└───┘└──────────────────────────────┘└───┘┌─┴─┐┌──────────────────────────────┐┌─┴─┐
    q_2: ┤ H ├┤ P(2.0*x[2]) ├──■────────────────────────────────────■──┤ X ├┤ P(2.0*(π - x[1])*(π - x[2])) ├┤ X ├
         ├───┤├─────────────┤┌─┴─┐┌──────────────────────────────┐┌─┴─┐└───┘└──────────────────────────────┘└───┘
    q_3: ┤ H ├┤ P(2.0*x[3]) ├┤ X ├┤ P(2.0*(π - x[2])*(π - x[3])) ├┤ X ├──────────────────────────────────────────
         └───┘└─────────────┘└───┘└──────────────────────────────┘└───┘
    ```

*   Fixed an issue in handling the global phase of the [`UCGate`](/api/qiskit/0.45/qiskit.circuit.library.UCGate "qiskit.circuit.library.UCGate") class.

<span id="id111" />

### Aer 0.10.4

No change

<span id="id112" />

### IBM Q Provider 0.19.2

No change

<span id="qiskit-0-37-0" />
## 0.37.0

This release officially marks the end of support for the Qiskit Ignis project from Qiskit. It was originally deprecated in the 0.33.0 release and as was documented in that release the `qiskit-ignis` package has been removed from the Qiskit metapackage, which means in that future release `pip install qiskit` will no longer include `qiskit-ignis`. However, note because of limitations in python packaging we cannot automatically remove a pre-existing install of `qiskit-ignis`. If you are upgrading from a previous version it’s recommended that you manually uninstall Qiskit Ignis with `pip uninstall qiskit-ignis` or install the metapackage in a fresh python environment.

Qiskit Ignis has been supersceded by the [Qiskit Experiments](https://qiskit.org/documentation/experiments/) project. You can refer to the [migration guide](https://github.com/Qiskit/qiskit-ignis#migration-guide) for details on how to switch from Qiskit Ignis to Qiskit Experiments.

<span id="terra-0-21-0" />

### Terra 0.21.0

<span id="release-notes-0-21-0-prelude" />

<span id="id113" />

#### Prelude

The Qiskit 0.21.0 release highlights are:

> *   Support for serialization of a pulse [`ScheduleBlock`](/api/qiskit/0.45/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") via [`qiskit.qpy`](/api/qiskit/0.45/qpy#module-qiskit.qpy "qiskit.qpy"). The [QPY Format](/api/qiskit/0.45/qpy#qpy-format) has been updated to version 5 which includes a definition for including the pulse schedules. To support this, a new [`SymbolicPulse`](/api/qiskit/0.45/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") class was introduced to enable defining parametric pulse waveforms via symbolic expressions.
> *   Improvements to working with preset pass managers. A new function [`generate_preset_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") enables easily generating a pass manager equivalent to what [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will use internally. Additionally, preset pass managers are now instances of [`StagedPassManager`](/api/qiskit/0.45/qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager") which makes it easier to modify sections.
> *   A refactor of the internal data structure of the [`QuantumCircuit.data`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") attribute. It previously was a list of tuples in the form `(instruction, qubits, clbits)` and now is a list of [`CircuitInstruction`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") objects. The [`CircuitInstruction`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") objects is backwards compatible with the previous tuple based access, however with runtime overhead cost.

Additionally, the transpiler has been improved to enable better quality outputs. This includes the introduction of new passes such as [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") and `ToqmSwap`.

<span id="id114" />

#### New Features

*   Added a new class, [`qiskit.transpiler.StagedPassManager`](/api/qiskit/0.45/qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager"), which is a [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") subclass that has a pipeline with defined phases to perform circuit compilation. Each phase is a [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object that will get executed in a fixed order. For example:

    ```python
    from qiskit.transpiler.passes import *
    from qiskit.transpiler import PassManager, StagedPassManager

    basis_gates = ['rx', 'ry', 'rxx']
    init = PassManager([UnitarySynthesis(basis_gates, min_qubits=3), Unroll3qOrMore()])
    translate = PassManager([Collect2qBlocks(),
                             ConsolidateBlocks(basis_gates=basis_gates),
                             UnitarySynthesis(basis_gates)])

    staged_pm = StagedPassManager(stages=['init', 'translation'], init=init, translation=translate)
    ```

*   Added the methods [`PauliList.group_commuting()`](/api/qiskit/0.45/qiskit.quantum_info.PauliList#group_commuting "qiskit.quantum_info.PauliList.group_commuting") and [`SparsePauliOp.group_commuting()`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp#group_commuting "qiskit.quantum_info.SparsePauliOp.group_commuting"), which partition these operators into sublists where each element commutes with all the others. For example:

    ```python
    from qiskit.quantum_info import PauliList, SparsePauliOp

    groups = PauliList(["XX", "YY", "IZ", "ZZ"]).group_commuting()
    # 'groups' is [PauliList(['IZ', 'ZZ']), PauliList(['XX', 'YY'])]

    op = SparsePauliOp.from_list([("XX", 2), ("YY", 1), ("IZ", 2j), ("ZZ", 1j)])
    groups = op.group_commuting()
    # 'groups' is [
    #     SparsePauliOp(['IZ', 'ZZ'], coeffs=[0.+2.j, 0.+1.j]),
    #     SparsePauliOp(['XX', 'YY'], coeffs=[2.+0.j, 1.+0.j]),
    # ]
    ```

*   Added a new function, [`marginal_distribution()`](/api/qiskit/0.45/result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution"), which is used to marginalize an input dictionary of bitstrings to an integer (such as [`Counts`](/api/qiskit/0.45/qiskit.result.Counts "qiskit.result.Counts")). This is similar in functionality to the existing [`marginal_counts()`](/api/qiskit/0.45/result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") function with three key differences. The first is that [`marginal_counts()`](/api/qiskit/0.45/result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") works with either a counts dictionary or a `Results` object while [`marginal_distribution()`](/api/qiskit/0.45/result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") only works with a dictionary. The second is that [`marginal_counts()`](/api/qiskit/0.45/result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") does not respect the order of indices in its `indices` argument while [`marginal_distribution()`](/api/qiskit/0.45/result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") does and will permute the output bits based on the `indices` order. The third difference is that [`marginal_distribution()`](/api/qiskit/0.45/result#qiskit.result.marginal_distribution "qiskit.result.marginal_distribution") should be faster as its implementation is written in Rust and streamlined for just marginalizing a dictionary input.

*   Added the `@` (`__matmul__`) binary operator to `BaseOperator` subclasses in the [`qiskit.quantum_info`](/api/qiskit/0.45/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module. This is shorthand to call the classes’ `dot` method (`A @ B == A.dot(B)`).

*   Added a new optional argument, `reps`, to [`QuantumCircuit.decompose()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#decompose "qiskit.circuit.QuantumCircuit.decompose"), which allows repeated decomposition of the circuit. For example:

    ```python
    from qiskit import QuantumCircuit

    circuit = QuantumCircuit(1)
    circuit.ry(0.5, 0)

    # Equivalent to circuit.decompose().decompose()
    circuit.decompose(reps=2)

    # decompose 2 times, but only RY gate 2 times and R gate 1 times
    circuit.decompose(gates_to_decompose=['ry','r'], reps=2)
    ```

*   Added a new pulse base class [`SymbolicPulse`](/api/qiskit/0.45/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse"). This is a replacement of the conventional [`ParametricPulse`](/api/qiskit/0.45/qiskit.pulse.library.ParametricPulse "qiskit.pulse.library.ParametricPulse"), which will be deprecated. In the new base class, pulse-envelope and parameter-validation functions are represented by symbolic-expression objects. The new class provides self-contained and portable pulse data since these symbolic equations can be easily serialized through symbolic computation libraries.

*   Added support for non-Hermitian operators in [`AerPauliExpectation`](/api/qiskit/0.45/qiskit.opflow.expectations.AerPauliExpectation "qiskit.opflow.expectations.AerPauliExpectation"). This allows the use of Aer’s fast snapshot expectation computations in algorithms such as `QEOM`.

*   Added a new circuit drawing style, `textbook`, which uses the color scheme of the Qiskit Textbook.

*   A new attribute [`QuantumCircuit.op_start_times`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#op_start_times "qiskit.circuit.QuantumCircuit.op_start_times") is populated when one of scheduling analysis passes is run on the circuit. It can be used to obtain circuit instruction with instruction time, for example:

    ```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.fake_provider import FakeMontreal

    backend = FakeMontreal()

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)

    qct = transpile(
        qc, backend, initial_layout=[0, 1], coupling_map=[[0, 1]], scheduling_method="alap"
    )
    scheduled_insts = list(zip(qct.op_start_times, qct.data))
    ```

*   Added a new method [`QuantumCircuit.clear()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#clear "qiskit.circuit.QuantumCircuit.clear") which is used to remove all instructions from a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   Added a new method [`QuantumCircuit.copy_empty_like()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#copy_empty_like "qiskit.circuit.QuantumCircuit.copy_empty_like") which is used to get a cleared copy of a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instance. This is logically equivalent to `qc.copy().clear()`, but significantly faster and more memory-efficient. This is useful when one needs a new empty circuit with all the same resources (qubits, classical bits, metadata, and so on) already added.

*   The [`Target.instruction_supported()`](/api/qiskit/0.45/qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported") method now supports two new keyword arguments, `operation_class` and `parameters`. Using these arguments the [`instruction_supported()`](/api/qiskit/0.45/qiskit.transpiler.Target#instruction_supported "qiskit.transpiler.Target.instruction_supported") method can now be used for checking that a specific operation with parameter values are supported by a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") object. For example, if you want to check if a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") named `target` supports running a [`RXGate`](/api/qiskit/0.45/qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate") with $\theta = \frac{\pi}{2}$ you would do something like:

    ```python
    from math import pi
    from qiskit.circuit.library import RXGate

    target.instruction_supported(operation_class=RXGate, parameters=[pi/2])
    ```

    which will return `True` if `target` supports running [`RXGate`](/api/qiskit/0.45/qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate") with $\theta = \frac{\pi}{2}$ and `False` if it does not.

*   Added a Trotterization-based quantum real-time evolution algorithm [`qiskit.algorithms.TrotterQRTE`](/api/qiskit/0.45/qiskit.algorithms.TrotterQRTE "qiskit.algorithms.TrotterQRTE"). It is compliant with the new quantum time evolution framework and makes use of the [`ProductFormula`](/api/qiskit/0.45/qiskit.synthesis.ProductFormula "qiskit.synthesis.ProductFormula") and [`PauliEvolutionGate`](/api/qiskit/0.45/qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") implementations.

    ```python
    from qiskit.algorithms import EvolutionProblem
    from qiskit.algorithms.evolvers.trotterization import TrotterQRTE
    from qiskit.opflow import X, Z, StateFn, SummedOp

    operator = SummedOp([X, Z])
    initial_state = StateFn([1, 0])
    time = 1
    evolution_problem = EvolutionProblem(operator, time, initial_state)

    trotter_qrte = TrotterQRTE()
    evolution_result = trotter_qrte.evolve(evolution_problem)
    evolved_state_circuit = evolution_result.evolved_state
    ```

*   Added a new function [`generate_preset_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") which can be used to quickly generate a preset [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") object that mirrors the [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") used internally by the [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function. For example:

    ```python
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit.providers.fake_provider import FakeWashingtonV2

    # Generate an optimization level 3 pass manager targeting FakeWashingtonV2
    pass_manager = generate_preset_pass_manager(3, FakeWashingtonV2())
    ```

*   Added a new function [`marginal_memory()`](/api/qiskit/0.45/result#qiskit.result.marginal_memory "qiskit.result.marginal_memory") which is used to marginalize shot memory arrays. Provided with the shot memory array and the indices of interest, the function will return a maginized shot memory array. This function differs from the memory support in the [`marginal_counts()`](/api/qiskit/0.45/result#qiskit.result.marginal_counts "qiskit.result.marginal_counts") method which only works on the `memory` field in a `Results` object.

*   The primitives interface has been extended to accept objects in addition to indices as arguments to the `__call__` method. The `parameter_values` argument can now be optional.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](/api/qiskit/0.45/qasm3#module-qiskit.qasm3 "qiskit.qasm3")) now supports exporting circuits with explicit delays, such as from [`QuantumCircuit.delay()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#delay "qiskit.circuit.QuantumCircuit.delay").

*   Added a new layout and routing method to [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") based on the paper [“Time-optimal qubit mapping”](https://dl.acm.org/doi/10.1145/3445814.3446706). To use it, the optional package [Qiskit TOQM](https://github.com/qiskit-toqm/qiskit-toqm) must be installed. The `routing_method` kwarg of [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") supports an additional value, `'toqm'` which is used to enable layout and routing via TOQM.

    To install `qiskit-toqm` along with Terra, run:

    ```python
    pip install qiskit-terra[toqm]
    ```

*   Added a new module `qiskit.quantum_info.synthesis.qsd` to apply Quantum Shannon Decomposition of arbitrary unitaries. This functionality replaces the previous isometry-based approach in the default unitary synthesis transpiler pass as well as when adding unitaries to a circuit using a [`UnitaryGate`](/api/qiskit/0.45/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate").

    The Quantum Shannon Decomposition uses about half the cnot gates as the isometry implementation when decomposing unitary matrices of greater than two qubits.

*   Classes in the [`quantum_info`](/api/qiskit/0.45/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module that support scalar multiplication can now be multiplied by a scalar from either the left or the right. Previously, they would only accept scalar multipliers from the left.

*   The transpiler pass [`LookaheadSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.LookaheadSwap "qiskit.transpiler.passes.LookaheadSwap") (used by [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") when `routing_method="lookahead"`) has seen some performance improvements and will now be approximately three times as fast. This is purely being more efficient in its calculations, and does not change the complexity of the algorithm. In most cases, a more modern routing algorithm like [`SabreSwap`](/api/qiskit/0.45/qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") (`routing_method="sabre"`) will be vastly more performant.

*   New transpiler passes have been added. The transpiler pass [`Commuting2qGateRouter`](/api/qiskit/0.45/qiskit.transpiler.passes.Commuting2qGateRouter "qiskit.transpiler.passes.Commuting2qGateRouter") uses swap strategies to route a block of commuting gates to the coupling map. Indeed, routing is a hard problem but is significantly easier when the gates commute as in CZ networks. Blocks of commuting gates are also typically found in QAOA. Such cases can be dealt with using swap strategies that apply a predefined set of layers of SWAP gates. Furthermore, the new transpiler pass `FindCommutingPauliEvolutions` identifies blocks of Pauli evolutions made of commuting two-qubit terms. Here, a swap strategy is specified by the class `SwapStrategy`. Swap strategies need to be tailored to the coupling map and, ideally, the circuit for the best results.

*   Introduced a new optimizer to Qiskit library, which adds support to the optimization of parameters of variational quantum algorithms. This is the Univariate Marginal Distribution Algorithm (UMDA), which is a specific type of the Estimation of Distribution Algorithms. For example:

    ```python
    from qiskit.opflow import X, Z, I
    from qiskit import Aer
    from qiskit.algorithms.optimizers import UMDA
    from qiskit.algorithms import QAOA
    from qiskit.utils import QuantumInstance

    H2_op = (-1.052373245772859 * I ^ I) + \
            (0.39793742484318045 * I ^ Z) + \
            (-0.39793742484318045 * Z ^ I) + \
            (-0.01128010425623538 * Z ^ Z) + \
            (0.18093119978423156 * X ^ X)

    p = 2  # Toy example: 2 layers with 2 parameters in each layer: 4 variables

    opt = UMDA(maxiter=100, size_gen=20)
    backend = Aer.get_backend('statevector_simulator')
    vqe = QAOA(opt,
               quantum_instance=QuantumInstance(backend=backend),
               reps=p)

    result = vqe.compute_minimum_eigenvalue(operator=H2_op)
    ```

*   The constructor for the [`Unroll3qOrMore`](/api/qiskit/0.45/qiskit.transpiler.passes.Unroll3qOrMore "qiskit.transpiler.passes.Unroll3qOrMore") transpiler pass has two new optional keyword arguments, `target` and `basis_gates`. These options enable you to specify the [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") or supported basis gates respectively to describe the target backend. If any of the operations in the circuit are in the `target` or `basis_gates` those will not be unrolled by the pass as the target device has native support for the operation.

*   QPY serialization has been upgraded to support [`ScheduleBlock`](/api/qiskit/0.45/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock"). Now you can save pulse program in binary and load it at later time:

    ```python
    from qiskit import pulse, qpy

    with pulse.build() as schedule:
        pulse.play(pulse.Gaussian(160, 0.1, 40), pulse.DriveChannel(0))

    with open('schedule.qpy', 'wb') as fd:
        qpy.dump(schedule, fd)

    with open('schedule.qpy', 'rb') as fd:
        new_schedule = qpy.load(fd)[0]
    ```

    This uses the QPY interface common to [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). See [SCHEDULE\_BLOCK](/api/qiskit/0.45/qpy#qpy-schedule-block) for details of data structure.

*   Added a new transpiler pass, [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout"). This pass is of a new type to perform a new phase/function in the compilation pipeline, post-layout or post optimization qubit selection. The idea behind this pass is after we finish the optimization loop in transpiler we know what the final gate counts will be on each qubit in the circuit so we can potentially find a better-performing subset of qubits on a backend to execute the circuit. The pass will search for an isomorphic subgraph in the connectivity graph of the target backend and look at the full error rate of the complete circuit on any subgraph found and return the layout found with the lowest error rate for the circuit.

    This pass is similar to the [`VF2Layout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") pass and both internally use the same VF2 implementation from [retworkx](https://github.com/Qiskit/retworkx). However, [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") is deisgned to run after initial layout, routing, basis translation, and any optimization passes run and will only work if a layout has already been applied, the circuit has been routed, and all gates are in the target basis. This is required so that when a new layout is applied the circuit can still be run on the target device. [`VF2Layout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") on the other hand is designed to find a perfect initial layout and can work with any circuit.

*   The [`ApplyLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.ApplyLayout "qiskit.transpiler.passes.ApplyLayout") transpiler pass now has support for updating a layout on a circuit after a layout has been applied once before. If the `post_layout` field is present (in addition to the required `layout` field) the `property_set` when the [`ApplyLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.ApplyLayout "qiskit.transpiler.passes.ApplyLayout") pass is run the pass will update the layout to apply the new layout. This will return a [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") with the qubits in the new physical order and the `layout` property set will be updated so that it maps the virtual qubits from the original layout to the physical qubits in the new `post_layout` field.

*   The preset pass managers generated by [`level_1_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") which correspond to `optimization_level` 1, 2, and 3 respectively on the [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function now run the [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass after running the routing pass. This enables the transpiler to potentially find a different set of physical qubits on the target backend to run the circuit on which have lower error rates. The [`VF2PostLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") pass will not be run if you manually specify a `layout_method`, `routing_method`, or `initial_layout` arguments to [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). If the pass can find a better performing subset of qubits on backend to run the physical circuit it will adjust the layout of the circuit to use the alternative qubits instead.

*   The algorithm iteratively computes each eigenstate by starting from the ground state (which is computed as in VQE) and then optimising a modified cost function that tries to compute eigen states that are orthogonal to the states computed in the previous iterations and have the lowest energy when computed over the ansatz. The interface implemented is very similar to that of VQE and is of the form:

    ```python
    from qiskit.algorithms import VQD
    from qiskit.utils import QuantumInstance
    from qiskit.circuit.library import TwoLocal
    from qiskit.algorithms.optimizers import COBYLA
    from qiskit import BasicAer
    from qiskit.opflow import I,Z,X

    h2_op = (
        -1.052373245772859 * (I ^ I)
        + 0.39793742484318045 * (I ^ Z)
        - 0.39793742484318045 * (Z ^ I)
        - 0.01128010425623538 * (Z ^ Z)
        + 0.18093119978423156 * (X ^ X)
    )

    vqd = VQD(k =2, ansatz = TwoLocal(rotation_blocks="ry", entanglement_blocks="cz"),optimizer = COBYLA(maxiter = 0), quantum_instance = QuantumInstance(
                BasicAer.get_backend("qasm_simulator"), shots = 2048)
            )
    vqd_res = vqd.compute_eigenvalues(op)
    ```

    This particular code snippet generates 2 eigenvalues (ground and 1st excited state) Tests have also been implemented.

<span id="release-notes-0-21-0-upgrade-notes" />

<span id="id115" />

#### Upgrade Notes

*   The pulse classes in [`qiskit.pulse.library`](/api/qiskit/0.45/pulse#module-qiskit.pulse.library "qiskit.pulse.library") are now subclasses of [`SymbolicPulse`](/api/qiskit/0.45/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") rather than [`ParametricPulse`](/api/qiskit/0.45/qiskit.pulse.library.ParametricPulse "qiskit.pulse.library.ParametricPulse"). The available classes remain unchanged as [`Gaussian`](/api/qiskit/0.45/qiskit.pulse.library.Gaussian_class.rst#qiskit.pulse.library.Gaussian "qiskit.pulse.library.Gaussian"), [`GaussianSquare`](/api/qiskit/0.45/qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare"), [`Drag`](/api/qiskit/0.45/qiskit.pulse.library.Drag_class.rst#qiskit.pulse.library.Drag "qiskit.pulse.library.Drag"), and [`Constant`](/api/qiskit/0.45/qiskit.pulse.library.Constant_class.rst#qiskit.pulse.library.Constant "qiskit.pulse.library.Constant"). [`SymbolicPulse`](/api/qiskit/0.45/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") has full backward compatibility, and there should be no loss of functionality.

*   The data type of each element in [`QuantumCircuit.data`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") has changed. It used to be a simple 3-tuple of an [`Instruction`](/api/qiskit/0.45/qiskit.circuit.Instruction "qiskit.circuit.Instruction"), a list of [`Qubit`](/api/qiskit/0.45/qiskit.circuit.Qubit "qiskit.circuit.Qubit")s, and a list of [`Clbit`](/api/qiskit/0.45/qiskit.circuit.Clbit "qiskit.circuit.Clbit")s, whereas it is now an instance of [`CircuitInstruction`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction").

    The attributes of this new class are [`operation`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#operation "qiskit.circuit.CircuitInstruction.operation"), [`qubits`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#qubits "qiskit.circuit.CircuitInstruction.qubits") and [`clbits`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#clbits "qiskit.circuit.CircuitInstruction.clbits"), corresponding to the elements of the previous tuple. However, [`qubits`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#qubits "qiskit.circuit.CircuitInstruction.qubits") and [`clbits`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#clbits "qiskit.circuit.CircuitInstruction.clbits") are now `tuple` instances, not `list`s.

    This new class will behave exactly like the old 3-tuple if one attempts to access its index its elements, or iterate through it. This includes casting the [`qubits`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#qubits "qiskit.circuit.CircuitInstruction.qubits") and [`clbits`](/api/qiskit/0.45/qiskit.circuit.CircuitInstruction#clbits "qiskit.circuit.CircuitInstruction.clbits") elements to lists. This is to assist backwards compatibility. Starting from Qiskit Terra 0.21, this is no longer the preferred way to access these elements. Instead, you should use the attribute-access form described above.

    This has been done to allow further developments of the [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") data structure in Terra, without constantly breaking backwards compatibility. Planned developments include dynamic parameterized circuits, and an overall reduction in memory usage of deep circuits.

*   The `python-constraint` dependency, which is used solely by the [`CSPLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") transpiler pass, is no longer in the requirements list for the Qiskit Terra package. This is because the [`CSPLayout`](/api/qiskit/0.45/qiskit.transpiler.passes.CSPLayout "qiskit.transpiler.passes.CSPLayout") pass is no longer used by default in any of the preset pass managers for [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). While the pass is still available, if you’re using it you will need to manually install `python-contraint` or when you install `qiskit-terra` you can use the `csp-layout` extra, for example:

    ```python
    pip install "qiskit-terra[csp-layout]"
    ```

*   The QPY version format version emitted by [`qpy.dump()`](/api/qiskit/0.45/qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been increased to version 5. This new format version is incompatible with the previous versions and will result in an error when trying to load it with a deserializer that isn’t able to handle QPY version 5. This change was necessary to fix support for representing controlled gates properly and representing non-default control states.

*   Qiskit Terra’s compiled Rust extensions now have a minimum supported Rust version (MSRV) of 1.56.1. This means when building Qiskit Terra from source the oldest version of the Rust compiler supported is 1.56.1. If you are using an older version of the Rust compiler you will need to update to a newer version to continue to build Qiskit from source. This change was necessary as a number of upstream dependencies have updated their minimum supported versions too.

*   Circuit scheduling now executes in parallel when more than one circuit is provided to [`schedule()`](/api/qiskit/0.45/compiler#qiskit.compiler.schedule "qiskit.compiler.schedule"). Refer to [#2695](https://github.com/Qiskit/qiskit-terra/issues/2695) for more details.

*   The previously deprecated `BaseBackend`, `BaseJob`, and `BaseProvider` classes have all been removed. They were originally deprecated in the 0.18.0 release. Instead of these classes you should be using the versioned providers interface classes, the latest being [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2"), [`JobV1`](/api/qiskit/0.45/qiskit.providers.JobV1 "qiskit.providers.JobV1"), and [`ProviderV1`](/api/qiskit/0.45/qiskit.providers.ProviderV1 "qiskit.providers.ProviderV1").

*   The previously deprecated `backend` argument for the constructor of the [`RZXCalibrationBuilder`](/api/qiskit/0.45/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") transpiler pass has been removed. It was originally deprecated in the 0.19.0 release. Instead you should query the [`Backend`](/api/qiskit/0.45/qiskit.providers.Backend "qiskit.providers.Backend") object for the `instruction_schedule_map` and `qubit_channel_mapping` and pass that directly to the constructor. For example, with a [`BackendV1`](/api/qiskit/0.45/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") backend:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.providers.fake_provider import FakeMumbai

    backend = FakeMumbai()
    inst_map = backend.defaults().instruction_schedule_map
    channel_map = backend.configuration().qubit_channel_mapping
    cal_pass = RZXCalibrationBuilder(
        instruction_schedule_map=inst_map,
        qubit_channel_mapping=channel_map,
    )
    ```

    or with a [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend:

    ```python
    from qiskit.transpiler.passes import RZXCalibrationBuilder
    from qiskit.providers.fake_provider import FakeMumbaiV2

    backend = FakeMumbaiV2()
    inst_map = backend.instruction_schedule_map
    channel_map = {bit: backend.drive_channel(bit) for bit in range(backend.num_qubits)}
    cal_pass = RZXCalibrationBuilder(
        instruction_schedule_map=inst_map,
        qubit_channel_mapping=channel_map,
    )
    ```

*   The measurement shot limit for the `BasicAer` backend has been removed.

*   For the `DAGNode`, the previously deprecated `type`, `op`, `qargs`, `cargs`, and `wire` kwargs and attributes have been removed. These were originally deprecated in the 0.19.0 release. The `op`, `qargs`, and `cargs` kwargs and attributes can be accessed only on instances of `DAGOpNode`, and the `wire` kwarg and attribute are only on instances of `DAGInNode` or `DAGOutNode`.

*   The deprecated function `pauli_group()` has been removed. It was originally deprecated in Qiskit Terra 0.17.

*   Several deprecated methods on [`Pauli`](/api/qiskit/0.45/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") have been removed, which were originally deprecated in Qiskit Terra 0.17. These were:

    ## `sgn_prod`

    Use [`Pauli.compose()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#compose "qiskit.quantum_info.Pauli.compose") or [`Pauli.dot()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#dot "qiskit.quantum_info.Pauli.dot") instead.

    ## `to_spmatrix`

    Use [`Pauli.to_matrix()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#to_matrix "qiskit.quantum_info.Pauli.to_matrix") with argument `sparse=True` instead.

    ## `kron`

    Use [`Pauli.expand()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#expand "qiskit.quantum_info.Pauli.expand"), but beware that this returns a new object, rather than mutating the existing one.

    ## `update_z` and `update_x`

    Set the `z` and `x` attributes of the object directly.

    ## `insert_paulis`

    Use [`Pauli.insert()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#insert "qiskit.quantum_info.Pauli.insert").

    ## `append_paulis`

    Use [`Pauli.expand()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#expand "qiskit.quantum_info.Pauli.expand").

    ## `delete_qubits`

    Use [`Pauli.delete()`](/api/qiskit/0.45/qiskit.quantum_info.Pauli#delete "qiskit.quantum_info.Pauli.delete").

    ## `pauli_single`

    Construct the label manually and pass directly to the initializer, such as:

    ```python
    Pauli("I" * index + pauli_label + "I" * (num_qubits - index - len(pauli_label)))
    ```

    ## `random`

    Use [`quantum_info.random_pauli()`](/api/qiskit/0.45/quantum_info#qiskit.quantum_info.random_pauli "qiskit.quantum_info.random_pauli") instead.

*   Removed the `optimize` method from the [`Optimizer`](/api/qiskit/0.45/qiskit.algorithms.optimizers.Optimizer "qiskit.algorithms.optimizers.Optimizer") classes, which is superseded by the [`minimize()`](/api/qiskit/0.45/qiskit.algorithms.optimizers.Optimizer#minimize "qiskit.algorithms.optimizers.Optimizer.minimize") method as direct replacement. The one exception is [`SPSA`](/api/qiskit/0.45/qiskit.algorithms.optimizers.SPSA "qiskit.algorithms.optimizers.SPSA"), where the deprecation warning was not triggered so the method there is still kept.

*   [`Result`](/api/qiskit/0.45/qiskit.result.Result "qiskit.result.Result") was modified so that it always contains `date`, `status`, and `header` attributes (set to `None` if not specified).

*   For Python 3.7 [shared-memory38](https://pypi.org/project/shared-memory38/) is now a dependency. This was added as a dependency for Python 3.7 to enable leveraging the shared memory constructs in the standard library of newer versions of Python. If you’re running on Python >= 3.8 there is no extra dependency required.

*   [`Instruction`](/api/qiskit/0.45/qiskit.circuit.Instruction "qiskit.circuit.Instruction") labels are now type-checked on instruction creation.

*   QPY serialization has been upgraded to serialize [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with [`QuantumCircuit.calibrations`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#calibrations "qiskit.circuit.QuantumCircuit.calibrations"). As of QPY Version 5, only calibration entries of [`ScheduleBlock`](/api/qiskit/0.45/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") type can be serialized.

*   The definition of [`XXPlusYYGate`](/api/qiskit/0.45/qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate") has been changed. See [#7969](https://github.com/Qiskit/qiskit-terra/pull/7949) for details.

*   The preset pass managers generated by [`level_1_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_1_pass_manager "qiskit.transpiler.preset_passmanagers.level_1_pass_manager"), [`level_2_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager"), and [`level_3_pass_manager()`](/api/qiskit/0.45/transpiler_preset#qiskit.transpiler.preset_passmanagers.level_3_pass_manager "qiskit.transpiler.preset_passmanagers.level_3_pass_manager") and used by the [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function’s `optimization_level` argument at 1, 2, and 3 respectively no longer set a hard time limit on the [`VF2Layout`](/api/qiskit/0.45/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") transpiler pass. This means that the pass will no longer stop trying to find a better alternative perfect layout up until a fixed time limit (100ms for level 1, 10 sec for level 2, and 60 sec for level 3) as doing this limited the reproducibility of compilation when a perfect layout was available. This means that the output when using the pass might be different than before, although in all cases it would only change if a lower noise set of qubits can be found over the previous output. If you wish to retain the previous behavior you can create a custom [`PassManager`](/api/qiskit/0.45/qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") that sets the `time_limit` argument on the constructor for the `VF2Layout` pass.

<span id="release-notes-0-21-0-deprecation-notes" />

<span id="id116" />

#### Deprecation Notes

*   Calling [`timeline_drawer()`](/api/qiskit/0.45/qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") with an unscheduled circuit has been deprecated. All circuits, even one consisting only of delay instructions, must be transpiled with the `scheduling_method` keyword argument of [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") set, to generate schedule information being stored in [`QuantumCircuit.op_start_times`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#op_start_times "qiskit.circuit.QuantumCircuit.op_start_times").

*   The [NetworkX](https://networkx.org/) converter functions for the `DAGCircuit.to_networkx()` and `from_networkx()`, along with the `DAGDependency.to_networkx()` method have been deprecated and will be removed in a future release. Qiskit has been using [retworkx](https://qiskit.org/documentation/retworkx/) as its graph library since the qiskit-terra 0.12.0 release, and since then the networkx converter functions have been lossy. They were originally added so that users could leverage functionality in NetworkX’s algorithms library not present in retworkx. Since that time, retworkx has matured and offers more functionality, and the [`DAGCircuit`](/api/qiskit/0.45/qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is tightly coupled to retworkx for its operation. Having these converter methods provides limited value moving forward and are therefore going to be removed in a future release.

*   Accessing several old toggles (`HAS_MATPLOTLIB`, `HAS_PDFTOCAIRO`, `HAS_PYLATEX` and `HAS_PIL`) from the [`qiskit.visualization`](/api/qiskit/0.45/visualization#module-qiskit.visualization "qiskit.visualization") module is now deprecated, and these import paths will be removed in a future version of Qiskit Terra. The same objects should instead be accessed through [`qiskit.utils.optionals`](/api/qiskit/0.45/utils#module-qiskit.utils.optionals "qiskit.utils.optionals"), which contains testers for almost all of Terra’s optional dependencies.

*   The `qiskit.test.mock` module is now deprecated. The fake backend and fake provider classes which were previously available in `qiskit.test.mock` have been accessible in [`qiskit.providers.fake_provider`](/api/qiskit/0.45/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") since Terra 0.20.0. This change represents a proper commitment to support the fake backend classes as part of Qiskit, whereas previously they were just part of the internal testing suite, and were exposed to users as a side effect.

*   The arguments’ names when calling an [`Estimator`](/api/qiskit/0.45/qiskit.primitives.Estimator "qiskit.primitives.Estimator") or [`Sampler`](/api/qiskit/0.45/qiskit.primitives.Sampler "qiskit.primitives.Sampler") object as a function are renamed from `circuit_indices` and `observable_indices` to `circuits` and `observables`.

*   The `qobj_id` and `qobj_header` keyword arguments for the [`execute()`](/api/qiskit/0.45/execute#qiskit.execute_function.execute "qiskit.execute_function.execute") function have been deprecated and will be removed in a future release. Since the removal of the `BaseBackend` class these arguments don’t have any effect as no backend supports execution with a `Qobj` object directly and instead only work with [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects directly.

*   The arguments `x`, `z` and `label` to the initializer of [`Pauli`](/api/qiskit/0.45/qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") were documented as deprecated in Qiskit Terra 0.17, but a bug prevented the expected warning from being shown at runtime. The warning will now correctly show, and the arguments will be removed in Qiskit Terra 0.23 or later. A pair of `x` and `z` should be passed positionally as a single tuple (`Pauli((z, x))`). A string `label` should be passed positionally in the first argument (`Pauli("XYZ")`).

*   The [`SPSA.optimize()`](/api/qiskit/0.45/qiskit.algorithms.optimizers.SPSA#optimize "qiskit.algorithms.optimizers.SPSA.optimize") method is deprecated in favor of [`SPSA.minimize()`](/api/qiskit/0.45/qiskit.algorithms.optimizers.SPSA#minimize "qiskit.algorithms.optimizers.SPSA.minimize"), which can be used as direct replacement. Note that this method returns a complete result object with more information than before available.

*   The `circuits` argument of [`qpy.dump()`](/api/qiskit/0.45/qpy#qiskit.qpy.dump "qiskit.qpy.dump") has been deprecated and replaced with `programs` since now QPY supports multiple data types other than circuits.

*   `AlignmentKind.to_dict()` method has been deprecated and will be removed.

<span id="release-notes-0-21-0-bug-fixes" />

<span id="id117" />

#### Bug Fixes

*   Extra validation was added to [`DiagonalGate`](/api/qiskit/0.45/qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate") to check the argument has modulus one.

*   Duplicate qubit indices given to [`SparsePauliOp.from_sparse_list()`](/api/qiskit/0.45/qiskit.quantum_info.SparsePauliOp#from_sparse_list "qiskit.quantum_info.SparsePauliOp.from_sparse_list") will now correctly raise an error, instead of silently overwriting previous values. The old behavior can be accessed by passing the new keyword argument `do_checks=False`.

*   The [`timeline_drawer()`](/api/qiskit/0.45/qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") visualization will no longer misalign classical register slots.

*   Parameter validation for [`GaussianSquare`](/api/qiskit/0.45/qiskit.pulse.library.GaussianSquare "qiskit.pulse.library.GaussianSquare") is now consistent before and after construction. Refer to [#7882](https://github.com/Qiskit/qiskit-terra/issues/7882) for more details.

*   The [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based fake backends in the [`qiskit.providers.fake_provider`](/api/qiskit/0.45/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module, such as [`FakeMontrealV2`](/api/qiskit/0.45/qiskit.providers.fake_provider.FakeMontrealV2 "qiskit.providers.fake_provider.FakeMontrealV2"), now support the [`Delay`](/api/qiskit/0.45/qiskit.circuit.Delay "qiskit.circuit.Delay") operation in their [`target`](/api/qiskit/0.45/qiskit.providers.BackendV2#target "qiskit.providers.BackendV2.target") attributes. Previously, [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects that contained delays could not be compiled to these backends.

*   Fixed a bug in `TridiagonalToeplitz.eigs_bounds()`, which caused incorrect eigenvalue bounds to be returned in some cases with negative eigenvalues. Refer to [#7939](https://github.com/Qiskit/qiskit-terra/issues/7939) for more details.

*   Fixed a bug in which the LaTeX statevector drawer ignored the `max_size` parameter.

*   Fixed support in the [`PassManagerConfig.from_backend()`](/api/qiskit/0.45/qiskit.transpiler.PassManagerConfig#from_backend "qiskit.transpiler.PassManagerConfig.from_backend") constructor method for building a [`PassManagerConfig`](/api/qiskit/0.45/qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") object from a [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance. Previously this wasn’t handled correctly and would fail when running with a [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") object.

*   Fixed support for QPY serialization ([`qpy.dump()`](/api/qiskit/0.45/qpy#qiskit.qpy.dump "qiskit.qpy.dump")) and deserialization ([`qpy.load()`](/api/qiskit/0.45/qpy#qiskit.qpy.load "qiskit.qpy.load")) of a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object containing custom [`ControlledGate`](/api/qiskit/0.45/qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate") objects. Previously, an exception would be raised by [`qpy.load()`](/api/qiskit/0.45/qpy#qiskit.qpy.load "qiskit.qpy.load") when trying to reconstruct the custom [`ControlledGate`](/api/qiskit/0.45/qiskit.circuit.ControlledGate "qiskit.circuit.ControlledGate"). Fixed [#7999](https://github.com/Qiskit/qiskit-terra/issues/7999).

*   Fixed support for QPY serialization ([`qpy.dump()`](/api/qiskit/0.45/qpy#qiskit.qpy.dump "qiskit.qpy.dump")) and deserialization ([`qpy.load()`](/api/qiskit/0.45/qpy#qiskit.qpy.load "qiskit.qpy.load")) of a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object containing custom [`MCPhaseGate`](/api/qiskit/0.45/qiskit.circuit.library.MCPhaseGate "qiskit.circuit.library.MCPhaseGate") objects. Previously, an exception would be raised by [`qpy.load()`](/api/qiskit/0.45/qpy#qiskit.qpy.load "qiskit.qpy.load") when trying to reconstruct the [`MCPhaseGate`](/api/qiskit/0.45/qiskit.circuit.library.MCPhaseGate "qiskit.circuit.library.MCPhaseGate").

*   Fixed support for QPY serialization ([`qpy.dump()`](/api/qiskit/0.45/qpy#qiskit.qpy.dump "qiskit.qpy.dump")) and deserialization ([`qpy.load()`](/api/qiskit/0.45/qpy#qiskit.qpy.load "qiskit.qpy.load")) of a [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object containing controlled gates with an open control state. Previously, the open control state would be lost by the serialization process and the reconstructed circuit.

*   Fixed [`QuantumCircuit.reverse_bits()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#reverse_bits "qiskit.circuit.QuantumCircuit.reverse_bits") with circuits containing registerless [`Qubit`](/api/qiskit/0.45/qiskit.circuit.Qubit "qiskit.circuit.Qubit") and [`Clbit`](/api/qiskit/0.45/qiskit.circuit.Clbit "qiskit.circuit.Clbit"). For example, the following will now work:

    ```python
    from qiskit.circuit import QuantumCircuit, Qubit, Clbit

    qc = QuantumCircuit([Qubit(), Clbit()])
    qc.h(0).c_if(qc.clbits[0], 0)
    qc.reverse_bits()
    ```

*   Fixed the `ConfigurableFakeBackend.t2` attribute, which was previously incorrectly set based on the provided `t1` value.

*   Fixed an issue with [`BackendV2`](/api/qiskit/0.45/qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based fake backend classes from the [`qiskit.providers.fake_provider`](/api/qiskit/0.45/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module such as [`FakeMontrealV2`](/api/qiskit/0.45/qiskit.providers.fake_provider.FakeMontrealV2 "qiskit.providers.fake_provider.FakeMontrealV2") where the value for the [`dt`](/api/qiskit/0.45/qiskit.providers.BackendV2#dt "qiskit.providers.BackendV2.dt") attribute (and the [`Target.dt`](/api/qiskit/0.45/qiskit.transpiler.Target#dt "qiskit.transpiler.Target.dt") attribute) were not properly being converted to seconds. This would cause issues when using these fake backends with scheduling.

*   Fixed a bug in [`plot_histogram()`](/api/qiskit/0.45/qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") when the `number_to_keep` argument was smaller that the number of keys. The following code will no longer throw errors and will be properly aligned:

    ```python
    from qiskit.visualization import plot_histogram
    data = {'00': 3, '01': 5, '11': 8, '10': 11}
    plot_histogram(data, number_to_keep=2)
    ```

*   Improved the performance of building and working with parameterized [`QuantumCircuit`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instances with many gates that share a relatively small number of parameters.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](/api/qiskit/0.45/qasm3#module-qiskit.qasm3 "qiskit.qasm3")) will no longer attempt to produce definitions for non-standard gates in the `basis_gates` option.

*   Fixed the getter of [`OptimizerResult.nit`](/api/qiskit/0.45/qiskit.algorithms.optimizers.OptimizerResult#nit "qiskit.algorithms.optimizers.OptimizerResult.nit"), which previously returned the number of Jacobian evaluations instead of the number of iterations.

*   Fixed a bug in the string representation of [`Result`](/api/qiskit/0.45/qiskit.result.Result "qiskit.result.Result") objects that caused the attributes to be specified incorrectly.

*   Fixed an issue with [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") where in some cases providing a list of basis gate strings with the `basis_gates` keyword argument or implicitly via a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") input via the `target` keyword argument would not be interpreted correctly and result in a subset of the listed gates being used for each circuit.

*   Fixed an issue in the [`UnitarySynthesis`](/api/qiskit/0.45/qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass which would result in an error when a [`Target`](/api/qiskit/0.45/qiskit.transpiler.Target "qiskit.transpiler.Target") that didn’t have any qubit restrictions on the operations (e.g. in the case of an ideal simulator target) was specified with the `target` keyword argument for the constructor.

*   The method [`qiskit.result.marginal_counts()`](/api/qiskit/0.45/result#qiskit.result.marginal_counts "qiskit.result.marginal_counts"), when passed a [`Result`](/api/qiskit/0.45/qiskit.result.Result "qiskit.result.Result") from a pulse backend, would fail, because it contains an array of `ExperimentResult` objects, each of which have an `QobjExperimentHeader`, and those `ExperimentHeaders` lack creg\_sizes instance-variables. If the `Result` came from a simulator backend (e.g. Aer), that instance-variable would be there. We fix `marginal_counts` so that it skips logic that needs creg\_sizes if the field is not present, or non-None.

*   The OpenQASM 2 exporter ([`QuantumCircuit.qasm()`](/api/qiskit/0.45/qiskit.circuit.QuantumCircuit#qasm "qiskit.circuit.QuantumCircuit.qasm")) will now correctly define the qubit parameters for [`UnitaryGate`](/api/qiskit/0.45/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") operations that do not affect all the qubits they are defined over. Fixed [#8224](https://github.com/Qiskit/qiskit-terra/issues/8224).

*   Fixed an issue with reproducibility of the [`transpile()`](/api/qiskit/0.45/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when running with `optimization_level` 1, 2, and 3. Previously, under some conditions when there were multiple perfect layouts (a layout that doesn’t require any SWAP gates) available the selected layout and output circuit could vary regardless of whether the `seed_transpiler` argument was set.

<span id="id118" />

### Aer 0.10.4

No change

<span id="release-notes-0-19-2-ibmq" />

<span id="id119" />

### IBM Q Provider 0.19.2

<span id="release-notes-0-19-2-ibmq-bug-fixes" />

<span id="id120" />

#### Bug Fixes

*   In the upcoming terra release there will be a release candidate tagged prior to the final release. However changing the version string for the package is blocked on the qiskit-ibmq-provider right now because it is trying to parse the version and is assuming there will be no prelease suffix on the version string (see [#8200](https://github.com/Qiskit/qiskit-terra/pull/8200) for the details). PR [#1135](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1135) fixes this version parsing to use the regex from the pypa/packaging project which handles all the PEP440 package versioning include pre-release suffixes. This will enable terra to release an 0.21.0rc1 tag without breaking the qiskit-ibmq-provider.
*   `threading.currentThread` and `notifyAll` were deprecated in Python 3.10 (October 2021) and will be removed in Python 3.12 (October 2023). PR [#1133](https://github.com/Qiskit/qiskit-ibmq-provider/pull/1133) replaces them with `threading.current_thread`, `notify_all` added in Python 2.6 (October 2008).

<span id="qiskit-0-36-2" />