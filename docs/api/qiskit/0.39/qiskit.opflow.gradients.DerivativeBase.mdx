---
title: DerivativeBase
description: API reference for qiskit.opflow.gradients.DerivativeBase
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.opflow.gradients.DerivativeBase
---

# DerivativeBase

<Class id="qiskit.opflow.gradients.DerivativeBase" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.22/qiskit/opflow/gradients/derivative_base.py" signature="DerivativeBase" modifiers="class">
  Bases: [`qiskit.opflow.converters.converter_base.ConverterBase`](qiskit.opflow.converters.ConverterBase "qiskit.opflow.converters.converter_base.ConverterBase")

  Base class for differentiating opflow objects.

  Converter for differentiating opflow objects and handling things like properly differentiating combo\_fn’s and enforcing product rules when operator coefficients are parameterized.

  This is distinct from CircuitGradient converters which use quantum techniques such as parameter shifts and linear combination of unitaries to compute derivatives of circuits.

  CircuitGradient - uses quantum techniques to get derivatives of circuits DerivativeBase - uses classical techniques to differentiate opflow data structures

  ## Methods Defined Here

  ### convert

  <Function id="qiskit.opflow.gradients.DerivativeBase.convert" signature="DerivativeBase.convert(operator, params=None)" modifiers="abstract">
    **Parameters**

    *   **operator** ([`OperatorBase`](qiskit.opflow.OperatorBase "qiskit.opflow.operator_base.OperatorBase")) – The operator we are taking the gradient, Hessian or QFI of
    *   **params** (`Union`\[[`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.parametervector.ParameterVector"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), `List`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], `None`]) – The parameters we are taking the gradient, Hessian or QFI with respect to.

    **Return type**

    [`OperatorBase`](qiskit.opflow.OperatorBase "qiskit.opflow.operator_base.OperatorBase")

    **Returns**

    An operator whose evaluation yields the gradient, Hessian or QFI.

    **Raises**

    **ValueError** – If `params` contains a parameter not present in `operator`.
  </Function>

  ### gradient\_wrapper

  <Function id="qiskit.opflow.gradients.DerivativeBase.gradient_wrapper" signature="DerivativeBase.gradient_wrapper(operator, bind_params, grad_params=None, backend=None, expectation=None)">
    Get a callable function which provides the respective gradient, Hessian or QFI for given parameter values. This callable can be used as gradient function for optimizers.

    **Parameters**

    *   **operator** ([`OperatorBase`](qiskit.opflow.OperatorBase "qiskit.opflow.operator_base.OperatorBase")) – The operator for which we want to get the gradient, Hessian or QFI.
    *   **bind\_params** (`Union`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.parametervector.ParameterVector"), `List`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")]]) – The operator parameters to which the parameter values are assigned.
    *   **grad\_params** (`Union`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterVector`](qiskit.circuit.ParameterVector "qiskit.circuit.parametervector.ParameterVector"), `List`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], `Tuple`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")], `List`\[`Tuple`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), [`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")]], `None`]) – The parameters with respect to which we are taking the gradient, Hessian or QFI. If grad\_params = None, then grad\_params = bind\_params
    *   **backend** (`Union`\[[`Backend`](qiskit.providers.Backend "qiskit.providers.backend.Backend"), [`QuantumInstance`](qiskit.utils.QuantumInstance "qiskit.utils.quantum_instance.QuantumInstance"), `None`]) – The quantum backend or QuantumInstance to use to evaluate the gradient, Hessian or QFI.
    *   **expectation** (`Optional`\[[`ExpectationBase`](qiskit.opflow.expectations.ExpectationBase "qiskit.opflow.expectations.expectation_base.ExpectationBase")]) – The expectation converter to be used. If none is set then PauliExpectation() is used.

    **Return type**

    `Callable`\[\[`Iterable`], `ndarray`]

    **Returns**

    Function to compute a gradient, Hessian or QFI. The function takes an iterable as argument which holds the parameter values.
  </Function>

  ### parameter\_expression\_grad

  <Function id="qiskit.opflow.gradients.DerivativeBase.parameter_expression_grad" signature="DerivativeBase.parameter_expression_grad(param_expr, param)" modifiers="static">
    Get the derivative of a parameter expression w\.r.t. the given parameter.

    **Parameters**

    *   **param\_expr** ([`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")) – The Parameter Expression for which we compute the derivative
    *   **param** ([`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression")) – Parameter w\.r.t. which we want to take the derivative

    **Return type**

    `Union`\[[`ParameterExpression`](qiskit.circuit.ParameterExpression "qiskit.circuit.parameterexpression.ParameterExpression"), `float`]

    **Returns**

    ParameterExpression representing the gradient of param\_expr w\.r.t. param
  </Function>
</Class>

