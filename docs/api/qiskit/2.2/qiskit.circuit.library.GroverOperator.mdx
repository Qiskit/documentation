---
title: GroverOperator (v2.2)
description: API reference for qiskit.circuit.library.GroverOperator in qiskit v2.2
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.GroverOperator
---

# GroverOperator

<Class id="qiskit.circuit.library.GroverOperator" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/stable/2.2/qiskit/circuit/library/grover_operator.py#L288-L563" signature="qiskit.circuit.library.GroverOperator(oracle, state_preparation=None, zero_reflection=None, reflection_qubits=None, insert_barriers=False, mcx_mode='noancilla', name='Q')" modifiers="class">
  Bases: [`QuantumCircuit`](qiskit.circuit.QuantumCircuit "qiskit.circuit.quantumcircuit.QuantumCircuit")

  The Grover operator.

  Grover’s search algorithm \[1, 2] consists of repeated applications of the so-called Grover operator used to amplify the amplitudes of the desired output states. This operator, $\mathcal{Q}$, consists of the phase oracle, $\mathcal{S}_f$, zero phase-shift or zero reflection, $\mathcal{S}_0$, and an input state preparation $\mathcal{A}$:

$$
\mathcal{Q} = \mathcal{A} \mathcal{S}_0 \mathcal{A}^\dagger \mathcal{S}_f


$$

  In the standard Grover search we have $\mathcal{A} = H^{\otimes n}$:

$$
\mathcal{Q} = H^{\otimes n} \mathcal{S}_0 H^{\otimes n} \mathcal{S}_f
= D \mathcal{S_f}


$$

  The operation $D = H^{\otimes n} \mathcal{S}_0 H^{\otimes n}$ is also referred to as diffusion operator. In this formulation we can see that Grover’s operator consists of two steps: first, the phase oracle multiplies the good states by -1 (with $\mathcal{S}_f$) and then the whole state is reflected around the mean (with $D$).

  This class allows setting a different state preparation, as in quantum amplitude amplification (a generalization of Grover’s algorithm), $\mathcal{A}$ might not be a layer of Hardamard gates \[3].

  The action of the phase oracle $\mathcal{S}_f$ is defined as

$$
\mathcal{S}_f: |x\rangle \mapsto (-1)^{f(x)}|x\rangle


$$

  where $f(x) = 1$ if $x$ is a good state and 0 otherwise. To highlight the fact that this oracle flips the phase of the good states and does not flip the state of a result qubit, we call $\mathcal{S}_f$ a phase oracle.

  Note that you can easily construct a phase oracle from a bitflip oracle by sandwiching the controlled X gate on the result qubit by a X and H gate. For instance

  ```text
  Bitflip oracle     Phaseflip oracle
  q_0: ──■──         q_0: ────────────■────────────
       ┌─┴─┐              ┌───┐┌───┐┌─┴─┐┌───┐┌───┐
  out: ┤ X ├         out: ┤ X ├┤ H ├┤ X ├┤ H ├┤ X ├
       └───┘              └───┘└───┘└───┘└───┘└───┘
  ```

  There is some flexibility in defining the oracle and $\mathcal{A}$ operator. Before the Grover operator is applied in Grover’s algorithm, the qubits are first prepared with one application of the $\mathcal{A}$ operator (or Hadamard gates in the standard formulation). Thus, we always have operation of the form $\mathcal{A} \mathcal{S}_f \mathcal{A}^\dagger$. Therefore it is possible to move bitflip logic into $\mathcal{A}$ and leaving the oracle only to do phaseflips via Z gates based on the bitflips. One possible use-case for this are oracles that do not uncompute the state qubits.

  The zero reflection $\mathcal{S}_0$ is usually defined as

$$
\mathcal{S}_0 = 2 |0\rangle^{\otimes n} \langle 0|^{\otimes n} - \mathbb{I}_n


$$

  where $\mathbb{I}_n$ is the identity on $n$ qubits. By default, this class implements the negative version $2 |0\rangle^{\otimes n} \langle 0|^{\otimes n} - \mathbb{I}_n$, since this can simply be implemented with a multi-controlled Z sandwiched by X gates on the target qubit and the introduced global phase does not matter for Grover’s algorithm.

  **Examples**

  ```python
  >>> from qiskit.circuit import QuantumCircuit
  >>> from qiskit.circuit.library import GroverOperator
  >>> oracle = QuantumCircuit(2)
  >>> oracle.z(0)  # good state = first qubit is |1>
  >>> grover_op = GroverOperator(oracle, insert_barriers=True)
  >>> grover_op.decompose().draw()
           ┌───┐ ░ ┌───┐ ░ ┌───┐          ┌───┐      ░ ┌───┐
  state_0: ┤ Z ├─░─┤ H ├─░─┤ X ├───────■──┤ X ├──────░─┤ H ├
           └───┘ ░ ├───┤ ░ ├───┤┌───┐┌─┴─┐├───┤┌───┐ ░ ├───┤
  state_1: ──────░─┤ H ├─░─┤ X ├┤ H ├┤ X ├┤ H ├┤ X ├─░─┤ H ├
                 ░ └───┘ ░ └───┘└───┘└───┘└───┘└───┘ ░ └───┘
  ```

  ```python
  >>> oracle = QuantumCircuit(1)
  >>> oracle.z(0)  # the qubit state |1> is the good state
  >>> state_preparation = QuantumCircuit(1)
  >>> state_preparation.ry(0.2, 0)  # non-uniform state preparation
  >>> grover_op = GroverOperator(oracle, state_preparation)
  >>> grover_op.decompose().draw()
           ┌───┐┌──────────┐┌───┐┌───┐┌───┐┌─────────┐
  state_0: ┤ Z ├┤ RY(-0.2) ├┤ X ├┤ Z ├┤ X ├┤ RY(0.2) ├
           └───┘└──────────┘└───┘└───┘└───┘└─────────┘
  ```

  ```python
  >>> oracle = QuantumCircuit(4)
  >>> oracle.z(3)
  >>> reflection_qubits = [0, 3]
  >>> state_preparation = QuantumCircuit(4)
  >>> state_preparation.cry(0.1, 0, 3)
  >>> state_preparation.ry(0.5, 3)
  >>> grover_op = GroverOperator(oracle, state_preparation,
  ... reflection_qubits=reflection_qubits)
  >>> grover_op.decompose().draw()
                                        ┌───┐          ┌───┐
  state_0: ──────────────────────■──────┤ X ├───────■──┤ X ├──────────■────────────────
                                 │      └───┘       │  └───┘          │
  state_1: ──────────────────────┼──────────────────┼─────────────────┼────────────────
                                 │                  │                 │
  state_2: ──────────────────────┼──────────────────┼─────────────────┼────────────────
           ┌───┐┌──────────┐┌────┴─────┐┌───┐┌───┐┌─┴─┐┌───┐┌───┐┌────┴────┐┌─────────┐
  state_3: ┤ Z ├┤ RY(-0.5) ├┤ RY(-0.1) ├┤ X ├┤ H ├┤ X ├┤ H ├┤ X ├┤ RY(0.1) ├┤ RY(0.5) ├
           └───┘└──────────┘└──────────┘└───┘└───┘└───┘└───┘└───┘└─────────┘└─────────┘
  ```

  ```python
  >>> mark_state = Statevector.from_label('011')
  >>> diffuse_operator = 2 * DensityMatrix.from_label('000') - Operator.from_label('III')
  >>> grover_op = GroverOperator(oracle=mark_state, zero_reflection=diffuse_operator)
  >>> grover_op.decompose().draw(fold=70)
           ┌─────────────────┐      ┌───┐                          »
  state_0: ┤0                ├──────┤ H ├──────────────────────────»
           │                 │┌─────┴───┴─────┐     ┌───┐          »
  state_1: ┤1 UCRZ(0,pi,0,0) ├┤0              ├─────┤ H ├──────────»
           │                 ││  UCRZ(pi/2,0) │┌────┴───┴────┐┌───┐»
  state_2: ┤2                ├┤1              ├┤ UCRZ(-pi/4) ├┤ H ├»
           └─────────────────┘└───────────────┘└─────────────┘└───┘»
  «         ┌─────────────────┐      ┌───┐
  «state_0: ┤0                ├──────┤ H ├─────────────────────────
  «         │                 │┌─────┴───┴─────┐    ┌───┐
  «state_1: ┤1 UCRZ(pi,0,0,0) ├┤0              ├────┤ H ├──────────
  «         │                 ││  UCRZ(pi/2,0) │┌───┴───┴────┐┌───┐
  «state_2: ┤2                ├┤1              ├┤ UCRZ(pi/4) ├┤ H ├
  «         └─────────────────┘└───────────────┘└────────────┘└───┘
  ```

  <Admonition title="See also" type="note">
    The [`grover_operator()`](qiskit.circuit.library.grover_operator "qiskit.circuit.library.grover_operator") implements the same functionality but keeping the [`MCXGate`](qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") abstract, such that the compiler may choose the optimal decomposition. We recommend using [`grover_operator()`](qiskit.circuit.library.grover_operator "qiskit.circuit.library.grover_operator") for performance reasons, which does not wrap the circuit into an opaque gate.
  </Admonition>

  References:

  \[1] L. K. Grover (1996), A fast quantum mechanical algorithm for database search, [arXiv:quant-ph/9605043](https://arxiv.org/abs/quant-ph/9605043).

  \[2] I. Chuang & M. Nielsen, Quantum Computation and Quantum Information, Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.

  \[3] Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000). Quantum Amplitude Amplification and Estimation. [arXiv:quant-ph/0005055](http://arxiv.org/abs/quant-ph/0005055).

  <Admonition title="Deprecated since version 2.1" type="danger">
    The class `qiskit.circuit.library.grover_operator.GroverOperator` is deprecated as of Qiskit 2.1. It will be removed in Qiskit 3.0. Use qiskit.circuit.library.grover\_operator instead.
  </Admonition>

  **Parameters**

  *   **oracle** (*Union\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")*,* [*Statevector*](qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector")*]*) – The phase oracle implementing a reflection about the bad state. Note that this is not a bitflip oracle, see the docstring for more information.
  *   **state\_preparation** (*Optional\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")*]*) – The operator preparing the good and bad state. For Grover’s algorithm, this is a n-qubit Hadamard gate and for amplitude amplification or estimation the operator $\mathcal{A}$.
  *   **zero\_reflection** (*Optional\[Union\[*[*QuantumCircuit*](qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")*,* [*DensityMatrix*](qiskit.quantum_info.DensityMatrix "qiskit.quantum_info.DensityMatrix")*,* [*Operator*](qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")*]]*) – The reflection about the zero state, $\mathcal{S}_0$.
  *   **reflection\_qubits** (*Optional\[List\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]]*) – Qubits on which the zero reflection acts on.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – Whether barriers should be inserted between the reflections and A.
  *   **mcx\_mode** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The mode to use for building the default zero reflection.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The name of the circuit.

  ## Attributes

  ### oracle

  <Attribute id="qiskit.circuit.library.GroverOperator.oracle">
    The oracle implementing a reflection about the bad state.
  </Attribute>

  ### reflection\_qubits

  <Attribute id="qiskit.circuit.library.GroverOperator.reflection_qubits">
    Reflection qubits, on which S0 is applied (if S0 is not user-specified).
  </Attribute>

  ### state\_preparation

  <Attribute id="qiskit.circuit.library.GroverOperator.state_preparation">
    The subcircuit implementing the A operator or Hadamards.
  </Attribute>

  ### zero\_reflection

  <Attribute id="qiskit.circuit.library.GroverOperator.zero_reflection">
    The subcircuit implementing the reflection about 0.
  </Attribute>

  ### name

  <Attribute id="qiskit.circuit.library.GroverOperator.name" attributeTypeHint="str">
    A human-readable name for the circuit.

    **Example**

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2, 2, name="my_circuit")
    print(qc.name)
    ```

    ```text
    my_circuit
    ```
  </Attribute>
</Class>

