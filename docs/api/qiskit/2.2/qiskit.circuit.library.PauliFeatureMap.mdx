---
title: PauliFeatureMap (v2.2)
description: API reference for qiskit.circuit.library.PauliFeatureMap in qiskit v2.2
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.circuit.library.PauliFeatureMap
---

# PauliFeatureMap

<Class id="qiskit.circuit.library.PauliFeatureMap" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit/tree/stable/2.2/qiskit/circuit/library/data_preparation/pauli_feature_map.py#L326-L643" signature="qiskit.circuit.library.PauliFeatureMap(feature_dimension=None, reps=2, entanglement='full', alpha=2.0, paulis=None, data_map_func=None, parameter_prefix='x', insert_barriers=False, name='PauliFeatureMap')" modifiers="class">
  Bases: [`NLocal`](qiskit.circuit.library.NLocal "qiskit.circuit.library.n_local.n_local.NLocal")

  The Pauli Expansion circuit.

  The Pauli Expansion circuit is a data encoding circuit that transforms input data $\vec{x} \in \mathbb{R}^n$, where n is the `feature_dimension`, as

$$
U_{\Phi(\vec{x})}=\exp\left(i\sum_{S \in \mathcal{I}}
\phi_S(\vec{x})\prod_{i\in S} P_i\right).
$$

  Here, $S$ is a set of qubit indices that describes the connections in the feature map, $\mathcal{I}$ is a set containing all these index sets, and $P_i \in \{I, X, Y, Z\}$. Per default the data-mapping $\phi_S$ is

$$
\phi_S(\vec{x}) = \begin{cases}
x_i \text{ if } S = \{i\} \\
\prod_{j \in S} (\pi - x_j) \text{ if } |S| > 1
\end{cases}.
$$

  The possible connections can be set using the `entanglement` and `paulis` arguments. For example, for single-qubit $Z$ rotations and two-qubit $YY$ interactions between all qubit pairs, we can set:

  ```python
  feature_map = PauliFeatureMap(..., paulis=["Z", "YY"], entanglement="full")
  ```

  which will produce blocks of the form

  ```text
  ┌───┐┌─────────────┐┌──────────┐                                            ┌───────────┐
  ┤ H ├┤ P(2.0*x[0]) ├┤ RX(pi/2) ├──■──────────────────────────────────────■──┤ RX(-pi/2) ├
  ├───┤├─────────────┤├──────────┤┌─┴─┐┌────────────────────────────────┐┌─┴─┐├───────────┤
  ┤ H ├┤ P(2.0*x[1]) ├┤ RX(pi/2) ├┤ X ├┤ P(2.0*(pi - x[0])*(pi - x[1])) ├┤ X ├┤ RX(-pi/2) ├
  └───┘└─────────────┘└──────────┘└───┘└────────────────────────────────┘└───┘└───────────┘
  ```

  The circuit contains `reps` repetitions of this transformation.

  Please refer to [`ZFeatureMap`](qiskit.circuit.library.ZFeatureMap "qiskit.circuit.library.ZFeatureMap") for the case of single-qubit Pauli-$Z$ rotations and to [`ZZFeatureMap`](qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap") for the single- and two-qubit Pauli-$Z$ rotations.

  **Examples**

  ```python
  >>> prep = PauliFeatureMap(2, reps=1, paulis=['ZZ'])
  >>> print(prep.decompose())
       ┌───┐
  q_0: ┤ H ├──■──────────────────────────────────────■──
       ├───┤┌─┴─┐┌────────────────────────────────┐┌─┴─┐
  q_1: ┤ H ├┤ X ├┤ P(2.0*(pi - x[0])*(pi - x[1])) ├┤ X ├
       └───┘└───┘└────────────────────────────────┘└───┘
  ```

  ```python
  >>> prep = PauliFeatureMap(2, reps=1, paulis=['Z', 'XX'])
  >>> print(prep.decompose())
       ┌───┐┌─────────────┐┌───┐                                            ┌───┐
  q_0: ┤ H ├┤ P(2.0*x[0]) ├┤ H ├──■──────────────────────────────────────■──┤ H ├
       ├───┤├─────────────┤├───┤┌─┴─┐┌────────────────────────────────┐┌─┴─┐├───┤
  q_1: ┤ H ├┤ P(2.0*x[1]) ├┤ H ├┤ X ├┤ P(2.0*(pi - x[0])*(pi - x[1])) ├┤ X ├┤ H ├
       └───┘└─────────────┘└───┘└───┘└────────────────────────────────┘└───┘└───┘
  ```

  ```python
  >>> prep = PauliFeatureMap(2, reps=1, paulis=['ZY'])
  >>> print(prep.decompose())
       ┌───┐┌──────────┐                                            ┌───────────┐
  q_0: ┤ H ├┤ RX(pi/2) ├──■──────────────────────────────────────■──┤ RX(-pi/2) ├
       ├───┤└──────────┘┌─┴─┐┌────────────────────────────────┐┌─┴─┐└───────────┘
  q_1: ┤ H ├────────────┤ X ├┤ P(2.0*(pi - x[0])*(pi - x[1])) ├┤ X ├─────────────
       └───┘            └───┘└────────────────────────────────┘└───┘
  ```

  ```python
  >>> from qiskit.circuit.library import EfficientSU2
  >>> prep = PauliFeatureMap(3, reps=3, paulis=['Z', 'YY', 'ZXZ'])
  >>> wavefunction = EfficientSU2(3)
  >>> classifier = prep.compose(wavefunction)
  >>> classifier.num_parameters
  27
  >>> classifier.count_ops()
  OrderedDict([('cx', 39), ('rx', 36), ('u1', 21), ('h', 15), ('ry', 12), ('rz', 12)])
  ```

  References:

  \[1] Havlicek et al. Supervised learning with quantum enhanced feature spaces, [Nature 567, 209-212 (2019)](https://www.nature.com/articles/s41586-019-0980-2).

  <Admonition title="Deprecated since version 2.1" type="danger">
    The class `qiskit.circuit.library.data_preparation.pauli_feature_map.PauliFeatureMap` is deprecated as of Qiskit 2.1. It will be removed in Qiskit 3.0. Use the pauli\_feature\_map function as a replacement. Note that this will no longer return a BlueprintCircuit, but just a plain QuantumCircuit.
  </Admonition>

  **Parameters**

  *   **feature\_dimension** (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]*) – Number of qubits in the circuit.
  *   **reps** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of repeated circuits.
  *   **entanglement** (*Union\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str)*, Dict\[*[*int*](https://docs.python.org/3/library/functions.html#int)*, List\[Tuple\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]]], Callable\[\[*[*int*](https://docs.python.org/3/library/functions.html#int)*], Union\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str)*, Dict\[*[*int*](https://docs.python.org/3/library/functions.html#int)*, List\[Tuple\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]]]]]]*) – Specifies the entanglement structure. Can be a string (`'full'`, `'linear'`, `'reverse_linear'`, `'circular'` or `'sca'`) or can be a dictionary where the keys represent the number of qubits and the values are list of integer-pairs specifying the indices of qubits that are entangled with one another, for example: `{1: [(0,), (2,)], 2: [(0,1), (2,0)]}` or can be a `Callable[[int], Union[str | Dict[...]]]` to return an entanglement specific for a repetition
  *   **alpha** ([*float*](https://docs.python.org/3/library/functions.html#float)) – The Pauli rotation factor, multiplicative to the pauli rotations
  *   **paulis** (*Optional\[List\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str)*]]*) – A list of strings for to-be-used paulis. If None are provided, `['Z', 'ZZ']` will be used.
  *   **data\_map\_func** (*Optional\[Callable\[\[np.ndarray],* [*float*](https://docs.python.org/3/library/functions.html#float)*]]*) – A mapping function for data x which can be supplied to override the default mapping from `self_product()`.
  *   **parameter\_prefix** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) – The prefix used if default parameters are generated.
  *   **insert\_barriers** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – If True, barriers are inserted in between the evolution instructions and Hadamard layers.
  *   **name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str)) –

  ## Attributes

  ### alpha

  <Attribute id="qiskit.circuit.library.PauliFeatureMap.alpha">
    The Pauli rotation factor (alpha).

    **Returns**

    The Pauli rotation factor.
  </Attribute>

  ### entanglement\_blocks

  <Attribute id="qiskit.circuit.library.PauliFeatureMap.entanglement_blocks">
    The blocks in the entanglement layers.

    **Returns**

    The blocks in the entanglement layers.
  </Attribute>

  ### feature\_dimension

  <Attribute id="qiskit.circuit.library.PauliFeatureMap.feature_dimension">
    Returns the feature dimension (which is equal to the number of qubits).

    **Returns**

    The feature dimension of this feature map.
  </Attribute>

  ### num\_parameters\_settable

  <Attribute id="qiskit.circuit.library.PauliFeatureMap.num_parameters_settable">
    The number of distinct parameters.
  </Attribute>

  ### paulis

  <Attribute id="qiskit.circuit.library.PauliFeatureMap.paulis">
    The Pauli strings used in the entanglement of the qubits.

    **Returns**

    The Pauli strings as list.
  </Attribute>

  ### name

  <Attribute id="qiskit.circuit.library.PauliFeatureMap.name" attributeTypeHint="str">
    A human-readable name for the circuit.

    **Example**

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(2, 2, name="my_circuit")
    print(qc.name)
    ```

    ```text
    my_circuit
    ```
  </Attribute>

  ## Methods

  ### get\_entangler\_map

  <Function id="qiskit.circuit.library.PauliFeatureMap.get_entangler_map" github="https://github.com/Qiskit/qiskit/tree/stable/2.2/qiskit/circuit/library/data_preparation/pauli_feature_map.py#L606-L643" signature="get_entangler_map(rep_num, block_num, num_block_qubits)">
    Get the entangler map for in the repetition `rep_num` and the block `block_num`.

    The entangler map for the current block is derived from the value of `self.entanglement`. Below the different cases are listed, where `i` and `j` denote the repetition number and the block number, respectively, and `n` the number of qubits in the block.

    | entanglement type                | entangler map                                      |
    | -------------------------------- | -------------------------------------------------- |
    | `None`                           | `[[0, ..., n - 1]]`                                |
    | `str` (e.g `'full'`)             | the specified connectivity on `n` qubits           |
    | `List[int]`                      | \[`entanglement`]                                  |
    | `List[List[int]]`                | `entanglement`                                     |
    | `List[List[List[int]]]`          | `entanglement[i]`                                  |
    | `List[List[List[List[int]]]]`    | `entanglement[i][j]`                               |
    | `List[str]`                      | the connectivity specified in `entanglement[i]`    |
    | `List[List[str]]`                | the connectivity specified in `entanglement[i][j]` |
    | `Callable[int, str]`             | same as `List[str]`                                |
    | `Callable[int, List[List[int]]]` | same as `List[List[List[int]]]`                    |

    Note that all indices are to be taken modulo the length of the array they act on, i.e. no out-of-bounds index error will be raised but we re-iterate from the beginning of the list.

    **Parameters**

    *   **rep\_num** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The current repetition we are in.
    *   **block\_num** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The block number within the entanglement layers.
    *   **num\_block\_qubits** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of qubits in the block.

    **Returns**

    The entangler map for the current block in the current repetition.

    **Raises**

    [**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError) – If the value of `entanglement` could not be cast to a corresponding entangler map.

    **Return type**

    [*Sequence*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)\[[*Sequence*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)\[[int](https://docs.python.org/3/library/functions.html#int)]]
  </Function>

  ### pauli\_block

  <Function id="qiskit.circuit.library.PauliFeatureMap.pauli_block" github="https://github.com/Qiskit/qiskit/tree/stable/2.2/qiskit/circuit/library/data_preparation/pauli_feature_map.py#L560-L564" signature="pauli_block(pauli_string)">
    Get the Pauli block for the feature map circuit.
  </Function>

  ### pauli\_evolution

  <Function id="qiskit.circuit.library.PauliFeatureMap.pauli_evolution" github="https://github.com/Qiskit/qiskit/tree/stable/2.2/qiskit/circuit/library/data_preparation/pauli_feature_map.py#L566-L604" signature="pauli_evolution(pauli_string, time)">
    Get the evolution block for the given pauli string.
  </Function>
</Class>

