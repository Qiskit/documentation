---
title: calculate_1q_epg
description: API reference for qiskit.ignis.verification.calculate_1q_epg
in_page_toc_min_heading_level: 1
python_api_type: function
python_api_name: qiskit.ignis.verification.calculate_1q_epg
---

<span id="qiskit-ignis-verification-calculate-1q-epg" />

# qiskit.ignis.verification.calculate\_1q\_epg

<Function id="qiskit.ignis.verification.calculate_1q_epg" isDedicatedPage={true} github="https://github.com/qiskit-community/qiskit-ignis/tree/stable/0.6/qiskit/ignis/verification/randomized_benchmarking/rb_utils.py" signature="calculate_1q_epg(gate_per_cliff, epc_1q, qubit)">
  Convert error per Clifford (EPC) into error per gates (EPGs) of single qubit basis gates.

  Given that a standard 1Q RB sequences consist of `u1`, `u2` and `u3` gates, the EPC can be written using those EPGs:

$$
EPC = 1 - (1 - EPG_{U1})^{N_{U1}} (1 - EPG_{U2})^{N_{U2}} (1 - EPG_{U3})^{N_{U3}}.
$$

  where $N_{x}$ is the number of gate $x$ per Clifford. Assuming `u1` composed of virtual-Z gate, ie FrameChange instruction, the $EPG_{U1}$ is estimated to be zero within the range of quantization error. Therefore the EPC can be written as:

$$
EPC = 1 - (1 - EPG_{U2})^{N_{U2}} (1 - EPG_{U3})^{N_{U3}}.
$$

  Because `u2` and `u3` gates are respectively implemented by a single and two half-pi pulses with virtual-Z rotations, we assume $EPG_{U3} = 2EPG_{U2}$. Using this relation in the limit of $EPG_{U2} \ll 1$:

$$
\begin{split}EPC & = 1 - (1 - EPG_{U2})^{N_{U2}} (1 - 2 EPG_{U2})^{N_{U3}} \\
& \simeq EPG_{U2}(N_{U2} + 2 N_{U3}).\end{split}
$$

  Finally the EPG of each basis gate can be written using EPC and number of gates:

$$
\begin{split}EPG_{U1} &= 0 \\
EPG_{U2} &= EPC / (N_{U2} + 2 N_{U3}) \\
EPG_{U3} &= 2 EPC / (N_{U2} + 2 N_{U3})\end{split}
$$

  To run this function, you first need to run a standard 1Q RB experiment with transpiled `QuantumCircuit` and count the number of basis gates composing the RB circuits.

  ```python
  import pprint
  import qiskit.ignis.verification.randomized_benchmarking as rb

  # assuming we ran 1Q RB experiment for qubit 0
  gpc = {0: {'cx': 0, 'u1': 0.13, 'u2': 0.31, 'u3': 0.51}}
  epc = 1.5e-3

  # calculate 1Q EPGs
  epgs = rb.rb_utils.calculate_1q_epg(gate_per_cliff=gpc, epc_1q=epc, qubit=0)
  pprint.pprint(epgs)
  ```

  ```python
  {'u1': 0, 'u2': 0.0011278195488721805, 'u3': 0.002255639097744361}
  ```

  In the example, `gpc` can be generated by [`gates_per_clifford()`](qiskit.ignis.verification.gates_per_clifford "qiskit.ignis.verification.gates_per_clifford"). The output of the function `epgs` can be used to calculate EPG of CNOT gate in conjugation with 2Q RB results, see [`calculate_2q_epg()`](qiskit.ignis.verification.calculate_2q_epg "qiskit.ignis.verification.calculate_2q_epg").

  <Admonition title="Note" type="note">
    This function presupposes the basis gate consists of `u1`, `u2` and `u3`.
  </Admonition>

  **Parameters**

  *   **gate\_per\_cliff** (`Dict`\[`int`, `Dict`\[`str`, `float`]]) – dictionary of gate per Clifford. see [`gates_per_clifford()`](qiskit.ignis.verification.gates_per_clifford "qiskit.ignis.verification.gates_per_clifford").
  *   **epc\_1q** (`float`) – EPC fit from 1Q RB experiment data.
  *   **qubit** (`int`) – index of qubit to calculate EPGs.

  **Return type**

  `Dict`\[`str`, `float`]

  **Returns**

  Dictionary of EPGs of single qubit basis gates.

  **Raises**

  **QiskitError** – when `u2` or `u3` is not found, `cx` gate count is nonzero, or specified qubit is not included in the gate count dictionary.
</Function>

