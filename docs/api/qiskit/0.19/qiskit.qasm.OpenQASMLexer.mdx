---
title: OpenQASMLexer
description: API reference for qiskit.qasm.OpenQASMLexer
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.qasm.OpenQASMLexer
---

# OpenQASMLexer

<Class id="qiskit.qasm.OpenQASMLexer" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.14/qiskit/qasm/pygments/lexer.py" signature="OpenQASMLexer(*args, **kwds)" modifiers="class">
  A pygments lexer for OpenQasm.

  ## Attributes

  ### alias\_filenames

  <Attribute id="qiskit.qasm.OpenQASMLexer.alias_filenames" attributeValue="[]">
    Secondary file name globs
  </Attribute>

  ### aliases

  <Attribute id="qiskit.qasm.OpenQASMLexer.aliases" attributeValue="['qasm']">
    Shortcuts for the lexer
  </Attribute>

  ### filenames

  <Attribute id="qiskit.qasm.OpenQASMLexer.filenames" attributeValue="['*.qasm']">
    File name globs
  </Attribute>

  ### flags

  <Attribute id="qiskit.qasm.OpenQASMLexer.flags" attributeValue="8">
    Flags for compiling the regular expressions. Defaults to MULTILINE.
  </Attribute>

  ### gates

  <Attribute id="qiskit.qasm.OpenQASMLexer.gates" attributeValue="['id', 'cx', 'x', 'y', 'z', 's', 'sdg', 'h', 't', 'tdg', 'ccx', 'c3x', 'c4x', 'c3sqrtx', 'rx', 'ry', 'rz', 'cz', 'cy', 'ch', 'swap', 'cswap', 'crx', 'cry', 'crz', 'cu1', 'cu3', 'rxx', 'rzz', 'rccx', 'rc3x', 'u1', 'u2', 'u3']" />

  ### mimetypes

  <Attribute id="qiskit.qasm.OpenQASMLexer.mimetypes" attributeValue="[]">
    MIME types
  </Attribute>

  ### name

  <Attribute id="qiskit.qasm.OpenQASMLexer.name" attributeValue="'OpenQASM'">
    Name of the lexer
  </Attribute>

  ### priority

  <Attribute id="qiskit.qasm.OpenQASMLexer.priority" attributeValue="0">
    Priority, should multiple lexers match and no content is provided
  </Attribute>

  ### tokens

  <Attribute id="qiskit.qasm.OpenQASMLexer.tokens" attributeValue="{'gate': [('[unitary\\d+]', Token.Keyword.Type, '#push'), ('p\\d+', Token.Text, '#push')], 'if_keywords': [('[a-zA-Z0-9_]*', Token.Literal.String, '#pop'), ('\\d+', Token.Literal.Number, '#push'), ('.*\\(', Token.Text, 'params')], 'index': [('\\d+', Token.Literal.Number, '#pop')], 'keywords': [('\\s*(&#x22;([^&#x22;]|&#x22;&#x22;)*&#x22;)', Token.Literal.String, '#push'), ('\\d+', Token.Literal.Number, '#push'), ('.*\\(', Token.Text, 'params')], 'params': [('[a-zA-Z_][a-zA-Z0-9_]*', Token.Text, '#push'), ('\\d+', Token.Literal.Number, '#push'), ('(\\d+\\.\\d*|\\d*\\.\\d+)([eEf][+-]?[0-9]+)?', Token.Literal.Number, '#push'), ('\\)', Token.Text)], 'root': [('\\n', Token.Text), ('[^\\S\\n]+', Token.Text), ('//\\n', Token.Comment), ('//.*?$', Token.Comment.Single), ('(OPENQASM|include)\\b', Token.Keyword.Reserved, 'keywords'), ('(qreg|creg)\\b', Token.Keyword.Declaration), ('(if)\\b', Token.Keyword.Reserved, 'if_keywords'), ('(pi)\\b', Token.Name.Constant), ('(barrier|measure|reset)\\b', Token.Name.Builtin, 'params'), ('(id|cx|x|y|z|s|sdg|h|t|tdg|ccx|c3x|c4x|c3sqrtx|rx|ry|rz|cz|cy|ch|swap|cswap|crx|cry|crz|cu1|cu3|rxx|rzz|rccx|rc3x|u1|u2|u3)\\b', Token.Keyword.Type, 'params'), ('[unitary\\d+]', Token.Keyword.Type), ('(gate)\\b', Token.Name.Function, 'gate'), ('[a-zA-Z_][a-zA-Z0-9_]*', Token.Text, 'index')]}">
    Dict of `{'state': [(regex, tokentype, new_state), ...], ...}`

    The initial state is ‘root’. `new_state` can be omitted to signify no state transition. If it is a string, the state is pushed on the stack and changed. If it is a tuple of strings, all states are pushed on the stack and the current state will be the topmost. It can also be `combined('state1', 'state2', ...)` to signify a new, anonymous state combined from the rules of two or more existing ones. Furthermore, it can be ‘#pop’ to signify going back one step in the state stack, or ‘#push’ to push the current state on the stack again.

    The tuple can also be replaced with `include('state')`, in which case the rules from the state named by the string are included in the current one.
  </Attribute>

  ## Methods

  ### add\_filter

  <Function id="qiskit.qasm.OpenQASMLexer.add_filter" signature="OpenQASMLexer.add_filter(filter_, **options)">
    Add a new stream filter to this lexer.
  </Function>

  ### analyse\_text

  <Function id="qiskit.qasm.OpenQASMLexer.analyse_text" signature="OpenQASMLexer.analyse_text(text)" modifiers="static">
    Has to return a float between `0` and `1` that indicates if a lexer wants to highlight this text. Used by `guess_lexer`. If this method returns `0` it won’t highlight it in any case, if it returns `1` highlighting with this lexer is guaranteed.

    The LexerMeta metaclass automatically wraps this function so that it works like a static method (no `self` or `cls` parameter) and the return value is automatically converted to float. If the return value is an object that is boolean False it’s the same as if the return values was `0.0`.
  </Function>

  ### get\_tokens

  <Function id="qiskit.qasm.OpenQASMLexer.get_tokens" signature="OpenQASMLexer.get_tokens(text, unfiltered=False)">
    Return an iterable of (tokentype, value) pairs generated from text. If unfiltered is set to True, the filtering mechanism is bypassed even if filters are defined.

    Also preprocess the text, i.e. expand tabs and strip it if wanted and applies registered filters.
  </Function>

  ### get\_tokens\_unprocessed

  <Function id="qiskit.qasm.OpenQASMLexer.get_tokens_unprocessed" signature="OpenQASMLexer.get_tokens_unprocessed(text, stack=('root',))">
    Split `text` into (tokentype, text) pairs.

    `stack` is the inital stack (default: `['root']`)
  </Function>
</Class>

