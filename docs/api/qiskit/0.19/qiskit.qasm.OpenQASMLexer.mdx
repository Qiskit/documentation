---
title: OpenQASMLexer (v0.19)
description: API reference for qiskit.qasm.OpenQASMLexer in qiskit v0.19
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit.qasm.OpenQASMLexer
---

# OpenQASMLexer

<Class id="qiskit.qasm.OpenQASMLexer" isDedicatedPage={true} github="https://github.com/qiskit/qiskit/tree/stable/0.14/qiskit/qasm/pygments/lexer.py" signature="OpenQASMLexer(*args, **kwds)" modifiers="class">
  A pygments lexer for OpenQasm.

  ## Attributes

  <span id="openqasmlexer-alias-filenames" />

  ### alias\_filenames

  <Attribute id="qiskit.qasm.OpenQASMLexer.alias_filenames" attributeValue="[]">
    Secondary file name globs
  </Attribute>

  <span id="openqasmlexer-aliases" />

  ### aliases

  <Attribute id="qiskit.qasm.OpenQASMLexer.aliases" attributeValue="['qasm']">
    Shortcuts for the lexer
  </Attribute>

  <span id="openqasmlexer-filenames" />

  ### filenames

  <Attribute id="qiskit.qasm.OpenQASMLexer.filenames" attributeValue="['*.qasm']">
    File name globs
  </Attribute>

  <span id="openqasmlexer-flags" />

  ### flags

  <Attribute id="qiskit.qasm.OpenQASMLexer.flags" attributeValue="8">
    Flags for compiling the regular expressions. Defaults to MULTILINE.
  </Attribute>

  <span id="openqasmlexer-gates" />

  ### gates

  <Attribute id="qiskit.qasm.OpenQASMLexer.gates" attributeValue="['id', 'cx', 'x', 'y', 'z', 's', 'sdg', 'h', 't', 'tdg', 'ccx', 'c3x', 'c4x', 'c3sqrtx', 'rx', 'ry', 'rz', 'cz', 'cy', 'ch', 'swap', 'cswap', 'crx', 'cry', 'crz', 'cu1', 'cu3', 'rxx', 'rzz', 'rccx', 'rc3x', 'u1', 'u2', 'u3']" />

  <span id="openqasmlexer-mimetypes" />

  ### mimetypes

  <Attribute id="qiskit.qasm.OpenQASMLexer.mimetypes" attributeValue="[]">
    MIME types
  </Attribute>

  <span id="openqasmlexer-name" />

  ### name

  <Attribute id="qiskit.qasm.OpenQASMLexer.name" attributeValue="'OpenQASM'">
    Name of the lexer
  </Attribute>

  <span id="openqasmlexer-priority" />

  ### priority

  <Attribute id="qiskit.qasm.OpenQASMLexer.priority" attributeValue="0">
    Priority, should multiple lexers match and no content is provided
  </Attribute>

  <span id="openqasmlexer-tokens" />

  ### tokens

  <Attribute id="qiskit.qasm.OpenQASMLexer.tokens" attributeValue="{'gate': [('[unitary\\d+]', Token.Keyword.Type, '#push'), ('p\\d+', Token.Text, '#push')], 'if_keywords': [('[a-zA-Z0-9_]*', Token.Literal.String, '#pop'), ('\\d+', Token.Literal.Number, '#push'), ('.*\\(', Token.Text, 'params')], 'index': [('\\d+', Token.Literal.Number, '#pop')], 'keywords': [('\\s*(&#x22;([^&#x22;]|&#x22;&#x22;)*&#x22;)', Token.Literal.String, '#push'), ('\\d+', Token.Literal.Number, '#push'), ('.*\\(', Token.Text, 'params')], 'params': [('[a-zA-Z_][a-zA-Z0-9_]*', Token.Text, '#push'), ('\\d+', Token.Literal.Number, '#push'), ('(\\d+\\.\\d*|\\d*\\.\\d+)([eEf][+-]?[0-9]+)?', Token.Literal.Number, '#push'), ('\\)', Token.Text)], 'root': [('\\n', Token.Text), ('[^\\S\\n]+', Token.Text), ('//\\n', Token.Comment), ('//.*?$', Token.Comment.Single), ('(OPENQASM|include)\\b', Token.Keyword.Reserved, 'keywords'), ('(qreg|creg)\\b', Token.Keyword.Declaration), ('(if)\\b', Token.Keyword.Reserved, 'if_keywords'), ('(pi)\\b', Token.Name.Constant), ('(barrier|measure|reset)\\b', Token.Name.Builtin, 'params'), ('(id|cx|x|y|z|s|sdg|h|t|tdg|ccx|c3x|c4x|c3sqrtx|rx|ry|rz|cz|cy|ch|swap|cswap|crx|cry|crz|cu1|cu3|rxx|rzz|rccx|rc3x|u1|u2|u3)\\b', Token.Keyword.Type, 'params'), ('[unitary\\d+]', Token.Keyword.Type), ('(gate)\\b', Token.Name.Function, 'gate'), ('[a-zA-Z_][a-zA-Z0-9_]*', Token.Text, 'index')]}">
    Dict of `{'state': [(regex, tokentype, new_state), ...], ...}`

    The initial state is ‘root’. `new_state` can be omitted to signify no state transition. If it is a string, the state is pushed on the stack and changed. If it is a tuple of strings, all states are pushed on the stack and the current state will be the topmost. It can also be `combined('state1', 'state2', ...)` to signify a new, anonymous state combined from the rules of two or more existing ones. Furthermore, it can be ‘#pop’ to signify going back one step in the state stack, or ‘#push’ to push the current state on the stack again.

    The tuple can also be replaced with `include('state')`, in which case the rules from the state named by the string are included in the current one.
  </Attribute>

  ## Methods

  <span id="openqasmlexer-add-filter" />

  ### add\_filter

  <Function id="qiskit.qasm.OpenQASMLexer.add_filter" signature="OpenQASMLexer.add_filter(filter_, **options)">
    Add a new stream filter to this lexer.
  </Function>

  <span id="openqasmlexer-analyse-text" />

  ### analyse\_text

  <Function id="qiskit.qasm.OpenQASMLexer.analyse_text" signature="OpenQASMLexer.analyse_text(text)" modifiers="static">
    Has to return a float between `0` and `1` that indicates if a lexer wants to highlight this text. Used by `guess_lexer`. If this method returns `0` it won’t highlight it in any case, if it returns `1` highlighting with this lexer is guaranteed.

    The LexerMeta metaclass automatically wraps this function so that it works like a static method (no `self` or `cls` parameter) and the return value is automatically converted to float. If the return value is an object that is boolean False it’s the same as if the return values was `0.0`.
  </Function>

  <span id="openqasmlexer-get-tokens" />

  ### get\_tokens

  <Function id="qiskit.qasm.OpenQASMLexer.get_tokens" signature="OpenQASMLexer.get_tokens(text, unfiltered=False)">
    Return an iterable of (tokentype, value) pairs generated from text. If unfiltered is set to True, the filtering mechanism is bypassed even if filters are defined.

    Also preprocess the text, i.e. expand tabs and strip it if wanted and applies registered filters.
  </Function>

  <span id="openqasmlexer-get-tokens-unprocessed" />

  ### get\_tokens\_unprocessed

  <Function id="qiskit.qasm.OpenQASMLexer.get_tokens_unprocessed" signature="OpenQASMLexer.get_tokens_unprocessed(text, stack=('root',))">
    Split `text` into (tokentype, text) pairs.

    `stack` is the inital stack (default: `['root']`)
  </Function>
</Class>

