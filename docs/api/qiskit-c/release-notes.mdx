---
title: Qiskit SDK C API release notes
description: Changes made to Qiskit SDK C API
in_page_toc_max_heading_level: 2
---

<span id="qiskit-version-release-notes" />

<span id="release-notes" />

# Qiskit SDK C API release notes

<span id="relnotes-unreleased-notes-preview" />

## Unreleased Notes Preview

<span id="relnotes-unreleased-notes-preview-prelude" />

### Prelude

This release adds support for `stretch` variables to [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") which are used to express relationships between instruction durations. For example, in order to ensure a sequence of gates between two barriers will be left-aligned, whatever their actual durations may be, we can do the following:

```c
from qiskit import QuantumCircuit
from numpy import pi

qc = QuantumCircuit(5)
qc.barrier()
qc.cx(0, 1)
qc.u(pi/4, 0, pi/2, 2)
qc.cx(3, 4)

a = qc.add_stretch("a")
b = qc.add_stretch("b")
c = qc.add_stretch("c")

# Use the stretches as Delay duration.
qc.delay(a, [0, 1])
qc.delay(b, 2)
qc.delay(c, [3, 4])
qc.barrier()
```

For additional context and examples, refer to the [OpenQASM 3 language specification.](https://openqasm.com/language/delays.html#duration-and-stretch-types)

<span id="relnotes-unreleased-notes-preview-new-features" />

### New Features

*   Added a new class [`QFTGate`](qiskit-circuit-library-qft-gate#qiskit.circuit.library.QFTGate "qiskit.circuit.library.QFTGate") for natively representing Quantum Fourier Transforms (QFTs). The older way of representing QFTs via quantum circuits, see [`QFT`](qiskit-circuit-library-qft#qiskit.circuit.library.QFT "qiskit.circuit.library.QFT"), remains for backward compatibility. The new way of representing a QFT via a gate avoids synthesizing its definition circuit when the gate is declared, delaying the actual synthesis to the transpiler. It also allows to easily choose between several different algorithms for synthesizing QFTs, which are available as high-level-synthesis plugins.

*   Added a synthesis method [`synth_qft_full()`](synthesis#qiskit.synthesis.synth_qft_full "qiskit.synthesis.synth_qft_full") for constructing a QFT circuit assuming a fully-connected architecture.

*   Added two high-level-synthesis plugins for synthesizing a [`QFTGate`](qiskit-circuit-library-qft-gate#qiskit.circuit.library.QFTGate "qiskit.circuit.library.QFTGate"). The class [`QFTSynthesisFull`](qiskit-transpiler-passes-synthesis-hls-plugins-qft-synthesis-full#qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisFull "qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisFull") is based on [`synth_qft_full()`](synthesis#qiskit.synthesis.synth_qft_full "qiskit.synthesis.synth_qft_full") and synthesizes a QFT gate assuming all-to-all connectivity. The class [`QFTSynthesisLine`](qiskit-transpiler-passes-synthesis-hls-plugins-qft-synthesis-line#qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisLine "qiskit.transpiler.passes.synthesis.hls_plugins.QFTSynthesisLine") is based on [`synth_qft_line()`](synthesis#qiskit.synthesis.synth_qft_line "qiskit.synthesis.synth_qft_line") and synthesizes a QFT gate assuming linear nearest neighbor connectivity.

*   [`MCXVChain`](qiskit-circuit-library-mcxv-chain#qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain") has two new Boolean parameters relative\_phase and action\_only. If action\_only the circuit does not clean the dirty qubits. If relative\_phase the gate is implemented up to a global phase. Both parameters are used to optimize the decomposition of MCXVChain.

*   Support for level 1 data was added to [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2") as was support for passing options through to the `run()` method of the wrapped [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2"). The run options can be specified using a `"run_options"` entry inside of the `options` dicitonary passed to [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2"). The `"run_options"` entry should be a dictionary mapping argument names to values for passing to the backend’s `run()` method. When a `"meas_level"` option with a value of 1 is set in the run options, the results from the backend will be treated as level 1 results rather as bit arrays (the level 2 format).

*   Added two parameters to [`GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") to exclude error (noise\_info) and pulse channel information (pulse\_channels) from the construction of the backend. These parameters are true by default, replicating the initial default behavior of the constructor. A memory-sensitive user may set these options to False to reduce the memory overhead by 40x when transpiling on large- scale [`GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2").

*   The [`StabilizerState`](qiskit-quantum-info-stabilizer-state#qiskit.quantum_info.StabilizerState "qiskit.quantum_info.StabilizerState") class now has a new method [`probabilities_dict_from_bitstring()`](qiskit-quantum-info-stabilizer-state#qiskit.quantum_info.StabilizerState.probabilities_dict_from_bitstring "qiskit.quantum_info.StabilizerState.probabilities_dict_from_bitstring") allowing the user to pass single bitstring to measure an outcome for. Previouslly the [`probabilities_dict()`](qiskit-quantum-info-stabilizer-state#qiskit.quantum_info.StabilizerState.probabilities_dict "qiskit.quantum_info.StabilizerState.probabilities_dict") would be utilized and would at worst case calculate (2^n) number of probability calculations (depending on the state), even if a user wanted a single result. With this new method the user can calculate just the single outcome bitstring value a user passes to measure the probability for. As the number of qubits increases, the more prevelant the performance enhancement may be (depending on the state) as only 1 bitstring result is measured.

*   Implemented `UniformSuperpositionGate` class, which allows the creation of a uniform superposition state using the Shukla-Vedula algorithm. This feature facilitates the creation of quantum circuits that produce a uniform superposition state $\frac{1}{\sqrt{M}} \sum_{j=0}^{M-1} |j\rangle$, where $M$ is a positive integer representing the number of computational basis states with an amplitude of $\frac{1}{\sqrt{M}}$. This implementation supports the efficient creation of uniform superposition states, requiring only $O(\log_2 (M))$ qubits and $O(\log_2 (M))$ gates. Usage example:

    ```python
    from qiskit import QuantumCircuit 
    from qiskit.circuit.library.data_preparation import UniformSuperpositionGate

    M = 5
    num_qubits = 3
    usp_gate = UniformSuperpositionGate(M, num_qubits)
    qc = QuantumCircuit(num_qubits)
    qc.append(usp_gate, list(range(num_qubits)))

    qc.draw()
    ```

*   Support for the Linux aarch64 platform has been promoted to tier 1 support as documented in:

    [guides/install-qiskit#operating-system-support](/guides/install-qiskit#operating-system-support)

    from its previous support level of tier 2 in the 1.x release series.

*   Introduced a C API to build and interact with sparse observables. While the API surface in this release is fairly small, just covering the [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") class this new API lays the foundation for Qiskit’s C interface.

    The detailed syntax and more information is available under the C API docs, but a minimal example to construct the 100-qubit observable `X0 Y1 Z1` is:

    ```c
    #include <complex.h>
    #include <qiskit.h>
    #include <stdint.h>
    #include <stdio.h>

    int main(int argc, char *argv[]) {
        // build a 100-qubit empty observable
        uint32_t num_qubits = 100;
        QkObs *obs = qk_obs_zero(num_qubits);

        // add the term 2 * (X0 Y1 Z2) to the observable
        complex double coeff = 2;
        QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};
        uint32_t indices[3] = {0, 1, 2};
        QkObsTerm term = {coeff, 3, bit_terms, indices, num_qubits};
        qk_obs_add_term(obs, &term);

        // print some properties
        printf("num_qubits: %u\n", qk_obs_num_qubits(obs));
        printf("num_terms: %lu\n", qk_obs_num_terms(obs));

        // free the memory allocated for the observable
        qk_obs_free(obs);

        return 0;
    }
    ```

<span id="relnotes-unreleased-notes-preview-circuits-features" />

### Circuits Features

*   Added support for `AnnotatedOperation.params()` and [`AnnotatedOperation.validate_parameter()`](qiskit-circuit-annotated-operation#qiskit.circuit.AnnotatedOperation.validate_parameter "qiskit.circuit.AnnotatedOperation.validate_parameter"), which enable circuit-level parameter handling (such as binding parameters) for annotated operations.

*   [`CircuitInstruction`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") and [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") each have new methods to query various properties of their internal [`Operation`](qiskit-circuit-operation#qiskit.circuit.Operation "qiskit.circuit.Operation"), without necessarily needing to access it. These methods are:

    *   [`CircuitInstruction.is_standard_gate()`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.is_standard_gate "qiskit.circuit.CircuitInstruction.is_standard_gate") and [`DAGOpNode.is_standard_gate()`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.is_standard_gate "qiskit.dagcircuit.DAGOpNode.is_standard_gate"),
    *   [`CircuitInstruction.is_controlled_gate()`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.is_controlled_gate "qiskit.circuit.CircuitInstruction.is_controlled_gate") and [`DAGOpNode.is_controlled_gate()`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.is_controlled_gate "qiskit.dagcircuit.DAGOpNode.is_controlled_gate"),
    *   [`CircuitInstruction.is_directive()`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.is_directive "qiskit.circuit.CircuitInstruction.is_directive") and [`DAGOpNode.is_directive()`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.is_directive "qiskit.dagcircuit.DAGOpNode.is_directive"),
    *   [`CircuitInstruction.is_control_flow()`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.is_control_flow "qiskit.circuit.CircuitInstruction.is_control_flow") and [`DAGOpNode.is_control_flow()`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.is_control_flow "qiskit.dagcircuit.DAGOpNode.is_control_flow"), and
    *   [`CircuitInstruction.is_parameterized()`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.is_parameterized "qiskit.circuit.CircuitInstruction.is_parameterized") and [`DAGOpNode.is_parameterized()`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.is_parameterized "qiskit.dagcircuit.DAGOpNode.is_parameterized").

    If applicable, using any of these methods is significantly faster than querying [`CircuitInstruction.operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation") or [`DAGOpNode.op`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.op "qiskit.dagcircuit.DAGOpNode.op") directly, especially if the instruction or node represents a Qiskit standard gate. This is because the standard gates are stored natively in Rust, and their Python representation is only created when requested.

*   A native rust representation of Qiskit’s standard gate library has been added. When a standard gate is added to a [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") it is now represented in a more efficient manner directly in Rust seamlessly. Accessing that gate object from a circuit or dag will return a new Python object representing the standard gate. This leads to faster and more efficient transpilation and manipulation of circuits for functionality written in Rust.

*   Improved performance of the method [`DAGCircuit.quantum_causal_cone()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.quantum_causal_cone "qiskit.dagcircuit.DAGCircuit.quantum_causal_cone") by not examining the same non-directive node multiple times when reached from different paths.

*   Replacing the internal synthesis algorithm of [`StatePreparation`](qiskit-circuit-library-state-preparation#qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") and [`Initialize`](qiskit-circuit-library-initialize#qiskit.circuit.library.Initialize "qiskit.circuit.library.Initialize") of Shende et al. by the algorithm given in [`Isometry`](qiskit-circuit-library-isometry#qiskit.circuit.library.Isometry "qiskit.circuit.library.Isometry") of Iten et al. The new algorithm reduces the number of CX gates and the circuit depth by a factor of 2.

*   [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") now supports the unary `+` operator.

*   Improved the functionality of [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") to include support for the following parameterized gates with free parameters: [`RXXGate`](qiskit-circuit-library-rxx-gate#qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate"),:class:.RYYGate,:class:.RZZGate,:class:.RZXGate, [`RXGate`](qiskit-circuit-library-rx-gate#qiskit.circuit.library.RXGate "qiskit.circuit.library.RXGate"),:class:.RYGate,:class:.RZGate,:class:.PhaseGate, [`U1Gate`](qiskit-circuit-library-u-1-gate#qiskit.circuit.library.U1Gate "qiskit.circuit.library.U1Gate"),:class:.CRXGate,:class:.CRYGate,:class:.CRZGate, [`CPhaseGate`](qiskit-circuit-library-c-phase-gate#qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate").

    Before these were only supported with bound parameters.

*   Added a new function `quantum_volume()` for generating a quantum volume [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object as defined in A. Cross et al. Validating quantum computers using randomized model circuits, Phys. Rev. A 100, 032328 (2019) [https://link.aps.org/doi/10.1103/PhysRevA.100.032328](https://link.aps.org/doi/10.1103/PhysRevA.100.032328). This new function differs from the existing [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") class in that it returns a [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") object instead of building a subclass object. The second is that this new function is multithreaded and implemented in rust so it generates the output circuit \~10x faster than the [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") class.

*   Improved the runtime performance of constructing the [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") class with the `classical_permutation` argument set to `True`. Internally it now calls the `quantum_volume()` function which is written in Rust which is \~10x faster to generate a quantum volume circuit.

*   Added a new function to `qiskit.circuit.random` that allows to generate a pseudo-random Clifford circuit with gates from the standard library: `random_clifford_circuit()`. Example usage:

    ```python
    from qiskit.circuit.random import random_clifford_circuit

    circ = random_clifford_circuit(num_qubits=2, num_gates=6)
    circ.draw(output='mpl')
    ```

    ![\_images/release\_notes-1.png](/images/api/qiskit-c/release_notes-1.avif)

*   Added a new circuit manipulation function [`pauli_twirl_2q_gates()`](circuit#qiskit.circuit.pauli_twirl_2q_gates "qiskit.circuit.pauli_twirl_2q_gates") that can be used to apply Pauli twirling to a given circuit. This only works for twirling a fixed set of two-qubit gates, currently [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate"), [`ECRGate`](qiskit-circuit-library-ecr-gate#qiskit.circuit.library.ECRGate "qiskit.circuit.library.ECRGate"), [`CZGate`](qiskit-circuit-library-cz-gate#qiskit.circuit.library.CZGate "qiskit.circuit.library.CZGate"), [`iSwapGate`](qiskit-circuit-library-i-swap-gate#qiskit.circuit.library.iSwapGate "qiskit.circuit.library.iSwapGate"). For example:

    ```python
    from qiskit.circuit import QuantumCircuit, pauli_twirl_2q_gates

    qc = QuantumCircuit(2)
    qc.cx(0, 1)
    twirled_circuit = pauli_twirl_2q_gates(qc, seed=123456)
    twirled_circuit.draw("mpl")
    ```

    ![\_images/release\_notes-2.png](/images/api/qiskit-c/release_notes-2.avif)

*   Added binary arithmetic gates for inplace addition two $n$-qubit registers, that is $|a\rangle |b\rangle \mapsto |a\rangle |a+b\rangle$. The [`ModularAdderGate`](qiskit-circuit-library-modular-adder-gate#qiskit.circuit.library.ModularAdderGate "qiskit.circuit.library.ModularAdderGate") implements addition modulo $2^n$, the `AdderGate` implements standard addition including a carry-out, and the [`FullAdderGate`](qiskit-circuit-library-full-adder-gate#qiskit.circuit.library.FullAdderGate "qiskit.circuit.library.FullAdderGate") includes a carry-in qubit. See the respective documentations for details and examples.

    In contrast to the existing library circuits, such as [`CDKMRippleCarryAdder`](qiskit-circuit-library-cdkm-ripple-carry-adder#qiskit.circuit.library.CDKMRippleCarryAdder "qiskit.circuit.library.CDKMRippleCarryAdder"), handling the abstract gate allows the compiler (or user) to select the optimal gate synthesis, depending on the circuit’s context.

*   Added the [`MultiplierGate`](qiskit-circuit-library-multiplier-gate#qiskit.circuit.library.MultiplierGate "qiskit.circuit.library.MultiplierGate") for multiplication of two $n$-qubit registers, that is $|a\rangle |b\rangle \mapsto |a\rangle |b\rangle |a \cdot b\rangle$. See the class documentations for details and examples.

*   Quantum circuits in `qiskit.circuit.library.boolean_logic` now have equivalent representations as [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate") objects:

    *   [`AndGate`](qiskit-circuit-library-and-gate#qiskit.circuit.library.AndGate "qiskit.circuit.library.AndGate"), representing [`AND`](qiskit-circuit-library-and#qiskit.circuit.library.AND "qiskit.circuit.library.AND"),
    *   [`OrGate`](qiskit-circuit-library-or-gate#qiskit.circuit.library.OrGate "qiskit.circuit.library.OrGate"), representing [`OR`](qiskit-circuit-library-or#qiskit.circuit.library.OR "qiskit.circuit.library.OR"),
    *   [`BitwiseXorGate`](qiskit-circuit-library-bitwise-xor-gate#qiskit.circuit.library.BitwiseXorGate "qiskit.circuit.library.BitwiseXorGate"), representing [`XOR`](qiskit-circuit-library-xor#qiskit.circuit.library.XOR "qiskit.circuit.library.XOR"),
    *   [`InnerProductGate`](qiskit-circuit-library-inner-product-gate#qiskit.circuit.library.InnerProductGate "qiskit.circuit.library.InnerProductGate"), representing [`InnerProduct`](qiskit-circuit-library-inner-product#qiskit.circuit.library.InnerProduct "qiskit.circuit.library.InnerProduct").

*   Specialized implementations of [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__ "(in Python v3.13)") have been added for all standard-library circuit gates. Most of the standard gates already specialized this method, but a few did not, and could cause significant slowdowns in unexpected places.

*   Added `evolved_operator_ansatz()`, `hamiltonian_variational_ansatz()`, and `qaoa_ansatz()` to the circuit library to implement variational circuits based on operator evolutions. `evolved_operator_ansatz()` and `qaoa_ansatz()` are functionally equivalent to [`EvolvedOperatorAnsatz`](qiskit-circuit-library-evolved-operator-ansatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz") and [`QAOAAnsatz`](qiskit-circuit-library-qaoa-ansatz#qiskit.circuit.library.QAOAAnsatz "qiskit.circuit.library.QAOAAnsatz"), but generally more performant.

    The `hamiltonian_variational_ansatz()` is designed to take a single Hamiltonian and automatically split it into commuting terms to implement a Hamiltonian variational ansatz. This could already be achieved manually by using the [`EvolvedOperatorAnsatz`](qiskit-circuit-library-evolved-operator-ansatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz"), but is now more convenient to use.

*   Added `grover_operator()` to construct a Grover operator circuit, used in e.g. Grover’s algorithm and amplitude estimation/amplification. This function is similar to [`GroverOperator`](qiskit-circuit-library-grover-operator#qiskit.circuit.library.GroverOperator "qiskit.circuit.library.GroverOperator"), but does not require choosing the implementation of the multi-controlled X gate a-priori and let’s the compiler choose the optimal decomposition instead. In addition to this, it does not wrap the circuit into an opaque gate and is faster as less decompositions are required to transpile.

    Example:

    ```c
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import grover_operator

    oracle = QuantumCircuit(2)
    oracle.z(0)  # good state = first qubit is |1>
    grover_op = grover_operator(oracle, insert_barriers=True)
    print(grover_op.draw())
    ```

*   A new data attribute, [`qiskit.circuit.CONTROL_FLOW_OP_NAMES`](circuit#qiskit.circuit.CONTROL_FLOW_OP_NAMES "qiskit.circuit.CONTROL_FLOW_OP_NAMES"), is available to easily find and check whether a given [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") is a control-flow operation by name.

*   The standard equivalence library ([`SessionEquivalenceLibrary`](circuit#qiskit.circuit.SessionEquivalenceLibrary "qiskit.circuit.SessionEquivalenceLibrary")) now has rules that can directly convert between Qiskit’s standard-library 2q continuous Ising-type interactions (e.g. [`CPhaseGate`](qiskit-circuit-library-c-phase-gate#qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate"), [`RZZGate`](qiskit-circuit-library-rzz-gate#qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate"), [`RZXGate`](qiskit-circuit-library-rzx-gate#qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate"), and so on) using local equivalence relations. Previously, several of these conversions would go via a 2-CX form, which resulted in less efficient circuit generation.

    <Admonition title="Note" type="note">
      In general, the [`BasisTranslator`](qiskit-transpiler-passes-basis-translator#qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") is not guaranteed to find the “best” equivalence relation for a given [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target"), but will always find an equivalence if one exists. We rely on more expensive resynthesis and gate-optimization passes in the transpiler to improve the output. These passes are currently not as effective for basis sets with a continuously parametrized two-qubit interaction as they are for discrete super-controlled two-qubit interactions.
    </Admonition>

*   The random\_circuit function from qiskit.circuit.random.utils has a new feature where users can specify a distribution num\_operand\_distribution (a dict) that specifies the ratio of 1-qubit, 2-qubit, 3-qubit, and 4-qubit gates in the random circuit. For example, if num\_operand\_distribution = \{1: 0.25, 2: 0.25, 3: 0.25, 4: 0.25} is passed to the function then the generated circuit will have approximately 25% of 1-qubit, 2-qubit, 3-qubit, and 4-qubit gates (The order in which the dictionary is passed does not matter i.e. you can specify num\_operand\_distribution = \{3: 0.5, 1: 0.0, 4: 0.3, 2: 0.2} and the function will still work as expected). Also it should be noted that the if num\_operand\_distribution is not specified then max\_operands will default to 4 and a random circuit with a random gate distribution will be generated. If both num\_operand\_distribution and max\_operands are specified at the same time then num\_operand\_distribution will be used to generate the random circuit. Example usage:

    ```c
    from qiskit.circuit.random import random_circuit

    circ = random_circuit(num_qubits=6, depth=5, num_operand_distribution = {1: 0.25, 2: 0.25, 3: 0.25, 4: 0.25})
    circ.draw(output='mpl')
    ```

*   Added a new argument `"apply_synthesis"` to [`Decompose`](qiskit-transpiler-passes-decompose#qiskit.transpiler.passes.Decompose "qiskit.transpiler.passes.Decompose"), which allows the transpiler pass to apply high-level synthesis to decompose objects that are only defined by a synthesis routine. For example:

    ```c
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Clifford
    from qiskit.transpiler.passes import Decompose

    cliff = Clifford(HGate())
    circuit = QuantumCircuit(1)
    circuit.append(cliff, [0])

    # Clifford has no .definition, it is only defined by synthesis
    nothing_happened = Decompose()(circuit)

    # this internally runs the HighLevelSynthesis pass to decompose the Clifford
    decomposed = Decompose(apply_synthesis=True)(circuit)
    ```

*   Added the [`iqp()`](qiskit-circuit-library-iqp-function#qiskit.circuit.library.iqp "qiskit.circuit.library.iqp") function to construct Instantaneous Quantum Polynomial time (IQP) circuits. In addition to the existing [`IQP`](qiskit-circuit-library-iqp#qiskit.circuit.library.IQP "qiskit.circuit.library.IQP") class, the function also allows construction of random IQP circuits:

    ```c
    from qiskit.circuit.library import iqp

    random_iqp = iqp(num_qubits=4)
    print(random_iqp.draw())
    ```

*   Added the [`MCMTGate`](qiskit-circuit-library-mcmt-gate#qiskit.circuit.library.MCMTGate "qiskit.circuit.library.MCMTGate") to represent a multi-control multi-target operation as a gate. This gate representation of the existing [`MCMT`](qiskit-circuit-library-mcmt#qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") circuit allows the compiler to select the best available implementation according to the number and the state of auxiliary qubits present in the circuit.

    Specific implementation can be chosen by specifying the high-level synthesis plugin:

    ```c
    from qiskit import QuantumCircuit, transpile
    from qiskit.circuit.library import MCMTGate, HGate
    from qiskit.transpiler.passes import HLSConfig  # used for the synthesis config

    mcmt = MCMTGate(HGate(), num_ctrl_qubits=5, num_target_qubits=3)

    circuit = QuantumCircuit(20)
    circuit.append(mcmt, range(mcmt.num_qubits))

    config = HLSConfig(mcmt=["vchain"])  # alternatively use the "noaux" method
    synthesized = transpile(circuit, hls_config=config)
    ```

    The [`MCMTGate`](qiskit-circuit-library-mcmt-gate#qiskit.circuit.library.MCMTGate "qiskit.circuit.library.MCMTGate") in addition also supports custom (i.e., open) control states of the control qubits.

*   As a part of circuit library modernization, each of the following quantum circuits is either also represented as a [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate") object or can be constructed using a synthesis method:

    *   [`GraphState`](qiskit-circuit-library-graph-state#qiskit.circuit.library.GraphState "qiskit.circuit.library.GraphState") is represented by [`GraphStateGate`](qiskit-circuit-library-graph-state-gate#qiskit.circuit.library.GraphStateGate "qiskit.circuit.library.GraphStateGate"),
    *   [`FourierChecking`](qiskit-circuit-library-fourier-checking#qiskit.circuit.library.FourierChecking "qiskit.circuit.library.FourierChecking") can be constructed using `fourier_checking()`,
    *   [`UnitaryOverlap`](qiskit-circuit-library-unitary-overlap#qiskit.circuit.library.UnitaryOverlap "qiskit.circuit.library.UnitaryOverlap") can be constructed using `unitary_overlap()`,
    *   [`HiddenLinearFunction`](qiskit-circuit-library-hidden-linear-function#qiskit.circuit.library.HiddenLinearFunction "qiskit.circuit.library.HiddenLinearFunction") can be constructed using `hidden_linear_function()`,
    *   [`PhaseEstimation`](qiskit-circuit-library-phase-estimation#qiskit.circuit.library.PhaseEstimation "qiskit.circuit.library.PhaseEstimation") can be constructed using `phase_estimation()`.

*   [`PauliFeatureMap`](qiskit-circuit-library-pauli-feature-map#qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap") and [`ZZFeatureMap`](qiskit-circuit-library-zz-feature-map#qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap") now support specifying the entanglement as a dictionary where the keys represent the number of qubits, and the values are lists of integer tuples that define which qubits are entangled with one another. This allows for more flexibility in constructing feature maps tailored to specific quantum algorithms. Example usage:

    ```c
    from qiskit.circuit.library import PauliFeatureMap
    entanglement = {
      1: [(0,), (2,)],
      2: [(0, 1), (1, 2)],
      3: [(0, 1, 2)],
    }
    qc = PauliFeatureMap(3, reps=2, paulis=['Z', 'ZZ', 'ZZZ'], entanglement=entanglement, insert_barriers=True)
    qc.decompose().draw('mpl')
    ```

*   The [`count_ops()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.count_ops "qiskit.circuit.QuantumCircuit.count_ops") method in [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") has been re-written in Rust. It now runs between 3 and 9 times faster.

*   Added the `insert_barriers` keyword argument to the [`repeat()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.repeat "qiskit.circuit.QuantumCircuit.repeat") method. Setting it to `True` will insert barriers between circuit repetitions.

*   Added circuit library functions `pauli_feature_map()`, `z_feature_map()`, `zz_feature_map()` to construct Pauli feature map circuits. These functions are approximately 8x faster than the current circuit library objects, [`PauliFeatureMap`](qiskit-circuit-library-pauli-feature-map#qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap"), [`ZFeatureMap`](qiskit-circuit-library-z-feature-map#qiskit.circuit.library.ZFeatureMap "qiskit.circuit.library.ZFeatureMap"), and [`ZZFeatureMap`](qiskit-circuit-library-zz-feature-map#qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap"), and will replace them in the future. Note, that the new functions return a plain [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instead of a `BlueprintCircuit`.

    The functions can be used as drop-in replacement:

    ```c
    from qiskit.circuit.library import pauli_feature_map, PauliFeatureMap

    fm = pauli_feature_map(20, paulis=["z", "xx", "yyy"])
    also_fm = PauliFeatureMap(20, paulis=["z", "xx", "yyy"]).decompose()
    ```

*   [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") has several new methods to work with and inspect manual [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") variables.

    See [Working with real-time typed classical data](qiskit-circuit-quantum-circuit#circuit-real-time-methods) for more in-depth discussion on all of these.

    The new methods are:

    *   [`add_var()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.add_var "qiskit.circuit.QuantumCircuit.add_var")
    *   [`add_input()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.add_input "qiskit.circuit.QuantumCircuit.add_input")
    *   [`add_capture()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.add_capture "qiskit.circuit.QuantumCircuit.add_capture")
    *   [`add_uninitialized_var()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.add_uninitialized_var "qiskit.circuit.QuantumCircuit.add_uninitialized_var")
    *   [`get_var()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.get_var "qiskit.circuit.QuantumCircuit.get_var")
    *   [`has_var()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.has_var "qiskit.circuit.QuantumCircuit.has_var")
    *   [`iter_vars()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.iter_vars "qiskit.circuit.QuantumCircuit.iter_vars")
    *   [`iter_declared_vars()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.iter_declared_vars "qiskit.circuit.QuantumCircuit.iter_declared_vars")
    *   [`iter_captured_vars()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.iter_captured_vars "qiskit.circuit.QuantumCircuit.iter_captured_vars")
    *   [`iter_input_vars()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.iter_input_vars "qiskit.circuit.QuantumCircuit.iter_input_vars")
    *   [`store()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.store "qiskit.circuit.QuantumCircuit.store")

    In addition, there are several new dynamic attributes on [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") surrounding these variables:

    *   [`num_vars`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.num_vars "qiskit.circuit.QuantumCircuit.num_vars")
    *   [`num_input_vars`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.num_input_vars "qiskit.circuit.QuantumCircuit.num_input_vars")
    *   [`num_captured_vars`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.num_captured_vars "qiskit.circuit.QuantumCircuit.num_captured_vars")
    *   [`num_declared_vars`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.num_declared_vars "qiskit.circuit.QuantumCircuit.num_declared_vars")

*   [`ControlFlowOp`](qiskit-circuit-control-flow-op#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") and its subclasses now have a [`iter_captured_vars()`](qiskit-circuit-control-flow-op#qiskit.circuit.ControlFlowOp.iter_captured_vars "qiskit.circuit.ControlFlowOp.iter_captured_vars") method, which will return an iterator over the unique variables captured in any of its immediate blocks.

*   [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") has several new methods to work with and inspect manual [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") variables. These are largely equivalent to their [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") counterparts, except that the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") ones are optimized for programmatic access with already defined objects, while the [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods are more focussed on interactive human use.

    The new methods are:

    *   [`add_input_var()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.add_input_var "qiskit.dagcircuit.DAGCircuit.add_input_var")
    *   [`add_captured_var()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.add_captured_var "qiskit.dagcircuit.DAGCircuit.add_captured_var")
    *   [`add_declared_var()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.add_declared_var "qiskit.dagcircuit.DAGCircuit.add_declared_var")
    *   [`has_var()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.has_var "qiskit.dagcircuit.DAGCircuit.has_var")
    *   [`iter_vars()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.iter_vars "qiskit.dagcircuit.DAGCircuit.iter_vars")
    *   [`iter_declared_vars()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.iter_declared_vars "qiskit.dagcircuit.DAGCircuit.iter_declared_vars")
    *   [`iter_captured_vars()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.iter_captured_vars "qiskit.dagcircuit.DAGCircuit.iter_captured_vars")
    *   [`iter_input_vars()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.iter_input_vars "qiskit.dagcircuit.DAGCircuit.iter_input_vars")

    There are also new public attributes:

    *   [`num_vars`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.num_vars "qiskit.dagcircuit.DAGCircuit.num_vars")
    *   [`num_input_vars`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.num_input_vars "qiskit.dagcircuit.DAGCircuit.num_input_vars")
    *   [`num_captured_vars`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.num_captured_vars "qiskit.dagcircuit.DAGCircuit.num_captured_vars")
    *   [`num_declared_vars`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.num_declared_vars "qiskit.dagcircuit.DAGCircuit.num_declared_vars")

*   [`DAGCircuit.wires`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.wires "qiskit.dagcircuit.DAGCircuit.wires") will now also contain any [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") manual variables in the circuit as well, as these are also classical data flow.

*   A new method, [`Var.new()`](circuit-classical#qiskit.circuit.classical.expr.Var.new "qiskit.circuit.classical.expr.Var.new"), is added to manually construct a real-time classical variable that owns its memory.

*   [`QuantumCircuit.compose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose") has two need keyword arguments, `var_remap` and `inline_captures` to better support real-time classical variables.

    `var_remap` can be used to rewrite [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes in the circuit argument as its instructions are inlined onto the base circuit. This can be used to avoid naming conflicts.

    `inline_captures` can be set to `True` (defaults to `False`) to link all [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes tracked as “captures” in the argument circuit with the same [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes in the base circuit, without attempting to redeclare the variables. This can be used, in combination with [`QuantumCircuit.copy_empty_like()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.copy_empty_like "qiskit.circuit.QuantumCircuit.copy_empty_like")’s `vars_mode="captures"` handling, to build up a circuit layer by layer, containing variables.

*   [`DAGCircuit.compose()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.compose "qiskit.dagcircuit.DAGCircuit.compose") has a new keyword argument, `inline_captures`, which can be set to `True` to inline “captured” [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes on the argument circuit onto the base circuit without redeclaring them. In conjunction with the `vars_mode="captures"` option to several [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") methods, this can be used to combine DAGs that operate on the same variables.

*   [`QuantumCircuit.copy_empty_like()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.copy_empty_like "qiskit.circuit.QuantumCircuit.copy_empty_like") and [`DAGCircuit.copy_empty_like()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.copy_empty_like "qiskit.dagcircuit.DAGCircuit.copy_empty_like") have a new keyword argument, `vars_mode` which controls how any memory-owning [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes are tracked in the output. By default (`"alike"`), the variables are declared in the same input/captured/local mode as the source. This can be set to `"captures"` to convert all variables to captures (useful with [`compose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose")) or `"drop"` to remove them.

*   A new `vars_mode` keyword argument has been added to the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") methods:

    *   [`separable_circuits()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.separable_circuits "qiskit.dagcircuit.DAGCircuit.separable_circuits")
    *   [`layers()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.layers "qiskit.dagcircuit.DAGCircuit.layers")
    *   [`serial_layers()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.serial_layers "qiskit.dagcircuit.DAGCircuit.serial_layers")

    which has the same meaning as it does for [`copy_empty_like()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.copy_empty_like "qiskit.dagcircuit.DAGCircuit.copy_empty_like").

*   Added a new [`get_control_flow_name_mapping()`](circuit#qiskit.circuit.get_control_flow_name_mapping "qiskit.circuit.get_control_flow_name_mapping") convenience function that returns a mapping of Qiskit’s control-flow operation names to their corresponding class. Example usage:

    ```python
    from qiskit.circuit import get_control_flow_name_mapping

    ctrl_flow_name_map = get_control_flow_name_mapping()
    if_else_object = ctrl_flow_name_map["if_else"]

    print(if_else_object)
    ```

    ```text
    <class 'qiskit.circuit.controlflow.if_else.IfElseOp'>
    ```

*   Added a new method, [`QuantumCircuit.estimate_duration()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.estimate_duration "qiskit.circuit.QuantumCircuit.estimate_duration"), to compute the estimated duration of a scheduled circuit output from the [`transpiler`](transpiler#module-qiskit.transpiler "qiskit.transpiler"). This should be used if you need an estimate of the full circuit duration instead of the deprecated [`QuantumCircuit.duration`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.duration "qiskit.circuit.QuantumCircuit.duration") attribute.

*   The new [`BitFlipOracleGate`](qiskit-circuit-library-bit-flip-oracle-gate#qiskit.circuit.library.BitFlipOracleGate "qiskit.circuit.library.BitFlipOracleGate") and [`PhaseOracleGate`](qiskit-circuit-library-phase-oracle-gate#qiskit.circuit.library.PhaseOracleGate "qiskit.circuit.library.PhaseOracleGate") have the same interface as [`PhaseOracle`](qiskit-circuit-library-phase-oracle#qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") (except the evaluate\_bitstring method). Bit-flip oracle gate synthesizes a bit flip oracle instead of a phase flip oracle, meaning it acts on one additional qubit and can be seen as applying a controlled X operation, where the control is the value of the expression encoded by the oracle.

    ```python
    from qiskit import QuantumCircuit
    from qiskit.circuit.library.bit_flip_oracle import BitFlipOracleGate
    from qiskit.circuit.library.phase_oracle import PhaseOracleGate
    qc = QuantumCircuit(5)
    bool_expr = "(x0 & x1 | ~x2) & x4"
    oracle = BitFlipOracleGate(bool_expr)
    qc.compose(oracle, inplace=True)
    print(qc)
    ```

    ```text
         ┌─────────────────────┐
    q_0: ┤0                    ├
         │                     │
    q_1: ┤1                    ├
         │                     │
    q_2: ┤2 (x0 & x1 | ~x2)... ├
         │                     │
    q_3: ┤3                    ├
         │                     │
    q_4: ┤4                    ├
         └─────────────────────┘
    ```

    ```python
    print(qc.decompose())
    ```

    ```text
    q_0: ──o────■────■──
           │    │    │  
    q_1: ──┼────o────■──
           │    │    │  
    q_2: ──o────o────┼──
           │    │    │  
    q_3: ──■────■────■──
         ┌─┴─┐┌─┴─┐┌─┴─┐
    q_4: ┤ X ├┤ X ├┤ X ├
         └───┘└───┘└───┘
    ```

    ```python
    qc = QuantumCircuit(5)
    bool_expr = "(x0 & x1 | ~x2) & x4"
    oracle = PhaseOracleGate(bool_expr)
    qc.compose(oracle, inplace=True)
    print(qc)
    ```

    ```text
         ┌───────────────┐
    q_0: ┤0              ├
         │               │
    q_1: ┤1              ├
         │  Phase oracle │
    q_2: ┤2              ├
         │               │
    q_3: ┤3              ├
         └───────────────┘
    q_4: ─────────────────
    ```

    ```python
    print(qc.decompose())
    ```

    ```text
    q_0: ─o──■──■─
          │  │  │ 
    q_1: ─┼──o──■─
          │  │  │ 
    q_2: ─o──o──┼─
          │  │  │ 
    q_3: ─■──■──■─

    q_4: ─────────
    ```

*   Added a new argument `approximation_degree` to [`CommutationChecker.commute()`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker.commute "qiskit.circuit.CommutationChecker.commute") and [`CommutationChecker.commute_nodes()`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker.commute_nodes "qiskit.circuit.CommutationChecker.commute_nodes"), which allows to set the approximation threshold for when gates are said to commute. See the docstring of [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") for more detail.

*   A new method, [`QuantumCircuit.noop()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.noop "qiskit.circuit.QuantumCircuit.noop"), allows qubits to be marked as explicitly used within a control-flow builder scope, without adding a corresponding operation to them.

*   The classical realtime-expressions module [`qiskit.circuit.classical`](circuit-classical#module-qiskit.circuit.classical "qiskit.circuit.classical") can now represent constant expressions. The [`Expr`](circuit-classical#qiskit.circuit.classical.expr.Expr "qiskit.circuit.classical.expr.Expr") class now has a bool `const` attribute which indicates the expression’s const-ness. This allows us to enforce that expressions in certain contexts must be possible to evaluate at compile time.

    All [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") expressions are considered to be non-const, while all [`Value`](circuit-classical#qiskit.circuit.classical.expr.Value "qiskit.circuit.classical.expr.Value") expressions are const.

    An expression comprised only of other const expressions is also const:

    ```c
    from qiskit.circuit.classical import expr

    assert expr.bit_and(5, 6).const
    ```

    An expression that contains any non-const expression is non-const:

    ```c
    from qiskit.circuit.classical import expr, types

    assert not expr.bit_and(5, expr.Var.new("a", types.Uint(5)).const
    ```

*   The classical realtime-expressions module [`qiskit.circuit.classical`](circuit-classical#module-qiskit.circuit.classical "qiskit.circuit.classical") can now represent duration using the new types [`Duration`](circuit-classical#qiskit.circuit.classical.types.Duration "qiskit.circuit.classical.types.Duration").

    The module [`qiskit.circuit`](circuit#module-qiskit.circuit "qiskit.circuit") also has a new `Duration` class which can be used as a literal value within classical expressions.

    The [`lift()`](circuit-classical#qiskit.circuit.classical.expr.lift "qiskit.circuit.classical.expr.lift") function can be used to create a value expression from a `Duration` instance:

    ```c
    from qiskit.circuit import Duration
    from qiskit.circuit.classical import expr

    expr.lift(Duration.dt(1000))
    # Value(Duration.dt(1000), Duration())
    ```

*   The classical realtime-expressions module [`qiskit.circuit.classical`](circuit-classical#module-qiskit.circuit.classical "qiskit.circuit.classical") can now represent IEEE-754 double-precision floating point values using the new type [`Float`](circuit-classical#qiskit.circuit.classical.types.Float "qiskit.circuit.classical.types.Float").

    The [`lift()`](circuit-classical#qiskit.circuit.classical.expr.lift "qiskit.circuit.classical.expr.lift") function can be used to create a value expression from a Python float:

    ```c
    from qiskit.circuit.classical import expr

    expr.lift(5.0)
    # >>> Value(5.0, Float())
    ```

    This type is intended primarily for use in timing-related (duration and stretch) expressions. It is not compatible with bitwise or logical operations, though it can be used (dangerously) with these if first explicitly cast to something else.

*   Reduce the number of two-qubit gates when decomposing some multi-controlled single-qubit unitary gates. For example,

    *   For multi-controlled [`YGate`](qiskit-circuit-library-y-gate#qiskit.circuit.library.YGate "qiskit.circuit.library.YGate") on 10 qubits, we reduce the [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") count by 56%,
    *   For multi-controlled [`HGate`](qiskit-circuit-library-h-gate#qiskit.circuit.library.HGate "qiskit.circuit.library.HGate") on 10 qubits, we reduce the [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") count by 56%,
    *   For multi-controlled [`SXGate`](qiskit-circuit-library-sx-gate#qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") and [`SXdgGate`](qiskit-circuit-library-s-xdg-gate#qiskit.circuit.library.SXdgGate "qiskit.circuit.library.SXdgGate") on 10 qubits, we reduce the [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") count by 80%,
    *   For multi-controlled [`UGate`](qiskit-circuit-library-u-gate#qiskit.circuit.library.UGate "qiskit.circuit.library.UGate") on 10 qubits, we reduce the [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") count by 31%.

*   The classical realtime-expressions module [`qiskit.circuit.classical`](circuit-classical#module-qiskit.circuit.classical "qiskit.circuit.classical") can now represent arithmetic operations [`add()`](circuit-classical#qiskit.circuit.classical.expr.add "qiskit.circuit.classical.expr.add"), [`sub()`](circuit-classical#qiskit.circuit.classical.expr.sub "qiskit.circuit.classical.expr.sub"), [`mul()`](circuit-classical#qiskit.circuit.classical.expr.mul "qiskit.circuit.classical.expr.mul"), and [`div()`](circuit-classical#qiskit.circuit.classical.expr.div "qiskit.circuit.classical.expr.div") on numeric and timing operands.

    For example:

    ```c
    from qiskit.circuit import QuantumCircuit, ClassicalRegister, Duration
    from qiskit.circuit.classical import expr

    # Subtract two integers
    cr = ClassicalRegister(4, "cr")
    qc = QuantumCircuit(cr)
    with qc.if_test(expr.equal(expr.sub(cr, 2), 3)):
        pass

    # Multiply a Duration by a Float
    with qc.if_test(expr.less(expr.mul(Duration.dt(200), 2.0), Duration.ns(500))):
        pass

    # Divide a Duration by a Duration to get a Float
    with qc.if_test(expr.greater(expr.div(Duration.dt(200), Duration.dt(400)), 0.5)):
        pass
    ```

    For additional examples, see the module-level documentation linked above.

*   [`UCGate`](qiskit-circuit-library-uc-gate#qiskit.circuit.library.UCGate "qiskit.circuit.library.UCGate") now includes a `mux_simp` boolean attribute that enables the search for simplifications of Carvalho et al., implemented in `_simplify()`. This optimization, enabled by default, identifies and removes unnecessary controls from the multiplexer, reducing the number of CX gates and circuit depth, especially in separable state preparation with [`Initialize`](qiskit-circuit-library-initialize#qiskit.circuit.library.Initialize "qiskit.circuit.library.Initialize").

*   The [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") now natively supports [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable")s as input. This efficiently allows to handle evolution under projectors, which are implemented as controls of a phase rotation and require less gates than explicitly expanding the projector in terms of Paulis. For example:

    ```c
    from qiskit.circuit.library import PauliEvolutionGate
    from qiskit.quantum_info import SparseObservable

    obs = SparseObservable("001")
    evo_proj = PauliEvolutionGate(obs, time=1)
    print(evo_proj.definition.draw())
    ```

*   A new expression node [`Stretch`](circuit-classical#qiskit.circuit.classical.expr.Stretch "qiskit.circuit.classical.expr.Stretch") has been added to the classical expression system to represent `stretch` variables. To create a new ```stretch` variable, you can use :meth:`.QuantumCircuit.add_stretch`. The resulting expression is a constant expression of type :class:`~.types.Duration`, which can currently be used as the ``duration``` argument of a [`delay()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.delay "qiskit.circuit.QuantumCircuit.delay").

    The [`Stretch`](circuit-classical#qiskit.circuit.classical.expr.Stretch "qiskit.circuit.classical.expr.Stretch") expression is most similar to the existing [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") expression used to represent classical variables in a circuit, except it is constant and is always of type [`Duration`](circuit-classical#qiskit.circuit.classical.types.Duration "qiskit.circuit.classical.types.Duration"). It can be used in other expressions (e.g. you can multiply it by a numeric constant) and [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") provides full scoping support for it (e.g. it can be captured by or declared within a control flow scope).

*   Added [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate") versions of the single-register arithmetic gates, which allow the compiler to perform high-level optimizations compared to their [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") variants. These are:

    > *   [`ExactReciprocalGate`](qiskit-circuit-library-exact-reciprocal-gate#qiskit.circuit.library.ExactReciprocalGate "qiskit.circuit.library.ExactReciprocalGate") (replacing [`ExactReciprocal`](qiskit-circuit-library-exact-reciprocal#qiskit.circuit.library.ExactReciprocal "qiskit.circuit.library.ExactReciprocal"))
    > *   [`IntegerComparatorGate`](qiskit-circuit-library-integer-comparator-gate#qiskit.circuit.library.IntegerComparatorGate "qiskit.circuit.library.IntegerComparatorGate") (replacing [`IntegerComparator`](qiskit-circuit-library-integer-comparator#qiskit.circuit.library.IntegerComparator "qiskit.circuit.library.IntegerComparator"))
    > *   [`LinearPauliRotationsGate`](qiskit-circuit-library-linear-pauli-rotations-gate#qiskit.circuit.library.LinearPauliRotationsGate "qiskit.circuit.library.LinearPauliRotationsGate") (replacing [`LinearPauliRotations`](qiskit-circuit-library-linear-pauli-rotations#qiskit.circuit.library.LinearPauliRotations "qiskit.circuit.library.LinearPauliRotations"))
    > *   [`PiecewiseLinearPauliRotationsGate`](qiskit-circuit-library-piecewise-linear-pauli-rotations-gate#qiskit.circuit.library.PiecewiseLinearPauliRotationsGate "qiskit.circuit.library.PiecewiseLinearPauliRotationsGate") (replacing [`PiecewiseLinearPauliRotations`](qiskit-circuit-library-piecewise-linear-pauli-rotations#qiskit.circuit.library.PiecewiseLinearPauliRotations "qiskit.circuit.library.PiecewiseLinearPauliRotations"))
    > *   [`PiecewiseChebyshevGate`](qiskit-circuit-library-piecewise-chebyshev-gate#qiskit.circuit.library.PiecewiseChebyshevGate "qiskit.circuit.library.PiecewiseChebyshevGate") (replacing [`PiecewiseChebyshev`](qiskit-circuit-library-piecewise-chebyshev#qiskit.circuit.library.PiecewiseChebyshev "qiskit.circuit.library.PiecewiseChebyshev"))
    > *   [`PiecewisePolynomialPauliRotationsGate`](qiskit-circuit-library-piecewise-polynomial-pauli-rotations-gate#qiskit.circuit.library.PiecewisePolynomialPauliRotationsGate "qiskit.circuit.library.PiecewisePolynomialPauliRotationsGate") (replacing [`PiecewisePolynomialPauliRotations`](qiskit-circuit-library-piecewise-polynomial-pauli-rotations#qiskit.circuit.library.PiecewisePolynomialPauliRotations "qiskit.circuit.library.PiecewisePolynomialPauliRotations"))
    > *   [`PolynomialPauliRotationsGate`](qiskit-circuit-library-polynomial-pauli-rotations-gate#qiskit.circuit.library.PolynomialPauliRotationsGate "qiskit.circuit.library.PolynomialPauliRotationsGate") (replacing [`PolynomialPauliRotations`](qiskit-circuit-library-polynomial-pauli-rotations#qiskit.circuit.library.PolynomialPauliRotations "qiskit.circuit.library.PolynomialPauliRotations"))
    > *   [`LinearAmplitudeFunctionGate`](qiskit-circuit-library-linear-amplitude-function-gate#qiskit.circuit.library.LinearAmplitudeFunctionGate "qiskit.circuit.library.LinearAmplitudeFunctionGate") (replacing [`LinearAmplitudeFunction`](qiskit-circuit-library-linear-amplitude-function#qiskit.circuit.library.LinearAmplitudeFunction "qiskit.circuit.library.LinearAmplitudeFunction"))
    > *   [`QuadraticFormGate`](qiskit-circuit-library-quadratic-form-gate#qiskit.circuit.library.QuadraticFormGate "qiskit.circuit.library.QuadraticFormGate") (replacing [`QuadraticForm`](qiskit-circuit-library-quadratic-form#qiskit.circuit.library.QuadraticForm "qiskit.circuit.library.QuadraticForm"))
    > *   [`WeightedSumGate`](qiskit-circuit-library-weighted-sum-gate#qiskit.circuit.library.WeightedSumGate "qiskit.circuit.library.WeightedSumGate") (replacing [`WeightedAdder`](qiskit-circuit-library-weighted-adder#qiskit.circuit.library.WeightedAdder "qiskit.circuit.library.WeightedAdder"))

<span id="relnotes-unreleased-notes-preview-primitives-features" />

### Primitives Features

*   Added a new method [`BitArray.postselect()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.postselect "qiskit.primitives.BitArray.postselect") that returns all shots containing specified bit values. Example usage:

    ```c
    from qiskit.primitives.containers import BitArray

    ba = BitArray.from_counts({'110': 2, '100': 4, '000': 3})
    print(ba.postselect([0,2], [0,1]).get_counts())
    # {'110': 2, '100': 4}
    ```

*   The metadata of Primitives V2 implementations, i.e., [`StatevectorSampler`](qiskit-primitives-statevector-sampler#qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler"), [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator"), [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2") and [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2"), has been updated to match that of IBM quantum devices.

    *   `version` and `circuit_metadata` are added for all V2 implementations
    *   `shots` is added for [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2") and [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2")
    *   `precision` is renamed with `target_precision` for [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator")

    Note that metadata of [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator") does not have `shots` because the class computes expectation values with [`Statevector`](qiskit-quantum-info-statevector#qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") and shots are not used.

*   `Estimator` and [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator") return expectation values in a stochastic way if the input circuit includes a reset for a some subsystems. The result was not reproducible, but it is now reproducible if a random seed is set. For example:

    ```c
    from qiskit.primitives import StatevectorEstimator

    estimator = StatevectorEstimator(seed=123)
    ```

    or:

    ```c
    from qiskit.primitives import Estimator

    estimator = Estimator(options={"seed":123})
    ```

*   Added `to_bool_array()` method to `BitArray` class that returns the bit array as a boolean NumPy array. The `order` argument can be used to specify the endianness of the output array.

*   Expanded the docstring of `ObservablesArray.tolist()` to make it clear it might return a scalar in the case the observables array is of dimension 0.

<span id="relnotes-unreleased-notes-preview-providers-features" />

### Providers Features

*   Added the ability to set the `dt` property of [`GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") in the class initializer with a new `dt` argument. Example usage:

    ```c
    from qiskit.providers.fake_provider import GenericBackendV2
    backend = GenericBackendV2(
      num_qubits=5, 
      basis_gates=["cx", "id", "rz", "sx", "x"],
      dt= 2.22*e-10, 
      seed=42)
    ```

<span id="relnotes-unreleased-notes-preview-openqasm-features" />

### OpenQASM Features

*   The internal symbol table of the OpenQASM 3 exporter ([`qiskit.qasm3`](qasm-3#module-qiskit.qasm3 "qiskit.qasm3")) has been rewritten, which should result in cleaner outputs when using Qiskit standard-library gates that are not in the OpenQASM 3 standard-library headers, and more deterministic outputs. For example, using several [`RZXGate`](qiskit-circuit-library-rzx-gate#qiskit.circuit.library.RZXGate "qiskit.circuit.library.RZXGate")s will now result in only a single parametric definition, and when naming collisions occur, the symbol table will assign a deterministic counter to make names unique, rather than a non-deterministic integer (previously, the object identity was used).

*   The vendored version of the OpenQASM 3.0 standard library has been updated to match [the state as of commit 4ca1d79383](https://github.com/openqasm/openqasm/blob/4ca1d793833b24a195dcb8a5db99f1bd21b0d32f/examples/stdgates.inc). This should generally have no effect on your use of Qiskit, unless you were retrieving our vendored file for your own use.

*   The class [`qasm3.CustomGate`](qasm-3#qiskit.qasm3.CustomGate "qiskit.qasm3.CustomGate") is now inspectable programmatically. Its [`constructor`](qasm-3#qiskit.qasm3.CustomGate.constructor "qiskit.qasm3.CustomGate.constructor"), [`name`](qasm-3#qiskit.qasm3.CustomGate.name "qiskit.qasm3.CustomGate.name"), [`num_params`](qasm-3#qiskit.qasm3.CustomGate.num_params "qiskit.qasm3.CustomGate.num_params") and [`num_qubits`](qasm-3#qiskit.qasm3.CustomGate.num_qubits "qiskit.qasm3.CustomGate.num_qubits") can now be viewed from Python after the object has been constructed. This allows you to inspect the contents of provided data attributes like [`STDGATES_INC_GATES`](qasm-3#qiskit.qasm3.STDGATES_INC_GATES "qiskit.qasm3.STDGATES_INC_GATES").

*   The OpenQASM 3 exporter supports manual-storage [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes on circuits.

<span id="relnotes-unreleased-notes-preview-qpy-features" />

### QPY Features

*   Added a new QPY format version 13 that adds a Qiskit native representation of [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects.

*   QPY ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")) format version 12 has been added, which includes support for memory-owning [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") variables. See [Version 12](qpy#qpy-version-12) for more detail on the format changes.

<span id="relnotes-unreleased-notes-preview-quantum-information-features" />

### Quantum Information Features

*   The performance of [`SparsePauliOp.from_operator()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.from_operator "qiskit.quantum_info.SparsePauliOp.from_operator") has been optimized on top of the algorithm improvements methods introduced in Qiskit 1.0. It is now approximately five times faster than before for fully dense matrices, taking approximately 40ms to decompose a 10q operator involving all Pauli terms.

*   Added a new argument `assume_unitary` to [`qiskit.quantum_info.Operator.power()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.power "qiskit.quantum_info.Operator.power"). When `True`, we use a faster method based on Schur’s decomposition to raise an `Operator` to a fractional power.

*   Added `SparsePauliOperator.to_sparse_list()` to convert an operator into a sparse list format. This works inversely to `SparsePauliOperator.from_sparse_list()`. For example:

    ```c
    from qiskit.quantum_info import SparsePauliOp

    op = SparsePauliOp(["XIII", "IZZI"], coeffs=[1, 2])
    sparse = op.to_sparse_list()  # [("X", [3], 1), ("ZZ", [1, 2], 2)]

    other = SparsePauliOp.from_sparse_list(sparse, op.num_qubits)
    print(other == op)  # True
    ```

*   The performance of [`Pauli.to_label()`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli.to_label "qiskit.quantum_info.Pauli.to_label") has significantly improved for large Paulis.

*   The method [`Operator.power()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.power "qiskit.quantum_info.Operator.power") has a new parameter `branch_cut_rotation`. This can be used to shift the branch-cut point of the root around, which can affect which matrix is chosen as the principal root. By default, it is set to a small positive rotation to make roots of operators with a real-negative eigenvalue (like Pauli operators) more stable against numerical precision differences.

*   A new observable class has been added. [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") represents observables as a sum of terms, similar to [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"), but with two core differences:

    1.  Each complete term is stored as (effectively) a series of `(qubit, bit_term)` pairs, without storing qubits that undergo the identity for that term. This significantly improves the memory usage of observables such as the weighted sum of Paulis $\sum_i c_i Z_i$.
    2.  The single-qubit term alphabet is overcomplete for the operator space; it can represent Pauli operators (like [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp")), but also projectors onto the eigenstates of the Pauli operators, like $\lvert 0\rangle\langle 0\rangle$. Such projectors can be measured on hardware equally as efficiently as their corresponding Pauli operator, but [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") would require an exponential number of terms to represent ${\lvert0\rangle\langle0\rvert}^{\otimes n}$ over $n$ qubits, while [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") needs only a single term.

    You can construct and manipulate [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") using an interface familiar to users of [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp"):

    ```c
    from qiskit.quantum_info import SparseObservable

    obs = SparseObservable.from_sparse_list([
      ("XZY", (2, 1, 0), 1.5j),
      ("+-", (100, 99), 0.5j),
      ("01", (50, 49), 0.5),
    ])
    ```

    [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") is not currently supported as an input format to the primitives ([`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives")), but we expect to expand these interfaces to include them in the future.

*   Added [`SparseObservable.to_sparse_list()`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable.to_sparse_list "qiskit.quantum_info.SparseObservable.to_sparse_list") to obtain a sparse list representation of a [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable"). For example:

    ```c
    from qiskit.quantum_info import SparseObservable

    obs = SparseObservable.from_list([("+II", 1), ("-II", 1)])
    print(obs.to_sparse_list())  # [("+", [2], 1), ("-", [2], 1)]
    ```

*   Added [`SparseObservable.as_paulis()`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable.as_paulis "qiskit.quantum_info.SparseObservable.as_paulis") to express a sparse observable in terms of Paulis only by expanding all projectors. For example:

    ```c
    from qiskit.quantum_info import SparseObservable

    obs = SparseObservable("+-")
    obs_paulis = obs.as_paulis()  # 1/4 ( II + XI - IX - XX )
    ```

*   Support construction of a [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") from a [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") via the new method `SparsePauliOp.from_sparse_observable`. It is important to remember that [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable")s can efficiently represent projectors, which require an exponential number of terms in the [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp").

*   [`SparseObservable`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable "qiskit.quantum_info.SparseObservable") now supports operator composition using the [`compose()`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable.compose "qiskit.quantum_info.SparseObservable.compose") method, similar to other [`quantum_info`](quantum-info#module-qiskit.quantum_info "qiskit.quantum_info") classes. This is analagous to matrix multiplication, though the method is entirely matrix free.

*   [`SparseObservable.BitTerm`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable.BitTerm "qiskit.quantum_info.SparseObservable.BitTerm") as a new attribute, [`label`](qiskit-quantum-info-sparse-observable#qiskit.quantum_info.SparseObservable.BitTerm.label "qiskit.quantum_info.SparseObservable.BitTerm.label"), which contains the single-character Python string used to represent the term in string labels.

*   The method [`StabilizerState.expectation_value()`](qiskit-quantum-info-stabilizer-state#qiskit.quantum_info.StabilizerState.expectation_value "qiskit.quantum_info.StabilizerState.expectation_value") can now accept an operator of type [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp").

<span id="relnotes-unreleased-notes-preview-synthesis-features" />

### Synthesis Features

*   Port internal binary matrix utils from Python to Rust, including binary matrix multiplication, gaussian elimination, rank calculation, binary matrix inversion, and random invertible binary matrix generation. These functions are not part of the Qiskit API, and porting them to rust improves the performance of certain synthesis methods.

*   [`MCXRecursive`](qiskit-circuit-library-mcx-recursive#qiskit.circuit.library.MCXRecursive "qiskit.circuit.library.MCXRecursive") with $k$ control qubits and a single clean auxiliary qubit now requires at most $16k-8$ CX gates.

*   Port [`synth_permutation_acg()`](synthesis#qiskit.synthesis.synth_permutation_acg "qiskit.synthesis.synth_permutation_acg"), used to synthesize qubit permutations, to Rust. This produces an approximate 3x performance improvement on 1000 qubit circuits.

*   Port [`synth_permutation_basic()`](synthesis#qiskit.synthesis.synth_permutation_basic "qiskit.synthesis.synth_permutation_basic"), used to synthesize qubit permutations, to Rust.

*   Port `synth_cnot_full_pmh()`, used to synthesize a linear function into a CX network, to Rust. This produces approximately 44x speedup, as measured on 100 qubit circuits.

*   The function `synth_cnot_full_pmh()` now allows choosing the (heuristically) optimal `section_size` by setting it to `None`. Then, a value is chosen which attempts to minimize the upper bound on the number of CX gates, that is $\alpha \log_2(n)$ where $n$ is the number of qubits and $\alpha \approx 0.56$.

*   The function [`synth_clifford_bm()`](synthesis#qiskit.synthesis.synth_clifford_bm "qiskit.synthesis.synth_clifford_bm") was ported to Rust. Recall that this function optimally synthesizes [`Clifford`](qiskit-quantum-info-clifford#qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") operators on 1, 2 or 3 qubits with respect to the number of CX-gates. This leads to a significant increase in performance. For Cliffords over 3 qubits, the speedup in on the order of 80 times.

*   The function [`synth_clifford_greedy()`](synthesis#qiskit.synthesis.synth_clifford_greedy "qiskit.synthesis.synth_clifford_greedy") that synthesizes [`Clifford`](qiskit-quantum-info-clifford#qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") operators was ported to Rust, leading to a significant increase in performance for all numbers of qubits. For Cliffords over 50 qubits, the speedup is on the order of 1000 times.

*   Port [`synth_permutation_depth_lnn_kms()`](synthesis#qiskit.synthesis.synth_permutation_depth_lnn_kms "qiskit.synthesis.synth_permutation_depth_lnn_kms"), used to synthesize permutations for linear connectivity, to Rust.

*   Added synthesis functions [`synth_mcx_gray_code()`](synthesis#qiskit.synthesis.synth_mcx_gray_code "qiskit.synthesis.synth_mcx_gray_code") and [`synth_mcx_noaux_v24()`](synthesis#qiskit.synthesis.synth_mcx_noaux_v24 "qiskit.synthesis.synth_mcx_noaux_v24") that synthesize multi-controlled X gates. These functions do not require additional ancilla qubits.

*   Added synthesis functions [`synth_c3x()`](synthesis#qiskit.synthesis.synth_c3x "qiskit.synthesis.synth_c3x") and [`synth_c4x()`](synthesis#qiskit.synthesis.synth_c4x "qiskit.synthesis.synth_c4x") that synthesize 3-controlled and 4-controlled X-gates respectively.

*   Add a synthesis function [`synth_mcx_n_dirty_i15()`](synthesis#qiskit.synthesis.synth_mcx_n_dirty_i15 "qiskit.synthesis.synth_mcx_n_dirty_i15") that synthesizes a multi-controlled X gate with $k$ controls using $k - 2$ dirty ancillary qubits producing a circuit with at most $8 * k - 6$ CX gates, by Iten et. al. (arXiv:1501.06911).

*   Add a synthesis function [`synth_mcx_n_clean_m15()`](synthesis#qiskit.synthesis.synth_mcx_n_clean_m15 "qiskit.synthesis.synth_mcx_n_clean_m15") that synthesizes a multi-controlled X gate with $k$ controls using $k - 2$ clean ancillary qubits producing a circuit with at most $6 * k - 6$ CX gates, by Maslov (arXiv:1508.03273).

*   Add a synthesis function [`synth_mcx_1_clean_b95()`](synthesis#qiskit.synthesis.synth_mcx_1_clean_b95 "qiskit.synthesis.synth_mcx_1_clean_b95") that synthesizes a multi-controlled X gate with $k$ controls using a single clean ancillary qubit producing a circuit with at most $16 * k - 8$ CX gates, by Barenco et al. (arXiv:quant-ph/9503016).

*   Added [`adder_qft_d00()`](synthesis#qiskit.synthesis.adder_qft_d00 "qiskit.synthesis.adder_qft_d00"), [`adder_ripple_c04()`](synthesis#qiskit.synthesis.adder_ripple_c04 "qiskit.synthesis.adder_ripple_c04"), and [`adder_ripple_v95()`](synthesis#qiskit.synthesis.adder_ripple_v95 "qiskit.synthesis.adder_ripple_v95") to synthesize the adder gates, [`ModularAdderGate`](qiskit-circuit-library-modular-adder-gate#qiskit.circuit.library.ModularAdderGate "qiskit.circuit.library.ModularAdderGate"), `AdderGate`, and [`FullAdderGate`](qiskit-circuit-library-full-adder-gate#qiskit.circuit.library.FullAdderGate "qiskit.circuit.library.FullAdderGate").

*   Added [`multiplier_cumulative_h18()`](synthesis#qiskit.synthesis.multiplier_cumulative_h18 "qiskit.synthesis.multiplier_cumulative_h18") and [`multiplier_qft_r17()`](synthesis#qiskit.synthesis.multiplier_qft_r17 "qiskit.synthesis.multiplier_qft_r17") to synthesize the [`MultiplierGate`](qiskit-circuit-library-multiplier-gate#qiskit.circuit.library.MultiplierGate "qiskit.circuit.library.MultiplierGate").

*   Added [`synth_mcmt_vchain()`](synthesis#qiskit.synthesis.synth_mcmt_vchain "qiskit.synthesis.synth_mcmt_vchain") to synthesize the multi-control multi-target gate with a linear number of Toffoli gates and k-1 auxiliary qubits for k control qubits, along with the high-level synthesis plugin [`MCMTSynthesisVChain`](qiskit-transpiler-passes-synthesis-hls-plugins-mcmt-synthesis-v-chain#qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisVChain "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisVChain").

*   Added a high-level synthesis plugin structure for the [`MCMTGate`](qiskit-circuit-library-mcmt-gate#qiskit.circuit.library.MCMTGate "qiskit.circuit.library.MCMTGate"), including the [`MCMTSynthesisNoAux`](qiskit-transpiler-passes-synthesis-hls-plugins-mcmt-synthesis-no-aux#qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisNoAux "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisNoAux") (for no auxiliary qubits), the aforementioned [`MCMTSynthesisVChain`](qiskit-transpiler-passes-synthesis-hls-plugins-mcmt-synthesis-v-chain#qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisVChain "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisVChain") (using `num_control - 1` auxiliary qubits), and the [`MCMTSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-mcmt-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.MCMTSynthesisDefault") to let the compiler choose the optimal decomposition.

*   The function [`random_clifford()`](quantum-info#qiskit.quantum_info.random_clifford "qiskit.quantum_info.random_clifford") was ported to Rust, improving the runtime by a factor of 3.

*   Added [`ProductFormula.expand()`](qiskit-synthesis-product-formula#qiskit.synthesis.ProductFormula.expand "qiskit.synthesis.ProductFormula.expand") which allows to view the expansion of a product formula in a sparse Pauli format.

*   Added the plugin structure for the [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"). The default plugin, [`PauliEvolutionSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-pauli-evolution-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisDefault"), constructs circuit as before, but faster as it internally uses Rust. The larger the circuit (e.g. by the Hamiltonian size, the number of timesteps, or the Suzuki-Trotter order), the higher the speedup. For example, a 100-qubit Heisenberg Hamiltonian with 10 timesteps and a 4th-order Trotter formula is now constructed \~9.4x faster. The new plugin, [`PauliEvolutionSynthesisRustiq`](qiskit-transpiler-passes-synthesis-hls-plugins-pauli-evolution-synthesis-rustiq#qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisRustiq "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisRustiq"), uses the synthesis algorithm that is described in the paper “Faster and shorter synthesis of Hamiltonian simulation circuits” by de Brugière and Martiel ([https://arxiv.org/abs/2404.03280](https://arxiv.org/abs/2404.03280)) and is implemented in [https://github.com/smartiel/rustiq-core](https://github.com/smartiel/rustiq-core). For example:

    ```c
    from qiskit.circuit import QuantumCircuit
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.circuit.library import PauliEvolutionGate
    from qiskit.compiler import transpile
    from qiskit.transpiler.passes import HLSConfig

    op = SparsePauliOp(["XXX", "YYY", "IZZ"])
    qc = QuantumCircuit(4)
    qc.append(PauliEvolutionGate(op), [0, 1, 3])
    config = HLSConfig(PauliEvolution=[("rustiq", {"upto_phase": False})])
    tqc = transpile(qc, basis_gates=["cx", "u"], hls_config=config)
    tqc.draw(output='mpl')
    ```

    This code snippet uses the `"rustiq"` plugin to synthesize [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") objects in the quantum circuit qc. The plugin is called with the additional option `"upto_phase" = False` allowing to obtain smaller circuits at the expense of possibly not preserving the global phase. For the full list of supported options, see documentation for [`PauliEvolutionSynthesisRustiq`](qiskit-transpiler-passes-synthesis-hls-plugins-pauli-evolution-synthesis-rustiq#qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisRustiq "qiskit.transpiler.passes.synthesis.hls_plugins.PauliEvolutionSynthesisRustiq").

*   Port :func: .synth\_cz\_depth\_line\_mr to Rust. This function synthesizes a CZ circuit for linear nearest neighbor (LNN) connectivity, based on the Maslov and Roetteler method. On a 350x350 binary matrix, the Rust implementation yields a speedup of about 30 times.

*   Port :func: .synth\_permutation\_reverse\_lnn\_kms to Rust, which synthesizes a reverse permutation for linear nearest-neighbor architecture using the Kutin, Moulton, Smithline method.

*   Added the `wrap` keyword argument to the [`ProductFormula`](qiskit-synthesis-product-formula#qiskit.synthesis.ProductFormula "qiskit.synthesis.ProductFormula") classes which (when enabled) wraps individual Pauli evolution terms. This can be useful when visualizing circuits.

*   Added a new argument `preserve_order` to [`ProductFormula`](qiskit-synthesis-product-formula#qiskit.synthesis.ProductFormula "qiskit.synthesis.ProductFormula"), which allows re-ordering the Pauli terms in the Hamiltonian before the product formula expansion, to compress the final circuit depth. By setting this to `False`, a term of form

$$
Z_0 Z_1 + X_1 X_2 + Y_2 Y_3
$$

    will be re-ordered to

$$
Z_0 Z_1 + Y_2 Y_3 + X_1 X_2
$$

    which will lead to the `RZZ` and `RYY` rotations being applied in parallel, instead of three sequential rotations in the first part.

    This option can be set via the plugin interface:

    ```c
    from qiskit import QuantumCircuit, transpile
    from qiskit.circuit.library import PauliEvolutionGate
    from qiskit.quantum_info import SparsePauliOp
    from qiskit.synthesis.evolution import SuzukiTrotter
    from qiskit.transpiler.passes import HLSConfig

    op = SparsePauliOp(["XXII", "IYYI", "IIZZ"])
    time, reps = 0.1, 1

    synthesis = SuzukiTrotter(order=2, reps=reps)
    hls_config = HLSConfig(PauliEvolution=[("default", {"preserve_order": False})])

    circuit = QuantumCircuit(op.num_qubits)
    circuit.append(PauliEvolutionGate(op, time), circuit.qubits)

    tqc = transpile(circuit, basis_gates=["u", "cx"], hls_config=hls_config)
    print(tqc.draw())
    ```

*   Add a [`TwoQubitControlledUDecomposer`](qiskit-synthesis-two-qubit-controlled-u-decomposer#qiskit.synthesis.TwoQubitControlledUDecomposer "qiskit.synthesis.TwoQubitControlledUDecomposer") that decomposes any two-qubit unitary in terms of basis two-qubit fractional gates, such as [`RZZGate`](qiskit-circuit-library-rzz-gate#qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") (or two-gates gates which are locally equivalent to [`RZZGate`](qiskit-circuit-library-rzz-gate#qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate") up to single qubit gates).

    For example:

    ```c
    from qiskit.circuit.library import RZZGate
    from qiskit.synthesis import TwoQubitControlledUDecomposer
    from qiskit.quantum_info import random_unitary

    unitary = random_unitary(4, seed=1)
    decomposer = TwoQubitControlledUDecomposer(RZZGate, euler_basis="ZXZ")
    circ = decomposer(unitary)
    circ.draw(output='mpl')
    ```

*   Added synthesis functions [`synth_integer_comparator_2s()`](synthesis#qiskit.synthesis.synth_integer_comparator_2s "qiskit.synthesis.synth_integer_comparator_2s") and [`synth_integer_comparator_greedy()`](synthesis#qiskit.synthesis.synth_integer_comparator_greedy "qiskit.synthesis.synth_integer_comparator_greedy") to compile gates implementing an integer comparison, such as represented by [`IntegerComparatorGate`](qiskit-circuit-library-integer-comparator-gate#qiskit.circuit.library.IntegerComparatorGate "qiskit.circuit.library.IntegerComparatorGate"). The corresponding high-level synthesis plugins are [`IntComparatorSynthesis2s`](qiskit-transpiler-passes-synthesis-hls-plugins-int-comparator-synthesis-2-s#qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesis2s "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesis2s") and [`IntComparatorSynthesisNoAux`](qiskit-transpiler-passes-synthesis-hls-plugins-int-comparator-synthesis-no-aux#qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisNoAux "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisNoAux"). To let the compiler select the optimal decomposition based on the availably auxiliary qubits, use [`IntComparatorSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-int-comparator-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.IntComparatorSynthesisDefault").

*   Added [`synth_weighted_sum_carry()`](synthesis#qiskit.synthesis.synth_weighted_sum_carry "qiskit.synthesis.synth_weighted_sum_carry") to synthesize [`WeightedSumGate`](qiskit-circuit-library-weighted-sum-gate#qiskit.circuit.library.WeightedSumGate "qiskit.circuit.library.WeightedSumGate") objects. This is currently the only available synthesis method, with the corresponding high-level synthesis plugin [`WeightedSumSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-weighted-sum-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.WeightedSumSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.WeightedSumSynthesisDefault").

*   The standard equivalence library has additional equivalences for [`CSGate`](qiskit-circuit-library-cs-gate#qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate") and [`CSdgGate`](qiskit-circuit-library-c-sdg-gate#qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate"). When transpiling to the \[“cx”, “u”] basis set, the [`BasisTranslator`](qiskit-transpiler-passes-basis-translator#qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") transpiler pass now uses 2 [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") gates instead of 3 for [`CSdgGate`](qiskit-circuit-library-c-sdg-gate#qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate"), and in addition reduces the number of single-qubit gates in both cases.

<span id="relnotes-unreleased-notes-preview-transpiler-features" />

### Transpiler Features

*   Added a new import path option for [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager"), so that it can now be imported as:

    ```c
    from qiskit import generate_preset_pass_manager
    ```

    instead of having to type the full path:

    ```c
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    ```

    The function is also importable from the [`qiskit.transpiler`](transpiler#module-qiskit.transpiler "qiskit.transpiler") module as:

    ```c
    from qiskit.transpiler import generate_preset_pass_manager
    ```

*   Added a new user config file option `sabre_all_threads` and a corresponding environment variable `QISKIT_SABRE_ALL_THREADS`. When this flag is set the preset pass managers will run the [`SabreLayout`](qiskit-transpiler-passes-sabre-layout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") and [`SabreSwap`](qiskit-transpiler-passes-sabre-swap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") transpiler passes using all the available CPUs on the local system. Using this option is a tradeoff between determinism of output between different computers and potentially better output with fewer [`SwapGate`](qiskit-circuit-library-swap-gate#qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate")s.

    These transpiler passes run multiple random trials in parallel and pick the output which results in the fewest [`SwapGate`](qiskit-circuit-library-swap-gate#qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate")s. As a rule of thumb, if you run more trials, this provides the algorithm more opportunities to find a better result. By default, the preset pass managers use a fixed number of trials, in this release 5 trials for levels 0 and 1, and 20 trials for levels 2 and 3, but these numbers may change in future releases (and were different in historical releases). Using a fixed number of trials results in deterministic results regardless of the local system, because even with a fixed seed if you were to default to the number of local CPUs available the results would different when running between different computers.

    If the default number of trials for a given optimization level is higher than the number of local CPUs it will use the optimization level default which is higher.

*   The `optimization_level` argument for the [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") function is now optional. If it’s not specified it will default to using optimization level 2. As the argument is now optional, the first positional argument has been expanded to enable passing a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") or a [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") as the first argument for more convenient construction. For example:

    ```c
    from qiskit.transpiler.preset_passmanager import generate_preset_pass_manager
    from qiskit.providers.fake_provider import GenericBackendV2

    backend = GenericBackendV2(100)

    generate_preset_pass_manager(backend.Target)
    ```

    will construct a default pass manager for the 100 qubit :class\`.GenericBackendV2\` instance.

*   Added a new pass [`Split2QUnitaries`](qiskit-transpiler-passes-split-2-q-unitaries#qiskit.transpiler.passes.Split2QUnitaries "qiskit.transpiler.passes.Split2QUnitaries") that iterates over all two-qubit gates or unitaries in a circuit and replaces them with two single-qubit unitaries, if possible without introducing errors, i.e. the two-qubit gate/unitary is actually a (kronecker) product of single-qubit unitaries.

*   The passes [`Collect2qBlocks`](qiskit-transpiler-passes-collect-2-q-blocks#qiskit.transpiler.passes.Collect2qBlocks "qiskit.transpiler.passes.Collect2qBlocks"), [`ConsolidateBlocks`](qiskit-transpiler-passes-consolidate-blocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") and [`Split2QUnitaries`](qiskit-transpiler-passes-split-2-q-unitaries#qiskit.transpiler.passes.Split2QUnitaries "qiskit.transpiler.passes.Split2QUnitaries") have been added to the `init` stage of the preset pass managers with optimization level 2 and optimization level 3. The modification of the init stage should allow for a more efficient routing for quantum circuits that either:

    > *   contain two-qubit unitaries/gates that are actually a product of single-qubit gates
    > *   contain multiple two-qubit gates in a continuous block of two-qubit gates.

    In the former case, the routing of the two-qubit gate can simply be skipped as no real interaction between a pair of qubits occurs. In the latter case, the lookahead space of routing algorithms is not ‘polluted’ by superfluous two-qubit gates, i.e. for routing it is sufficient to only consider one single two-qubit gate per continuous block of two-qubit gates. These passes are not run if the pass managers target a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") that has a discrete basis gate set, i.e. all basis gates have are not parameterized.

*   Port part of the logic from the `StarPrerouting`, used to find a star graph connectivity subcircuit and replaces it with a linear routing equivalent.

*   The function `star_preroute()` now performs the heavily lifting to transform the dag by in the rust space by taking advantage of the functions `_build_sabre_dag()` and `_apply_sabre_result()`.

*   A new `dt` argument has been added to [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") to match the set of arguments of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). This will allow for the internal conversion of transpilation constraints to a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") representation.

*   Add an argument `matrix_based` to the [`CollectCliffords()`](qiskit-transpiler-passes-collect-cliffords#qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") transpiler pass. If the new parameter `matrix_based=True`, the [`CollectCliffords()`](qiskit-transpiler-passes-collect-cliffords#qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") transpiler pass can collect `RZGate(np.pi/2)` gates and other unitary gates that are [`Clifford()`](qiskit-quantum-info-clifford#qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") gates for certain parameters.

*   The [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") transpiler pass is now run as part of the preset pass managers at optimization levels 2 and 3. The pass is run in the `init` stage and the `optimization` stage, because the optimizations it applies are valid in both stages and the pass is fast to execute.

*   Added multiple high-level-synthesis plugins for synthesizing an [`MCXGate`](qiskit-circuit-library-mcx-gate#qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate"):

    *   [`MCXSynthesisNCleanM15`](qiskit-transpiler-passes-synthesis-hls-plugins-mcx-synthesis-n-clean-m-15#qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNCleanM15 "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNCleanM15"), based on [`synth_mcx_n_clean_m15()`](synthesis#qiskit.synthesis.synth_mcx_n_clean_m15 "qiskit.synthesis.synth_mcx_n_clean_m15").
    *   [`MCXSynthesisNDirtyI15`](qiskit-transpiler-passes-synthesis-hls-plugins-mcx-synthesis-n-dirty-i-15#qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNDirtyI15 "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNDirtyI15"), based on [`synth_mcx_n_dirty_i15()`](synthesis#qiskit.synthesis.synth_mcx_n_dirty_i15 "qiskit.synthesis.synth_mcx_n_dirty_i15").
    *   [`MCXSynthesis1CleanB95`](qiskit-transpiler-passes-synthesis-hls-plugins-mcx-synthesis-1-clean-b-95#qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1CleanB95 "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesis1CleanB95"), based on [`synth_mcx_1_clean_b95()`](synthesis#qiskit.synthesis.synth_mcx_1_clean_b95 "qiskit.synthesis.synth_mcx_1_clean_b95").
    *   [`MCXSynthesisNoAuxV24`](qiskit-transpiler-passes-synthesis-hls-plugins-mcx-synthesis-no-aux-v24#qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNoAuxV24 "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisNoAuxV24"), based on [`synth_mcx_noaux_v24()`](synthesis#qiskit.synthesis.synth_mcx_noaux_v24 "qiskit.synthesis.synth_mcx_noaux_v24").
    *   [`MCXSynthesisGrayCode`](qiskit-transpiler-passes-synthesis-hls-plugins-mcx-synthesis-gray-code#qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisGrayCode "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisGrayCode"), based on [`synth_mcx_gray_code()`](synthesis#qiskit.synthesis.synth_mcx_gray_code "qiskit.synthesis.synth_mcx_gray_code").

    As well:

    *   [`MCXSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-mcx-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.MCXSynthesisDefault"), choosing the most efficient synthesis method based on the number of clean and dirty ancilla qubits available.

    As an example, consider how the transpilation of the following circuit:

    ```c
    from qiskit.circuit import QuantumCircuit
    from qiskit.compiler import transpile

    qc = QuantumCircuit(7)
    qc.x(0)
    qc.mcx([0, 1, 2, 3], [4])
    qc.mcx([0, 1, 2, 3, 4], [5])
    qc.mcx([0, 1, 2, 3, 4, 5], [6])

    transpile(qc)
    ```

    For the first MCX gate, qubits `5` and `6` can be used as clean ancillas, and the best available synthesis method `synth_mcx_n_clean_m15` will get chosen. For the second MCX gate, qubit `6` can be used as a clean ancilla, the method `synth_mcx_n_clean_m15` no longer applies, so the method `synth_mcx_1_clean_b95` will get chosen. For the third MCX gate, there are no ancilla qubits, and the method `synth_mcx_noaux_v24` will get chosen.

*   The [`SabreLayout`](qiskit-transpiler-passes-sabre-layout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") transpiler pass has been updated to run an additional 2 or 3 layout trials by default independently of the `layout_trials` keyword argument’s value. A trivial layout and its reverse are included for all backends, just like the [`DenseLayout`](qiskit-transpiler-passes-dense-layout#qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") trial that was added in 1.2.0. In addition to this, the largest rings on an IBM backend heavy hex connectivity graph are added if the backends are 127, 133, or 156 qubits. This can provide a good starting point for some circuits on these commonly run backends, while for all others it’s just an additional “random trial”.

*   The implementation of the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") has been rewritten in Rust. This rewrite of the Python class should be fully API compatible with the previous Python implementation of the class. While the class was previously implemented using [rustworkx](https://www.rustworkx.org/) and its underlying data graph structure existed in Rust, the implementation of the class and all the data was stored in Python. This new version of [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") stores a Rust native representation for all its data and is fully implemented in Rust. This new implementation should be more efficient in memory usage as it compresses the qubit and clbit representation for instructions at rest. It also enables speed up for transpiler passes as they can fully manipulate a [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") from Rust.

*   A new argument `qubits_initially_zero` has been added to [`qiskit.compiler.transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager"), and to [`PassManagerConfig`](qiskit-transpiler-pass-manager-config#qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig"). If set to `True`, the qubits are assumed to be initially in the state $|0\rangle$, potentially allowing additional optimization opportunities for individual transpiler passes.

*   The constructor for [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass now accepts an additional argument `qubits_initially_zero`. If set to `True`, the pass assumes that the qubits are initially in the state $|0\rangle$. In addition, the pass keeps track of clean and dirty auxiliary qubits throughout the run, and passes this information to plugins via kwargs `num_clean_ancillas` and `num_dirty_ancillas`.

*   Improved handling of ancilla qubits in the [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass. For example, a circuit may have custom gates whose definitions include [`MCXGate`](qiskit-circuit-library-mcx-gate#qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate")s. Now the synthesis algorithms for the inner MCX-gates can use the ancilla qubits available on the global circuit but outside the custom gates’ definitions.

*   Added a new method `DAGCircuit.control_flow_ops()` which provides a fast path to get all the [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") in a [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") that contain a [`ControlFlowOp`](qiskit-circuit-control-flow-op#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp"). This was possible before using the [`DAGCircuit.op_nodes()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.op_nodes "qiskit.dagcircuit.DAGCircuit.op_nodes") method and passing the [`ControlFlowOp`](qiskit-circuit-control-flow-op#qiskit.circuit.ControlFlowOp "qiskit.circuit.ControlFlowOp") class as a filter, but this new function will perform the operation faster.

*   Ported the entirety of the [`Optimize1qGatesDecomposition`](qiskit-transpiler-passes-optimize-1-q-gates-decomposition#qiskit.transpiler.passes.Optimize1qGatesDecomposition "qiskit.transpiler.passes.Optimize1qGatesDecomposition") transpiler pass to Rust. This improves the runtime performance of the pass between 5x to 10x.

*   Added a Rust implementation of [`CommutationAnalysis`](qiskit-transpiler-passes-commutation-analysis#qiskit.transpiler.passes.CommutationAnalysis "qiskit.transpiler.passes.CommutationAnalysis") in `analyze_commutations()`.

*   Port most of the logic of the transpiler pass [`ElidePermutations`](qiskit-transpiler-passes-elide-permutations#qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations") to Rust.

*   Added a new transpiler pass, [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") that is used to remove gates that are equivalent to an identity up to some tolerance. For example if you had a circuit like:

    > ![\_images/release\_notes-3.png](/images/api/qiskit-c/release_notes-3.avif)

    running the pass would eliminate the [`CPhaseGate`](qiskit-circuit-library-c-phase-gate#qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate"):

    > ```python
    > from qiskit.circuit import QuantumCircuit
    > from qiskit.transpiler.passes import RemoveIdentityEquivalent
    >
    > qc = QuantumCircuit(2)
    > qc.cp(1e-20, 0, 1)
    >
    > removal_pass = RemoveIdentityEquivalent()
    > result = removal_pass(qc)
    > result.draw("mpl")
    > ```
    >
    > ![\_images/release\_notes-4.png](/images/api/qiskit-c/release_notes-4.avif)

*   The the [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") class has been reimplemented in Rust. This retains the same functionality as before but is now significantly in most cases.

*   The `ConsolidateGates` pass will now run the equivalent of the [`Collect2qBlocks`](qiskit-transpiler-passes-collect-2-q-blocks#qiskit.transpiler.passes.Collect2qBlocks "qiskit.transpiler.passes.Collect2qBlocks") pass internally if it was not run in a pass manager prior to the pass. Previously it was required that [`Collect2qBlocks`](qiskit-transpiler-passes-collect-2-q-blocks#qiskit.transpiler.passes.Collect2qBlocks "qiskit.transpiler.passes.Collect2qBlocks") or [`Collect1qRuns`](qiskit-transpiler-passes-collect-1-q-runs#qiskit.transpiler.passes.Collect1qRuns "qiskit.transpiler.passes.Collect1qRuns") were run prior to [`ConsolidateBlocks`](qiskit-transpiler-passes-consolidate-blocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") for [`ConsolidateBlocks`](qiskit-transpiler-passes-consolidate-blocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") to do anything. By doing the collection internally the overhead of the pass is reduced. If [`Collect2qBlocks`](qiskit-transpiler-passes-collect-2-q-blocks#qiskit.transpiler.passes.Collect2qBlocks "qiskit.transpiler.passes.Collect2qBlocks") or [`Collect1qRuns`](qiskit-transpiler-passes-collect-1-q-runs#qiskit.transpiler.passes.Collect1qRuns "qiskit.transpiler.passes.Collect1qRuns") are run prior to [`ConsolidateBlocks`](qiskit-transpiler-passes-consolidate-blocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") the collected runs by those passes from the property set are used and there is no change in behavior for the pass.

*   The [`RemoveDiagonalGatesBeforeMeasure`](qiskit-transpiler-passes-remove-diagonal-gates-before-measure#qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure "qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure") transpiler pass has been upgraded to include more diagonal gates: [`PhaseGate`](qiskit-circuit-library-phase-gate#qiskit.circuit.library.PhaseGate "qiskit.circuit.library.PhaseGate"), [`CPhaseGate`](qiskit-circuit-library-c-phase-gate#qiskit.circuit.library.CPhaseGate "qiskit.circuit.library.CPhaseGate"), [`CSGate`](qiskit-circuit-library-cs-gate#qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate"), [`CSdgGate`](qiskit-circuit-library-c-sdg-gate#qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate") and [`CCZGate`](qiskit-circuit-library-ccz-gate#qiskit.circuit.library.CCZGate "qiskit.circuit.library.CCZGate"). In addition, the code of the [`RemoveDiagonalGatesBeforeMeasure`](qiskit-transpiler-passes-remove-diagonal-gates-before-measure#qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure "qiskit.transpiler.passes.RemoveDiagonalGatesBeforeMeasure") was ported to Rust, and is now x20 faster for a 20 qubit circuit.

*   Added support for two-qubit fractional basis gates, such as [`RZZGate`](qiskit-circuit-library-rzz-gate#qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate"), to the [`ConsolidateBlocks`](qiskit-transpiler-passes-consolidate-blocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") transpiler pass. The decomposition itself is done using the [`TwoQubitControlledUDecomposer`](qiskit-synthesis-two-qubit-controlled-u-decomposer#qiskit.synthesis.TwoQubitControlledUDecomposer "qiskit.synthesis.TwoQubitControlledUDecomposer").

    For example:

    ```c
    from qiskit import QuantumCircuit
    from qiskit.transpiler import generate_preset_pass_manager
    from qiskit.transpiler.passes import ConsolidateBlocks

    qc = QuantumCircuit(2)
    qc.rzz(0.1, 0, 1)
    qc.rzz(0.2, 0, 1)
    consolidate_pass = ConsolidateBlocks(basis_gates=["rz", "rzz", "sx", "x", "rx"])
    block = consolidate_pass(qc)  # consolidate the circuit into a single unitary block
    block.draw(output='mpl')

    pm = generate_preset_pass_manager(
        optimization_level=2, basis_gates=["rz", "rzz", "sx", "x", "rx"]
    )
    tqc = pm.run(qc)  # synthesizing the circuit into basis gates
    tqc.draw(output='mpl')
    ```

*   Added support for two-qubit fractional basis gates, such as [`RZZGate`](qiskit-circuit-library-rzz-gate#qiskit.circuit.library.RZZGate "qiskit.circuit.library.RZZGate"), to the [`UnitarySynthesis`](qiskit-transpiler-passes-unitary-synthesis#qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass. The decomposition is done using the [`TwoQubitControlledUDecomposer`](qiskit-synthesis-two-qubit-controlled-u-decomposer#qiskit.synthesis.TwoQubitControlledUDecomposer "qiskit.synthesis.TwoQubitControlledUDecomposer"), and supports both standard and custom basis gates.

    For example:

    ```c
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import random_unitary
    from qiskit.transpiler.passes import UnitarySynthesis
    from qiskit.converters import circuit_to_dag, dag_to_circuit

    unitary = random_unitary(4, seed=1)
    qc = QuantumCircuit(2)
    qc.append(unitary, [0, 1])
    dag = circuit_to_dag(qc)
    circ = UnitarySynthesis(basis_gates=['rzz', 'rx', 'rz']).run(dag)
    dag_to_circuit(circ).draw(output='mpl')
    ```

*   Added a new transpiler pass, `LightCone` that is used to get the lightcone of a circuit when measuring a subset of qubits or a specific Pauli string. For example if you had a circuit like:

    > ![\_images/release\_notes-5.png](/images/api/qiskit-c/release_notes-5.avif)

    running the pass would eliminate the gates that do not affect the outcome.

    > ```python
    > from qiskit.transpiler.passes.optimization.light_cone import LightCone
    > from qiskit.transpiler.passmanager import PassManager
    > from qiskit.circuit import QuantumCircuit
    >
    > qc = QuantumCircuit(3,1)
    > qc.h(range(3))
    > qc.cx(0,1)
    > qc.cx(2,1)
    > qc.h(range(3))
    > qc.measure(0,0)
    >
    > pm = PassManager([LightCone()])
    > new_circuit = pm.run(qc)
    > new_circuit.draw("mpl")
    > ```
    >
    > ![\_images/release\_notes-6.png](/images/api/qiskit-c/release_notes-6.avif)

*   Added a new argument `max_block_width` to the class `BlockCollector` and to the transpiler passes [`CollectLinearFunctions`](qiskit-transpiler-passes-collect-linear-functions#qiskit.transpiler.passes.CollectLinearFunctions "qiskit.transpiler.passes.CollectLinearFunctions") and [`CollectCliffords`](qiskit-transpiler-passes-collect-cliffords#qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords"). This argument allows to restrict the maximum number of qubits over which a block of nodes is defined.

    For example:

    ```c
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler.passes import CollectLinearFunctions

    qc = QuantumCircuit(5)
    qc.h(0)
    qc.cx(0, 1)
    qc.cx(1, 2)
    qc.cx(2, 3)
    qc.cx(3, 4)

    # Collects all CX-gates into a single block 
    qc1 = CollectLinearFunctions()(qc)
    qc1.draw(output='mpl')

    # Collects CX-gates into two blocks of width 3 
    qc2 = CollectLinearFunctions(max_block_width=3)(qc)
    qc2.draw(output='mpl')
    ```

*   Added a new option, `collect_from_back`, to [`CollectMultiQBlocks`](qiskit-transpiler-passes-collect-multi-q-blocks#qiskit.transpiler.passes.CollectMultiQBlocks "qiskit.transpiler.passes.CollectMultiQBlocks"). When set to `True`, the blocks are collected in the reverse direction, from the outputs towards the inputs of the circuit. The blocks are still reported following the normal topological order. This leads to an additional flexibility provided by the pass, and additional optimization opportunities when combined with a circuit resynthesis method.

*   Added a new argument `approximation_degree` to [`CommutationAnalysis`](qiskit-transpiler-passes-commutation-analysis#qiskit.transpiler.passes.CommutationAnalysis "qiskit.transpiler.passes.CommutationAnalysis"), which allows setting the approximation threshold for when gates are said to commute. See the class docstring for more information.

*   A new transpiler pass, [`ContractIdleWiresInControlFlow`](qiskit-transpiler-passes-contract-idle-wires-in-control-flow#qiskit.transpiler.passes.ContractIdleWiresInControlFlow "qiskit.transpiler.passes.ContractIdleWiresInControlFlow"), is available from [`qiskit.transpiler.passes`](transpiler-passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes"). This pass removes qubits from control-flow blocks if the semantics allow this, and the qubit is idle throughout the control-flow operation. Previously, the routing stage of the preset pass managers might have done this as an accidental side-effect of how they worked, but the behavior is now more properly placed in an optimization pass.

*   A new [routing plugin stage](transpiler#transpiler-preset-stage-routing) is added, called `"default"`. In Qiskit 2.0, this is simply an alias for the previous default `"sabre"`. The underlying default algorithm may change over the course of the Qiskit 2.x series for some or all targets, but you can always set `routing_method="sabre"` explicitly to maintain the current behavior.

*   A new [translation plugin stage](transpiler#transpiler-preset-stage-translation) is added, called `"default"`. In Qiskit 2.0, this is simply an alias for the previous default `"translator"`. The underlying default algorithm may change over the course of the Qiskit 2.x series for some or all targets, but you can always set `translation_method="translator"` explicitly to maintain the current behavior.

*   The [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass now synthesizes objects of type [`AnnotatedOperation`](qiskit-circuit-annotated-operation#qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") via the plugin interface.

*   [`PassManager.run()`](qiskit-transpiler-pass-manager#qiskit.transpiler.PassManager.run "qiskit.transpiler.PassManager.run") now accepts a `property_set` argument, which can be set to a [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping "(in Python v3.13)")-like object to provide the initial values of the pipeline’s [`PropertySet`](qiskit-passmanager-property-set#qiskit.passmanager.PropertySet "qiskit.passmanager.PropertySet"). This can be used to recommence a partially applied compilation, or to reuse certain analysis from a prior compilation in a new place.

*   The scheduling passes [`PadDelay`](qiskit-transpiler-passes-pad-delay#qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") and [`PadDynamicalDecoupling`](qiskit-transpiler-passes-pad-dynamical-decoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") has new arguments on their constructors `target` and `durations` these are used to specify the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") or [`InstructionDurations`](qiskit-transpiler-instruction-durations#qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") respectively. This is required to provide the durations for the instructions in the circuit when this pass is run.

*   Added a new method to the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") class has a new method, [`seconds_to_dt()`](qiskit-transpiler-target#qiskit.transpiler.Target.seconds_to_dt "qiskit.transpiler.Target.seconds_to_dt"). This is used to translate a duration in seconds to a number of discretized time steps of the system time resolution specified in the [`Target.dt`](qiskit-transpiler-target#qiskit.transpiler.Target.dt "qiskit.transpiler.Target.dt") attribute. This is typically useful for converting the [`InstructionProperties.duration`](qiskit-transpiler-instruction-properties#qiskit.transpiler.InstructionProperties.duration "qiskit.transpiler.InstructionProperties.duration") value to units of `dt`.

*   The `synth_cnot_depth_line_kms()` pass was ported into rust, with preliminary benchmarks pointing at a factor of 20x speedup.

*   The `synth_cx_cz_depth_line_my()` pass was ported into rust, with preliminary benchmarks pointing at a factor of 70x speedup.

*   The [`Split2QUnitaries`](qiskit-transpiler-passes-split-2-q-unitaries#qiskit.transpiler.passes.Split2QUnitaries "qiskit.transpiler.passes.Split2QUnitaries") transpiler pass has been upgraded to handle the case where the unitary in consideration can be written as a SWAP gate and two 1-qubit gates. In this case, it splits the unitary and also applies virtual swapping similar to what is done in [`ElidePermutations`](qiskit-transpiler-passes-elide-permutations#qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations"). This functionality can be controlled with a new argument, `split_swap`, on the constructor of :class\`.Split2QUnitaries\` which can be used to disable splitting swap equivalent gates.

<span id="relnotes-unreleased-notes-preview-visualization-features" />

### Visualization Features

*   The user configuration file has a new option `circuit_idle_wires`, which takes a Boolean value. This allows users to set their preferred default behavior of the `idle_wires` option of the circuit drawers [`QuantumCircuit.draw()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw") and [`circuit_drawer()`](qiskit-visualization-circuit-drawer#qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer"). For example, adding a section to `~/.qiskit/settings.conf` with:

    ```text
    [default]
    circuit_idle_wires = false
    ```

    will change the default to display the bits in reverse order.

*   The [`timeline_drawer()`](qiskit-visualization-timeline-drawer#qiskit.visualization.timeline_drawer "qiskit.visualization.timeline_drawer") visualization function has a new argument `target`, used to specify a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") object for the visualization. By default the function used the `Instruction.duration` to get the duration of a given instruction, but specifying the target will leverage the timing details inside the target instead.

*   The text and [Matplotlib](https://matplotlib.org) circuit drawers ([`QuantumCircuit.draw()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw")) have minimal support for displaying expressions involving manual real-time variables. The [`Store`](circuit#qiskit.circuit.Store "qiskit.circuit.Store") operation and the variable initializations are not yet supported; for large-scale dynamic circuits, we recommend using the OpenQASM 3 export capabilities ([`qasm3.dumps()`](qasm-3#qiskit.qasm3.dumps "qiskit.qasm3.dumps")) to get a textual representation of a circuit.

<span id="relnotes-unreleased-notes-preview-misc-features" />

### Misc. Features

*   Added a new build-time environment variable `QISKIT_NO_CACHE_GATES` which when set to a value of `1` (i.e. `QISKIT_NO_CACHE_GATES=1`) which decreases the memory overhead of a [`CircuitInstruction`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") and [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") object at the cost of decreased runtime on multiple accesses to [`CircuitInstruction.operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation") and [`DAGOpNode.op`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.op "qiskit.dagcircuit.DAGOpNode.op"). If this environment variable is set when building the Qiskit python package from source the caching of the return of these attributes will be disabled.

*   [`qiskit.utils`](utils#module-qiskit.utils "qiskit.utils") now contains utilities to provide better control and inspection of Qiskit’s [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "(in Python v3.13)") parallelization settings. In particular, one can now use [`should_run_in_parallel()`](utils#qiskit.utils.should_run_in_parallel "qiskit.utils.should_run_in_parallel") to query whether [`parallel_map()`](utils#qiskit.utils.parallel_map "qiskit.utils.parallel_map") (and pass managers) will launch subprocesses for suitable inputs, and use the context manager [`should_run_in_parallel.override()`](utils#qiskit.utils.should_run_in_parallel.override "qiskit.utils.should_run_in_parallel.override") to temporarily override most system and user configuration around this decision.

    An additional function, [`default_num_processes()`](utils#qiskit.utils.default_num_processes "qiskit.utils.default_num_processes") reads the default maximum number of subprocesses that Qiskit will use for process-based parallelism.

*   A new environment variable, `QISKIT_IGNORE_USER_SETTINGS`, now controls whether to read the user settings file on `import qiskit`. If set to the string `true`, the settings file will not be read. This is useful for isolating certain instances of Qiskit from the system environment, such as for testing.

<span id="relnotes-unreleased-notes-preview-known-issues" />

### Known Issues

*   Versions of Qiskit before 1.2.4 will not be able to load QPY files dumped using [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump"), even with `version` set appropriately, if:

    *   there are unbound [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")s in the QPY file,
    *   the `use_symengine=True` flag was set (which is the default in Qiskit >= 1.0.0) in [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump"),
    *   the version of `symengine` installed in the generating and loading environments are not within the same minor version.

    This applies regardless of the version of Qiskit used in the generation (at least up to Qiskit 1.2.4 inclusive).

    If you want to maximize compatibility with older versions of Qiskit, you should set `use_symengine=False`. Newer versions of Qiskit should not require this.

*   QPY files from the Qiskit 0.45 series can, under a very specific and unlikely set of circumstances, fail to load with any newer version of Qiskit, including Qiskit 1.2.4. The criteria are:

    *   the [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") or `ScheduleBlock` to be dumped contained unbound [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects,
    *   the installed version of `symengine` was in the 0.9 series (which was the most recent release during the support window of Qiskit 0.45),
    *   the `use_symengine=True` flag was set (which was *not* the default).

    Later versions of Qiskit used during generation are not affected, because they required newer versions than `symengine` 0.9.

    In this case, you can recover the QPY file by reloading it with an environment with Qiskit 0.45.3 and `symengine` 0.9.2 installed. Then, use [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") with `use_symengine=False` to re-export the file. This will then be readable by any newer version of Qiskit.

*   When using QPY formats 10, 11, or 12 there is a dependency on the version of `symengine` installed in the payload for serialized `ParamerExpression` if there is mismatched version of the installed `symengine` package between the environment that generated the payload with [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") and the installed version that is trying to load the payload with [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load"). If this is encountered you will need to install the symengine version from the error message emitted to load the payload. QPY format version >= 13 (or \< 10) will not have this issue and it is recommended if you’re serializing [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects as part of your circuit or any `ScheduleBlock` objects you use version 13 to avoid this issue in the future.

<span id="relnotes-unreleased-notes-preview-upgrade-notes" />

### Upgrade Notes

*   The supported versions of [symengine](https://pypi.org/project/symengine/) have been pre-emptively capped at \< 0.14.0 (which is expected to be the next minor version, as of this release of Qiskit). This has been done to protect against a potential incompatibility in [`qpy`](qpy#module-qiskit.qpy "qiskit.qpy") when serializing [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects. The serialization used in [QPY Format](qpy#qpy-format) versions 10, 11, and 12 for [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects is tied to the symengine version used to generate it, and there is the potential for a future symengine release to not be compatible. This upper version cap is to prevent a future release of symengine causing incompatibilities when trying to load QPY files using `qpy.load`.

*   When using [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2"), circuit metadata is no longer cleared before passing circuits to the `run()` method of the wrapped [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") instance.

*   The following classes now use the $\sqrt{X}$ operation to diagonalize the Pauli-Y operator: [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"), [`EvolvedOperatorAnsatz`](qiskit-circuit-library-evolved-operator-ansatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz"), [`PauliFeatureMap`](qiskit-circuit-library-pauli-feature-map#qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap"). Previously, these classes used either $H S$ or $R_X(-\pi/2)$ as basis transformation. Using the $\sqrt{X}$ operation, represented by the [`SXGate`](qiskit-circuit-library-sx-gate#qiskit.circuit.library.SXGate "qiskit.circuit.library.SXGate") is more efficient as it uses only a single gate implemented as singleton.

*   The minimum supported version of Python is now 3.9, this has been raised from the previous minimum support version of 3.8. This change was necessary because the upstream cPython project no longer supports Python 3.8.

*   Qiskit no longer supports Linux i686 and 32 bit Windows. Starting in Qiskit 2.0 a 64 bit platform is needed to run Qiskit. The user base for 32bit architectures is relatively small and as Qiskit continues to focus on improving performance to handle the increased scale in the complexity of quantum computing hardware maintaining support for 32 bit platforms is proving increasingly difficult. This coupled with the larger scientific/numeric Python community’s trend away from 32 bit platform support maintaining support for 32bit platforms is no longer viable. Qiskit 1.x will still continue to support 32 bit platforms, but starting in this 2.0.0 release Qiskit no longer supports these platforms, will not publish pre-compiled binaries for these platforms any longer, and there is no longer any guarantee of being able to build from source on 32 bit platforms.

*   The minimum supported Rust version for building Qiskit from source is now 1.79. This has been raised from the previous minimum supported Rust version of 1.70 in the Qiskit 1.x release series.

*   Increased the minimum threshold for when gates are assumed to be the identity in [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") from machine epsilon to `1e-12` to account for round-off errors in the fidelity calculation and for consistency with the other classes, such as [`CommutationAnalysis`](qiskit-transpiler-passes-commutation-analysis#qiskit.transpiler.passes.CommutationAnalysis "qiskit.transpiler.passes.CommutationAnalysis") and [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition").

*   Updated the metric used to check commutations in [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker"). Two gates are assumed to commute if the average gate fidelity of the commutation is above `1 - 1e-12`. This value is chosen to account for round-off errors in the fidelity calculation and for consistency with [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") and [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition"). See the class docstring for more information.

*   `BlueprintCircuit.copy_empty_like()` now returns an empty [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") with the same number of qubits/clbits and the same metadata as the original circuit, instead of a `BlueprintCircuit`. This change is to mitigate unexpected behavior where dealing with an “empty” copy of a blueprint circuit would re-build the circuit data. Note that `BlueprintCircuit.copy()` still returns a `BlueprintCircuit`. Related: [#13535](https://github.com/Qiskit/qiskit/issues/13535)

*   Qiskit Pulse has been completely removed in this release, following its deprecation in Qiskit 1.3. This include all pulse module files, pulse visualization functionality, support for `ScheduleBlock` and pulse-gate serialization/deserialization capability in QPY, calibrations management in [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") and [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and pulse-based fake backends. For more details about the removed components related to pulse, see the corresponding sections below.

    Note that Pulse migration to Qiskit Dynamics, as was the initial plan following the deprecation of Pulse, has been put on hold due to Qiskit Dynamics development priorities. Users wanting to use Qiskit Pulse as a frontend to supporting backends or in other uses-cases can still use it via Qiskit versions prior to 2.0, which include Pulse functionality.

*   The functions `sequence` and `schedule` from the [`compiler`](compiler#module-qiskit.compiler "qiskit.compiler") module have been removed following their deprecation in Qiskit 1.3. They relied on being able to translate circuits to pulse using backend definitions, a capability that is no longer present. For this reason they have been removed with no proposed alternative. Note that this removals relate to the Pulse package which is also being removed in Qiskit 2.0.

<span id="relnotes-unreleased-notes-preview-circuits-upgrade-notes" />

### Circuits Upgrade Notes

*   The `annotated` argument of the [`Gate.control()`](qiskit-circuit-gate#qiskit.circuit.Gate.control "qiskit.circuit.Gate.control") method is now `None`, which allows Qiskit to choose whether to annotate a controlled operation. If the concrete implementation (`annotated=False`) is available, it will be returned by default. Otherwise, the annotated implementation will be returned (`annotated=True`). This allows, for example, to defer the synthesis of controlled, parameterized gates.

*   The [`Operation`](qiskit-circuit-operation#qiskit.circuit.Operation "qiskit.circuit.Operation") instances of [`DAGOpNode.op`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.op "qiskit.dagcircuit.DAGOpNode.op") being returned will not necessarily share a common reference to the underlying object anymore. This was never guaranteed to be the case and mutating the [`op`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.op "qiskit.dagcircuit.DAGOpNode.op") directly by reference was unsound and always likely to corrupt the dag’s internal state tracking Due to the internal refactor of the [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to store standard gates in rust the output object from [`DAGOpNode.op`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.op "qiskit.dagcircuit.DAGOpNode.op") will now likely be a copy instead of a shared instance. If you need to mutate an element should ensure that you either do:

    ```c
    op = dag_node.op
    op.params[0] = 3.14159
    dag_node.op = op
    ```

    or:

    ```c
    op = dag_node.op
    op.params[0] = 3.14159
    dag.substitute_node(dag_node, op)
    ```

    instead of doing something like:

    ```c
    dag_node.op.params[0] = 3.14159
    ```

    which will not work for any standard gates in this release. It would have likely worked by chance in a previous release but was never an API guarantee.

*   The [`Operation`](qiskit-circuit-operation#qiskit.circuit.Operation "qiskit.circuit.Operation") instances of [`CircuitInstruction.operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation") being returned will not necessarily share a common reference to the underlying object anymore. This was never guaranteed to be the case and mutating the [`operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation") directly by reference was unsound and always likely to corrupt the circuit, especially when parameters were in use. Due to the internal refactor of the QuantumCircuit to store standard gates in rust the output object from [`CircuitInstruction.operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation") will now likely be a copy instead of a shared instance. If you need to mutate an element in the circuit (which is strongly **not** recommended as it’s inefficient and error prone) you should ensure that you do:

    ```c
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(1)
    qc.p(0)

    op = qc.data[0].operation
    op.params[0] = 3.14

    qc.data[0] = qc.data[0].replace(operation=op)
    ```

    instead of doing something like:

    ```c
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(1)
    qc.p(0)

    qc.data[0].operation.params[0] = 3.14
    ```

    which will not work for any standard gates in this release. It would have likely worked by chance in a previous release but was never an API guarantee.

*   The [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") class will generate circuits with different unitary matrices and permutations for a given seed value from the previous Qiskit release. This is due to using a new internal random number generator for the circuit generation that will generate the circuit more quickly. If you need an exact circuit with the same seed you can use the previous release of Qiskit and generate the circuit with the `flatten=True` argument and export the circuit with [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") and then load it with this release.

*   [`Bit`](circuit#qiskit.circuit.Bit "qiskit.circuit.Bit") and [`Register`](circuit#qiskit.circuit.Register "qiskit.circuit.Register") as well as their subclassess are no longer guaranteed to be comparable using `is` checks, due to conversions to and from Python which may re-allocate each instance exposed to Python.

*   [`Bit`](circuit#qiskit.circuit.Bit "qiskit.circuit.Bit") and [`Register`](circuit#qiskit.circuit.Register "qiskit.circuit.Register") (and their subclasses) can no longer be subclassed. This was never intended to be supported behavior, and doing so would cause unspecified behavior in Qiskit. It is no longer possible to do this as an implementation detail of the classes.

*   It is no longer possible to create instances of the base [`Bit`](circuit#qiskit.circuit.Bit "qiskit.circuit.Bit") and [`Register`](circuit#qiskit.circuit.Register "qiskit.circuit.Register") classes is no longer possible. Directly instantiating these classes was clearly documented as something that was **not** supported and being able to do it was was just an implementation artifact of how the class heirarchy in previous releases. Starting in this release it is no longer possible to do this.

*   The [`PhaseOracle`](qiskit-circuit-library-phase-oracle#qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") no longer relies on the tweedledum library but might not be synthesized as effectively as before. [`BitFlipOracleGate`](qiskit-circuit-library-bit-flip-oracle-gate#qiskit.circuit.library.BitFlipOracleGate "qiskit.circuit.library.BitFlipOracleGate") was added as an alternative to directly synthesizing `BooleanExpression`, as this class is removed in Qiskit 2.0. A [`PhaseOracleGate`](qiskit-circuit-library-phase-oracle-gate#qiskit.circuit.library.PhaseOracleGate "qiskit.circuit.library.PhaseOracleGate") was added and will replace [`PhaseOracle`](qiskit-circuit-library-phase-oracle#qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") in Qiskit 3.0.

    The interface of [`PhaseOracle`](qiskit-circuit-library-phase-oracle#qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") was simplified; it no longer accepts a synthesizer parameter, and the expression parameter can only be a string; ClassicalElement has been deprecated in Qiskit 1.4.

    [`PhaseOracle`](qiskit-circuit-library-phase-oracle#qiskit.circuit.library.PhaseOracle "qiskit.circuit.library.PhaseOracle") is used exactly as before:

    ```python
    from qiskit.circuit.library.phase_oracle import PhaseOracle
    bool_expr = "(x0 & x1 | ~x2) & x4"
    oracle = PhaseOracle(bool_expr)
    print(oracle)
    ```

    ```text
    q_0: ─o──■──■─
          │  │  │ 
    q_1: ─┼──o──■─
          │  │  │ 
    q_2: ─o──o──┼─
          │  │  │ 
    q_3: ─■──■──■─
    ```

*   The method [`QuantumCircuit.measure_active()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.measure_active "qiskit.circuit.QuantumCircuit.measure_active") has changed the name of the classical register it creates, as the previous name conflicted with an OpenQASM reserved word. Instead of `measure`, it is now called `meas`, aligning with the register name used by [`measure_all()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.measure_all "qiskit.circuit.QuantumCircuit.measure_all").

*   [`DAGCircuit.control_flow_op_nodes()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.control_flow_op_nodes "qiskit.dagcircuit.DAGCircuit.control_flow_op_nodes") now always returns a list, even if empty. Previously, it returned `None` if empty, and never returned the empty list, which required special handling. If you need to explicitly test for emptiness in both Qiskit 1.x and 2.x, you can do:

    ```c
    control_flow_nodes = dag.control_flow_op_nodes()
    if not control_flow_nodes:
        # There are no control-flow nodes.
        pass
    ```

*   The generic control method for gates now avoids attempting to translate gates into a supported basis, if the gate is already supported. This can slightly change the synthesis of the controlled gate, although it should not increase the two-qubit gate count.

*   Converting a quantum circuit to a gate with [`converters.circuit_to_instruction()`](converters#qiskit.converters.circuit_to_instruction "qiskit.converters.circuit_to_instruction") fails properly when given circuit contains control flow instructions.

*   The internal function `qiskit.circuit.add_control.add_control` was removed, as it is not part of the public API. It had fragile preconditions to uphold and was a common source of bugs. Uses of `add_control(SomeGate(...), ...)` should change to `SomeGate(...).control(...)` using [`Gate.control()`](qiskit-circuit-gate#qiskit.circuit.Gate.control "qiskit.circuit.Gate.control") instead, which is far safer.

*   The [`ParameterExpression.sympify()`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression.sympify "qiskit.circuit.ParameterExpression.sympify") method can now raise a `MissingOptionalLibrary` exception if `sympy` is not installed. In the Qiskit 1.x releases sympy was always guaranteed to be installed, but starting in 2.x this is no longer a hard requirement and may only be needed if you are using this method. As this functionality explicitly requires `sympy` you will need to ensure you have `sympy` installed to use the method.

*   The deprecated argument `.dag` for [`DAGNode`](qiskit-dagcircuit-dag-node#qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") and its subclasses [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode"), [`DAGOutNode`](qiskit-dagcircuit-dag-out-node#qiskit.dagcircuit.DAGOutNode "qiskit.dagcircuit.DAGOutNode"), and [`DAGInNode`](qiskit-dagcircuit-dag-in-node#qiskit.dagcircuit.DAGInNode "qiskit.dagcircuit.DAGInNode"). `dag` was optional parameter when constructing these objects that was unused and ignored since the 1.3.0 release. The parameter was deprecated in 1.4 and has now been is removed.

*   The [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods:

    *   `cast`
    *   `cbit_argument_conversion`
    *   `cls_instances`
    *   `cls_prefix`
    *   `qbit_argument_conversion`

    have been removed, following their deprecation in Qiskit 1.2. These methods were internal helper functions, and never intended to be public API. No replacement is provided.

*   The deprecated attributes for [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") and [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate"): `duration` and `unit` have been removed. This includes setting the `unit` or `duration` arguments for any [`qiskit.circuit.Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") or subclass. These attributes were deprecated in Qiskit 1.3.0 and were used to attach a custom execution duration and unit for that duration to an individual instruction. However, the source of truth of the duration of a gate is the [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") which contains the duration for each instruction supported on the backend. The duration of an instruction is not something that’s typically user adjustable and is an immutable property of the backend. If you were previously using this capability to experiment with different durations for gates you can mutate the [`InstructionProperties.duration`](qiskit-transpiler-instruction-properties#qiskit.transpiler.InstructionProperties.duration "qiskit.transpiler.InstructionProperties.duration") field in a given [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") to set a custom duration for an instruction on a backend (the unit is always in seconds in the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target")).

*   The deprecated attribute for [`qiskit.circuit.Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") and [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate"): `condition` has been removed. These attributes were deprecated in the 1.3.0 release. This functionality has been superseded by the [`IfElseOp`](qiskit-circuit-if-else-op#qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") class which can be used to describe a classical condition in a circuit.

*   The deprecated methods for [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") and [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate"): `c_if` and `condition_bits` have been removed. These methods were deprecated in the 1.3.0 release. This functionality has been superseded by the [`IfElseOp`](qiskit-circuit-if-else-op#qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") class which can be used to describe a classical condition in a circuit. For example, a circuit previously using `Instruction.c_if()` like:

    ```c
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.x(0).c_if(0, 1)
    qc.z(1.c_if(1, 0)
    qc.measure(0, 0)
    qc.measure(1, 1)
    ```

    can be rewritten as:

    ```c
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    with expected.if_test((expected.clbits[0], True)):
        qc.x(0)
    with expected.if_test((expected.clbits[1], False)):
        qc.z(1)
    qc.measure(0, 0)
    qc.measure(1, 1)
    ```

*   The deprecated method `InstructionSet.c_if` has been removed. This method was deprecated in the 1.3.0 release. This functionality has been superseded by the [`IfElseOp`](qiskit-circuit-if-else-op#qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") class which can be used to describe a classical condition in a circuit.

*   As part of Pulse removal in Qiskit 2.0, the `calibrations` property has been removed from the [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"), [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and [`DAGDependency`](qiskit-dagcircuit-dag-dependency#qiskit.dagcircuit.DAGDependency "qiskit.dagcircuit.DAGDependency") classes. In addition, the method `has_calibration_for` has been removed from the [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") and [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") classes and `add_calibration` has been removed from [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   The `classical_function` was removed. This module was dependent on the tweedledum library which is no longer compatible with newer versions of Python. As an alternative, the [`PhaseOracleGate`](qiskit-circuit-library-phase-oracle-gate#qiskit.circuit.library.PhaseOracleGate "qiskit.circuit.library.PhaseOracleGate") and [`BitFlipOracleGate`](qiskit-circuit-library-bit-flip-oracle-gate#qiskit.circuit.library.BitFlipOracleGate "qiskit.circuit.library.BitFlipOracleGate") classes can be used to generate circuits from boolean expressions.

*   The internal representation of [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") has changed when they’re added to a [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). The object stored in the circuit will not necessarily share a common reference to the object added to the circuit anymore. This was never guaranteed to be the case and mutating the [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") object directly or by reference was unsound and always likely to corrupt the circuit, especially if you changed the matrix. If you need to mutate an element in the circuit (which is **not** recommended as it’s inefficient and error prone) you should ensure that you do something like:

    ```c
    from qiskit.circuit import QuantumCircuit
    from qiskit.quantum_info import random_unitary
    from qiskit.circuit.library import UnitaryGate
    import numpy as np

    qc = QuantumCircuit(2)
    qc.unitary(np.eye(2, dtype=complex))

    new_op = UnitaryGate(random_unitary(2))
    qc.data[0] = qc.data[0].replace(operation=new_op)
    ```

    This also applies to [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") too, but you can use [`DAGCircuit.substitute_node()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") instead.

*   The [`CircuitInstruction.params`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.params "qiskit.circuit.CircuitInstruction.params") attribute for a [`CircuitInstruction`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") that contains an [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") for its [`operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation") will no longer contain the underlying unitary matrix for the gate. This is because the internal representation of the gate no longer treats the matrix object as a parameter. If you need to access the matrix of the gate you can do this either via the [`CircuitInstruction.matrix`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.matrix "qiskit.circuit.CircuitInstruction.matrix") or the [`UnitaryGate.params`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate.params "qiskit.circuit.library.UnitaryGate.params") field of the [`CircuitInstruction.operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation").

<span id="relnotes-unreleased-notes-preview-primitives-upgrade-notes" />

### Primitives Upgrade Notes

*   [`BitArray.slice_bits()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.slice_bits "qiskit.primitives.BitArray.slice_bits") and [`BitArray.slice_shots()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.slice_shots "qiskit.primitives.BitArray.slice_shots") will now raise `IndexError` when indices are out of bounds. They used to raise `ValueError` in the case.

*   `BitArray.__getitem__()` will now raise `IndexError` when indices are out of bounds or the number of dimensions of indices does not match that of BitArray. They used to raise `ValueError` in the case.

*   As a consequence of the removal of the `BackendV1` model, the [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2") and [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2") classes no longer accept inputs of type `BackendV1` in their `backend` input argument.

*   Primitive V1 implementations and V1-exclusive non-versioned type aliases, deprecated in Qiskit 1.2, have been removed. These interfaces have been superseded by their V2 counterparts. The removal includes the following classes implementing V1 interfaces:

    *   `Estimator`, in favor of the V2 equivalent, [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator")
    *   `Sampler`, in favor of the V2 equivalent, [`StatevectorSampler`](qiskit-primitives-statevector-sampler#qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler")
    *   `BackendEstimator`, in favor of the V2 equivalent, [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2")
    *   `BackendSampler`, in favor of the V2 equivalent, [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2")

    As well as the following non-versioned type aliases:

    *   `BaseEstimator`, alias for [`BaseEstimatorV1`](qiskit-primitives-base-estimator-v1#qiskit.primitives.BaseEstimatorV1 "qiskit.primitives.BaseEstimatorV1")
    *   `BaseSampler`, alias for [`BaseSamplerV1`](qiskit-primitives-base-sampler-v1#qiskit.primitives.BaseSamplerV1 "qiskit.primitives.BaseSamplerV1")

    This removal does NOT affect the explicitly-versioned `BaseEstimatorV1` and `BaseSamplerV1` abstract interface definitions or related result and job classes, which have been kept to maintain backward compatibitily.

    In addition, the following utility functions have been removed. These functions were only used in Primitive V1 implementations:

    *   `init_circuit()`, to initialize a circuit from a [`Statevector`](qiskit-quantum-info-statevector#qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector"), use [`QuantumCircuit.initialize()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.initialize "qiskit.circuit.QuantumCircuit.initialize") instead,
    *   `init_observable()`, use the constructor of [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") instead,
    *   `final_measurement_mapping()`, use `QuantumCircuit.layout()` and [`SparsePauliOp.apply_layout()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.apply_layout "qiskit.quantum_info.SparsePauliOp.apply_layout") to adjust an operator for a layout. Otherwise, use `mthree.utils.final_measurement_mapping`. See [Mthree Utility functions](https://qiskit-extensions.github.io/mthree/apidocs/utils.html) for details.

<span id="relnotes-unreleased-notes-preview-providers-upgrade-notes" />

### Providers Upgrade Notes

*   Implementations of [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") (and `BackendV1`) may desire to update their [`run()`](qiskit-providers-backend-v2#qiskit.providers.BackendV2.run "qiskit.providers.BackendV2.run") methods to eagerly reject inputs containing typed classical variables (see [`qiskit.circuit.classical`](circuit-classical#module-qiskit.circuit.classical "qiskit.circuit.classical")) and the [`Store`](circuit#qiskit.circuit.Store "qiskit.circuit.Store") instruction, if they do not have support for them. The new [`Store`](circuit#qiskit.circuit.Store "qiskit.circuit.Store") instruction is treated by the transpiler as an always-available “directive” (like [`Barrier`](circuit#qiskit.circuit.Barrier "qiskit.circuit.Barrier")); if your backends do not support this won’t be caught by the [`transpiler`](transpiler#module-qiskit.transpiler "qiskit.transpiler").

    See [Real-time variables](providers#providers-guide-real-time-variables) for more information.

*   The `configuration` method of [`BasicSimulator`](qiskit-providers-basic-provider-basic-simulator#qiskit.providers.basic_provider.BasicSimulator "qiskit.providers.basic_provider.BasicSimulator") has been removed following its deprecation in Qiskit 1.3. This method returned a `BackendConfiguration` instance, and this class was part of the deprecated `BackendV1` workflow. The individual configuration elements can be retrieved directly from the backend or from the contained [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") instance `(backend.target)`.

*   The `run_experiment` method of [`BasicSimulator`](qiskit-providers-basic-provider-basic-simulator#qiskit.providers.basic_provider.BasicSimulator "qiskit.providers.basic_provider.BasicSimulator") has also been removed. This method took an instance of the `QasmQobjExperiment` class as an input argument, and the class has been deprecated since Qiskit 1.2.

*   The `BackendV1` model has been removed following its deprecation in Qiskit 1.2.0. This includes the `BackendV1` class as well as related modules and utils, as they have been superseded by the [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") model. The list of removed items includes:

    *   `BackendV1` class: the core of the removed model

    *   All elements in qiskit/providers/models, as they were used to represent components of the `BackendV1` model:

        > *   `BackendConfiguration`
        > *   `BackendProperties`
        > *   `BackendStatus`
        > *   `QasmBackendConfiguration`
        > *   `PulseBackendConfiguration`
        > *   `UchannelLO`
        > *   `GateConfig`
        > *   `PulseDefaults`
        > *   `PulseQobjDef`
        > *   `Command`
        > *   `GateProperties`
        > *   `Nduv`
        > *   `JobStatus`: This class has been superseded by the more widely used [`JobStatus`](qiskit-providers-job-status#qiskit.providers.JobStatus "qiskit.providers.JobStatus")
        > *   `PulseDefaults`

    *   `BackendV2Converter` class: used to convert from `BackendV1` to [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2")

    *   `convert_to_target` function: used to build a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") instance from legacy `BackendV1` components (such as `BackendConfiguration` or `BackendProperties`)

    *   `BackendPropertyError` and `BackendConfigurationError`: exceptions linked to removed classes

*   The [`BasicSimulator`](qiskit-providers-basic-provider-basic-simulator#qiskit.providers.basic_provider.BasicSimulator "qiskit.providers.basic_provider.BasicSimulator") backend no longer can simulate classical control flow. It only supported using `.c_if()`/`.condition` for modeling control flow, as this has now been removed from Qiskit’s data model it no longer can support control flow.

*   All fake backend classes based on the deprecated `BackendV1` have been removed from the [`providers.fake_provider`](providers-fake-provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module. These classes have been deprecated since Qiskit 1.2 and were part of the deprecated `BackendV1` workflow. Their use in tests has been replaced with the [`GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") class, which allows to create custom instances of [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") that implement a simulated [`BackendV2.run()`](qiskit-providers-backend-v2#qiskit.providers.BackendV2.run "qiskit.providers.BackendV2.run"). The removal affects:

    *   Base classes:

        *   `FakeBackend`
        *   `FakePulseBackend`
        *   `FakeQasmBackend`

    *   Fake backends for special testing purposes: \* `Fake1Q` \* `FakeOpenPulse2Q` \* `FakeOpenPulse3Q`

    *   Legacy fake backends:

        *   `Fake5QV1`
        *   `Fake20QV1`
        *   `Fake7QPulseV1`
        *   `Fake27QPulseV1`
        *   `Fake127QPulseV1`

*   As part of Pulse removal in Qiskit 2.0, the following methods have been removed:

    > *   `qiskit.providers.BackendV2.instruction_schedule_map`
    > *   `qiskit.providers.BackendV2.drive_channel`
    > *   `qiskit.providers.BackendV2.measure_channel`
    > *   `qiskit.providers.BackendV2.acquire_channel`
    > *   `qiskit.providers.BackendV2.control_channel`

*   As part of Pulse removal in Qiskit 2.0, pulse support has been removed from [`GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2"). This includes the ability to initialize the backend with custom calibrations (`calibrate_instructions` argument) and pulse channels information.

*   Removed the abstract base classes `Provider` and `ProviderV1` which have been deprecated since Qiskit 1.1.0. The abstraction provided by these interface definitions were not providing a huge value, solely just the attributes `name`, `backends`, and a `get_backend()` method. A \_provider\_, as a concept, will continue existing as a collection of backends. If you’re implementing a provider currently you can adjust your code by simply removing `ProviderV1` as the parent class of your implementation. As part of this you probably would want to add an implementation of `get_backend` for backwards compatibility. For example:

    ```c
    def get_backend(self, name=None, **kwargs):
      backend = self.backends(name, **kwargs)
      if len(backends) > 1:
        raise QiskitBackendNotFoundError("More than one backend matches the criteria")
      if not backends:
        raise QiskitBackendNotFoundError("No backend matches the criteria")
      return backends[0]
    ```

<span id="relnotes-unreleased-notes-preview-qpy-upgrade-notes" />

### QPY Upgrade Notes

*   The [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") function will now emit format version 13 by default. This means payloads generated with this function by default will only be compatible with Qiskit >= 1.3.0. If you need for the payload to be loaded by a older version of Qiskit you can use the `version` flag on [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") to emit a version compatible with earlier releases of Qiskit. You can refer to [QPY Compatibility](qpy#qpy-compatibility) for more details on this.

*   The value of [`qiskit.qpy.QPY_VERSION`](qpy#qiskit.qpy.QPY_VERSION "qiskit.qpy.QPY_VERSION") is now 12. [`QPY_COMPATIBILITY_VERSION`](qpy#qiskit.qpy.QPY_COMPATIBILITY_VERSION "qiskit.qpy.QPY_COMPATIBILITY_VERSION") is unchanged at 10.

*   The [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function can now raise a `MissingOptionalLibrary` exception if a QPY v10, v11, or v12 payload is passed in that is using symengine symbolic expressions and symengine is not installed. Or if sympy is not installed for any other QPY payload \< v13. In the Qiskit 1.x releases symengine and sympy were always guaranteed to be installed, but starting in 2.x this is no longer a hard requirement and may only be needed if you’re deserializing a QPY file that was generated using symengine. Parsing these QPY payloads requires symengine (0.11.0 or 0.13.0) as it’s usage is baked into the format specification for QPY v10, v11, and v12 so if the payload requires it there is no option but to install a compatible version of symengine. Similarly, sympy was was used for [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") encoding for all QPY versions from 1 through 12.

*   The minimum QPY compatibility version, [`QPY_COMPATIBILITY_VERSION`](qpy#qiskit.qpy.QPY_COMPATIBILITY_VERSION "qiskit.qpy.QPY_COMPATIBILITY_VERSION"), has been raised to 13 from 10 in the 1.x release. This version controls the minimum version of QPY that can be emitted by the [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") function. This means [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") can only emit QPY v13 and v14 in this release. QPY v13 is still compatible with Qiskit 1.3.x and 1.4.x which means payloads can be generated in Qiskit 2.x that can be loaded with the Qiskit 1.x release series still.

    This change was necessary as QPY versions 10 through 12 requires either the sympy and symengine libraries to generate a serialization for [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects, but in Qiskit 2.x neither library is required for the [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") object.

*   With the removal of Pulse in Qiskit 2.0, support for serializing `ScheduleBlock` programs via the [`qiskit.qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") function has been removed. Users can still load payloads containing pulse gates using the [`qiskit.qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function, however those will be treated as opaque custom instructions. Loading `ScheduleBlock` payloads is not supported anymore and will result with a [`QpyError`](qpy#qiskit.qpy.QpyError "qiskit.qpy.QpyError") exception.

<span id="relnotes-unreleased-notes-preview-synthesis-upgrade-notes" />

### Synthesis Upgrade Notes

*   The `atomic_evolution` argument to [`ProductFormula`](qiskit-synthesis-product-formula#qiskit.synthesis.ProductFormula "qiskit.synthesis.ProductFormula") (and its subclasses) has a new function signature. Rather than taking some Pauli operator and time coefficient and returning the evolution circuit, the new function takes in an existing circuit and should append the evolution of the provided Pauli and given time to this circuit. This new implementation benefits from significantly better performance.

*   [`LieTrotter`](qiskit-synthesis-lie-trotter#qiskit.synthesis.LieTrotter "qiskit.synthesis.LieTrotter") and [`SuzukiTrotter`](qiskit-synthesis-suzuki-trotter#qiskit.synthesis.SuzukiTrotter "qiskit.synthesis.SuzukiTrotter") no longer wrap the individually evolved Pauli terms into gate definitions. If you rely on a certain decomposition level of your circuit, you have to remove one level of [`decompose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.decompose "qiskit.circuit.QuantumCircuit.decompose") or add the `wrap=True` keyword argument to your synthesis object.

*   The plugins for [`LinearFunction`](qiskit-circuit-library-linear-function#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") no longer raise an error if another object than [`LinearFunction`](qiskit-circuit-library-linear-function#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") is passed into the `run` method. Instead, `None` is returned, which is consistent with the other plugins. If you relied on this error being raised, you can manually perform an instance-check.

*   The `atomic_evolution` argument to [`ProductFormula`](qiskit-synthesis-product-formula#qiskit.synthesis.ProductFormula "qiskit.synthesis.ProductFormula") (and its subclasses [`QDrift`](qiskit-synthesis-q-drift#qiskit.synthesis.QDrift "qiskit.synthesis.QDrift"), [`LieTrotter`](qiskit-synthesis-lie-trotter#qiskit.synthesis.LieTrotter "qiskit.synthesis.LieTrotter") and `SuzukiTrotter` ) has a new function signature. Rather than taking some Pauli operator and time coefficient and returning the evolution circuit, the new function takes in an existing circuit and should append the evolution of the provided Pauli and given time to this circuit. This new implementation benefits from significantly better performance.

<span id="relnotes-unreleased-notes-preview-transpiler-upgrade-notes" />

### Transpiler Upgrade Notes

*   The default `optimization_level` used by the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function when one is not specified has been changed to level 2. This makes it consistent with the default used by [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") which is used internally by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). Optimization level 2 provides a much better balance between the run time of the function and the optimizations it performs, it’s a better tradeoff to use by default.

    The API of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") remains unchanged because, fundamentally, level 2 and level 1 have the same semantics. If you were previously relying on the implicit default of level 1, you can simply set the argument `optimization_level=1` when you call [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). Similarly you can change the default back in your local environment by using a user config file and setting the `transpile_optimization_level` field to 1.

    The only potential issue is that your transpilation workflow may be relying on an implicit trivial layout (where qubit 0 in the circuit passed to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") is mapped to qubit 0 on the target backend/coupling, 1->1, 2->2, etc.) without specifying `optimization_level=1`, `layout_method="trivial"`, or explicitly setting `initial_layout` when calling [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"). This behavior was a side effect of the preset pass manager construction in optimization level 1 and is not mirrored in level 2. If you need this behavior you can use any of the three options listed previously to make this behavior explicit.

    Similarly, if you were targeting a discrete basis gate set you may encounter an issue using the new default with optimization level 2 (or running explicitly optimization level 3), as the additional optimization passes that run in level 2 and 3 don’t work in all cases with a discrete basis. You can explicitly set `optimization_level=1` manually in this case. In general the transpiler does not currently fully support discrete basis sets and if you’re relying on this you should likely construct a pass manager manually to build a compilation pipeline that will work with your target.

*   The default routing pass used by optimization level 0 for [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") and [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") has been changed from `StochasticSwap` to [`SabreSwap`](qiskit-transpiler-passes-sabre-swap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"). The [`SabreSwap`](qiskit-transpiler-passes-sabre-swap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") pass performs exactly the same function but performs better in both runtime and output quality (in number of swap gates and depth) compared to `StochasticSwap`. For `optimization_level=0` this shouldn’t matter because it’s not expected to run routing for the typical use case of level 0.

    If you were relying on the previous default routing algorithm for any reason you can use the `routing_method` argument for [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") to `"stochastic"` to use the `StochasticSwap` pass.

*   The [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") function has been upgraded to, when possible, internally convert transpiler constraints into a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") instance. If a backend input of type `BackendV1` is provided, it will be converted to [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") to expose its [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target"). This change does not require any user action.

*   [`DAGNode`](qiskit-dagcircuit-dag-node#qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") objects (and its subclasses [`DAGInNode`](qiskit-dagcircuit-dag-in-node#qiskit.dagcircuit.DAGInNode "qiskit.dagcircuit.DAGInNode"), [`DAGOutNode`](qiskit-dagcircuit-dag-out-node#qiskit.dagcircuit.DAGOutNode "qiskit.dagcircuit.DAGOutNode"), and [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode")) no longer return references to the same underlying object from [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") methods. This was never a guarantee before that all returned nodes would be shared reference to the same object, but with the migration of the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") to Rust when a [`DAGNode`](qiskit-dagcircuit-dag-node#qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") a new [`DAGNode`](qiskit-dagcircuit-dag-node#qiskit.dagcircuit.DAGNode "qiskit.dagcircuit.DAGNode") instance is generated on the fly when a node is returned to Python. These objects will evaluate as equal using `==` or similar checks that rely on `__eq__` but will no longer identify as the same object.

*   The [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") instances returned from the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") are no longer shared references to the underlying data stored on the DAG. In previous release it was possible to do something like:

    ```c
    for node in dag.op_nodes():
        node.op = new_op
    ```

    however this type of mutation was always unsound as it could break the DAG’s internal caching and cause corruption of the data structure. Instead you should use the API provided by [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") for mutation such as [`DAGCircuit.substitute_node()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node"), [`DAGCircuit.substitute_node_with_dag()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag"), or `DAGCircuit.contract_node()`. For example the above code block would become:

    ```c
    for node in dag.op_nodes():
      dag.substitute_node(node, new_op)
    ```

    This is similar to an upgrade note from 1.2.0 where this was noted on for mutation of the [`DAGOpNode.op`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode.op "qiskit.dagcircuit.DAGOpNode.op") attribute, not the [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") itself. However in 1.3 this extends to the entire object, not just it’s inner `op` attribute. In general this type of mutation was always unsound and not supported, but could previously have potentially worked in some cases.

*   The [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") now assumes that the qubits are initially in the state $|0\rangle$. To avoid this assumption, one can set the argument `qubits_initially_zero` to `False`.

*   The [routing plugin stage](transpiler#transpiler-preset-stage-routing) name `default` is now reserved for the Qiskit built-in plugin of the same name.

*   The default [routing plugin stage](transpiler#transpiler-preset-stage-routing) is now `"default"`. In Qiskit 2.0, this is simply an alias for the previous default `"sabre"`. The underlying default algorithm may change over the course of the Qiskit 2.x series for some or all targets, but you can always set `routing_method="sabre"` explicitly to maintain the current behavior.

*   The [translation plugin stage](transpiler#transpiler-preset-stage-translation) name `default` is now reserved for the Qiskit built-in plugin of the same name.

*   The default [translation plugin stage](transpiler#transpiler-preset-stage-translation) is now `"default"`. In Qiskit 2.0, this is simply an alias for the previous default `"translator"`. The underlying default algorithm may change over the course of the Qiskit 2.x series for some or all targets, but you can always set `translation_method="translator"` explicitly to maintain the current behavior.

*   The deprecated transpiler passes `ASAPSchedule`, `ALAPSchedule`, `DynamicalDecoupling`, and `AlignMeasures` have been removed. These passes were marked as deprecated. They have been replaced by the [`ALAPScheduleAnalysis`](qiskit-transpiler-passes-alap-schedule-analysis#qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis"), [`ASAPScheduleAnalysis`](qiskit-transpiler-passes-asap-schedule-analysis#qiskit.transpiler.passes.ASAPScheduleAnalysis "qiskit.transpiler.passes.ASAPScheduleAnalysis"), [`PadDynamicalDecoupling`](qiskit-transpiler-passes-pad-dynamical-decoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling"), and [`ConstrainedReschedule`](qiskit-transpiler-passes-constrained-reschedule#qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") passes respectively which can be used instead.

*   In the case that neither a target nor a set of basis gates are specified, the [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass synthesizes circuits with annotated operations with fewer layers of wrappings than before (this happens, for instance, for the circuit produced by [`multiplier_cumulative_h18()`](synthesis#qiskit.synthesis.multiplier_cumulative_h18 "qiskit.synthesis.multiplier_cumulative_h18")).

*   The keyword argument `property_set` is now reserved in [`BasePassManager.run()`](qiskit-passmanager-base-pass-manager#qiskit.passmanager.BasePassManager.run "qiskit.passmanager.BasePassManager.run"), and cannot be used as a `kwarg` that will be forwarded to the subclass’s conversion from the front-end representation to the internal representation.

*   The following deprecated uses of the `BackendProperties` object in the transpilation pipeline have been removed in Qiskit 2.0:

    *   `backend_properties` input argument in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile")
    *   `backend_properties` input argument in [`PassManagerConfig`](qiskit-transpiler-pass-manager-config#qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig")
    *   `backend_properties` input argument in [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager")
    *   `backend_properties` input argument in [`generate_routing_passmanager()`](transpiler-preset#qiskit.transpiler.preset_passmanagers.generate_routing_passmanager "qiskit.transpiler.preset_passmanagers.generate_routing_passmanager")
    *   `backend_properties` input argument in [`generate_translation_passmanager()`](transpiler-preset#qiskit.transpiler.preset_passmanagers.generate_translation_passmanager "qiskit.transpiler.preset_passmanagers.generate_translation_passmanager")
    *   `backend_properties` input argument [`Target.from_configuration()`](qiskit-transpiler-target#qiskit.transpiler.Target.from_configuration "qiskit.transpiler.Target.from_configuration")

    The following passes have also been updated to only accept a `target` instead of:

    *   `backend_prop` input argument in [`DenseLayout`](qiskit-transpiler-passes-dense-layout#qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout")
    *   `properties` input argument in [`VF2Layout`](qiskit-transpiler-passes-vf-2-layout#qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout")
    *   `properties` and `coupling_map` input arguments in [`VF2PostLayout`](qiskit-transpiler-passes-vf-2-post-layout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout")
    *   `backend_props` input argument in [`UnitarySynthesis`](qiskit-transpiler-passes-unitary-synthesis#qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis")

    The `BackendProperties` class has been deprecated since Qiskit 1.2, as it was part of the BackendV1 workflow. Specific instruction properties such as gate errors or durations can be added to a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") upon construction through the [`Target.add_instruction()`](qiskit-transpiler-target#qiskit.transpiler.Target.add_instruction "qiskit.transpiler.Target.add_instruction") method, and communicated to the relevant transpiler passes through the target input argument.

*   As a consequence of the removal of the `BackendV1` model, the accepted input types of the following transpiler objects have been updated:

    > *   The [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") and [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") functions no longer accept inputs of type `BackendV1` in their `backend` input argument.
    > *   The [`Target.from_configuration()`](qiskit-transpiler-target#qiskit.transpiler.Target.from_configuration "qiskit.transpiler.Target.from_configuration") method no longer accepts a `backend_properties` argument
    > *   The `Target.target_to_backend_properties()` method has been removed

*   The [`ResetAfterMeasureSimplification`](qiskit-transpiler-passes-reset-after-measure-simplification#qiskit.transpiler.passes.ResetAfterMeasureSimplification "qiskit.transpiler.passes.ResetAfterMeasureSimplification") transpiler pass now will use an [`IfElseOp`](qiskit-circuit-if-else-op#qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") to condition the execution of the [`XGate`](qiskit-circuit-library-x-gate#qiskit.circuit.library.XGate "qiskit.circuit.library.XGate") instead of setting a `condition` attribute on the gate. This is because the `condition` attribute has been removed from the Qiskit data model.

*   The deprecated `ConvertConditionsToIfOps` transpiler pass has been removed. The underlying `condition` attribute of [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") class has been removed so this transpiler pass no longer had anything to convert from. Instead you should directly use [`IfElseOp`](qiskit-circuit-if-else-op#qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") to classically condition the execution of an operation.

*   The [`PadDelay`](qiskit-transpiler-passes-pad-delay#qiskit.transpiler.passes.PadDelay "qiskit.transpiler.passes.PadDelay") and [`PadDynamicalDecoupling`](qiskit-transpiler-passes-pad-dynamical-decoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling") transpiler passes now require a new argument when constructed. Either `target` or `durations` need to be specified with a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") or [`InstructionDurations`](qiskit-transpiler-instruction-durations#qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") respectively. Without these the passes will not be able to determine the duration of instructions in the circuit and will error. Previously these passes would determine these values from the now removed `duration` attribute of [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") objects.

*   The previously deprecated argument `propagate_condition` on the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") methods [`substitute_node_with_dag()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag") and [`substitute_node()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") has been removed. These arguments were deprecated in Qiskit 1.4.0 and were removed because the larger removal of `Instruction.condition` it no longer served a purpose.

*   The previously deprecated `AlignMeasures` transpiler pass has been removed. This pass was deprecated in Qiskit 1.1.0. Instead the [`ConstrainedReschedule`](qiskit-transpiler-passes-constrained-reschedule#qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") pass should be used. [`ConstrainedReschedule`](qiskit-transpiler-passes-constrained-reschedule#qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") performs the same function and also supports aligning to additional timing constraints.

*   When calling [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") or [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and specifying the `instruction_durations` argument with a list instead of an [`InstructionDurations`](qiskit-transpiler-instruction-durations#qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") object and the list specifies durations in units of `dt` a `dt` parameter is required if scheduling the circuit.

*   Removed the deprecated `DAGNode.sort_key` attribute. This attribute was deprecated in the Qiskit 1.4.0 release. As the lexicographical topological sorting is done internally and rust and the sort key attribute was unused this was removed to remove the overhead from DAG node creation. If you were relying on the sort key you can reproduce it from a given node using something like:

    ```c
    def get_sort_key(node: DAGNode):
        if isinstance(node, (DAGInNode, DAGOutNode)):
            return str(node.wire)
        return ",".join(
            f"{dag.find_bit(q).index:04d}" for q in itertools.chain(node.qargs, node.cargs)
        )
    ```

*   The following [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") input arguments, deprecated since Qiskit 1.3 , have been removed from the API:

    > *   instruction\_durations
    > *   timing\_constraints

    In addition to this, the specification of custom basis gates through the `basis` gate argument of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager"), also deprecated in Qiskit 1.3, is no longer allowed, and a `ValueError` will be raised in these cases.

    The information formerly provided through these can still be specified via the `backend` or `target` arguments. You can build a Target instance with defined instruction durations doing:

    ```c
    Target.from_configuration(..., instruction_durations=...)
    ```

    For specific timing constraints:

    ```c
    Target.from_configuration(..., timing_constraints=...)
    ```

    And for custom basis gates, you can manually add them to the target or use `.from_configuration` with a custom name mapping, for example:

    ```c
    from qiskit.circuit.library import XGate
    from qiskit.transpiler.target import Target

    basis_gates = ["my_x", "cx"]
    custom_name_mapping = {"my_x": XGate()}
    target = Target.from_configuration(
        basis_gates=basis_gates, num_qubits=2, custom_name_mapping=custom_name_mapping
    )
    ```

*   The [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") interfaces now raise a `UserWarning` when providing a `coupling_map` and/or `basis_gates` along with a `backend`. In these cases there are multiple sources of truth, the user intentions are not always clear, and there can be conflicts that [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") may not know how to resolve. In these cases, we highly encourage the creation of a custom target that combines the chosen constraints.

    One of these situations is the specification of a gate with 3 or more qubits in backend or basis\_gates together with a custom coupling map. The coupling map does not provide the necessary connectivity details to be able to determine the action of the gate. In these cases, [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") now raise a `ValueError`.

*   As part of Pulse removal in Qiskit 2.0, all pulse and calibration related functionality in the transpiler has been removed. This includes the following:

    The following passes and function have been removed:

    > *   `qiskit.transpiler.passes.PulseGates` pass
    > *   `qiskit.transpiler.passes.ValidatePulseGates` pass
    > *   `qiskit.transpiler.passes.RXCalibrationBuilder` pass
    > *   `qiskit.transpiler.passes.RZXCalibrationBuilder` pass
    > *   `qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho` pass
    > *   `qiskit.transpiler.passes.EchoRZXWeylDecomposition` pass
    > *   `qiskit.transpiler.passes.NoramlizeRXAngle` pass
    > *   `qiskit.transpiler.passes.rzx_templates()` function

    The `inst_map` argument has been removed from the following elements:

    > *   The [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") and [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") functions
    > *   The [`Target.from_configuration()`](qiskit-transpiler-target#qiskit.transpiler.Target.from_configuration "qiskit.transpiler.Target.from_configuration") method
    > *   The constructor of the [`PassManagerConfig`](qiskit-transpiler-pass-manager-config#qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") class

    Calibration support has been removed:

    > *   `calibration` has been removed from the [`InstructionProperties`](qiskit-transpiler-instruction-properties#qiskit.transpiler.InstructionProperties "qiskit.transpiler.InstructionProperties") ‘s constructor and is no longer a property of that class.
    > *   The `has_calibration`, `get_calibration`, `instruction_schedule_map` and `update_from_instruction_schedule_map` methods have been removed from the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") class.

*   The deprecated `StochasticSwap` transpiler pass, and its associated built-in routing stage plugin “stochastic”, have been removed. These were marked as deprecated in the Qiskit 1.3.0 release. The pass has been superseded by the [`SabreSwap`](qiskit-transpiler-passes-sabre-swap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") which should be used instead as it offers better performance and output quality. For example if the pass was previously invoked via the transpile function such as with:

    ```c
    from qiskit import transpile
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler import CouplingMap
    from qiskit.providers.fake_provider import GenericBackendV2


    qc = QuantumCircuit(4)
    qc.h(0)
    qc.cx(0, range(1, 4))
    qc.measure_all()

    cmap = CouplingMap.from_heavy_hex(3)
    backend = GenericBackendV2(num_qubits=cmap.size(), coupling_map=cmap)

    tqc = transpile(
        qc,
        routing_method="stochastic",
        layout_method="dense",
        seed_transpiler=12342,
        target=backend.target
    )
    ```

    this should be replaced with:

    ```c
    tqc = transpile(
        qc,
        routing_method="sabre",
        layout_method="dense",
        seed_transpiler=12342,
        target=backend.target
    )
    ```

*   The pass `qiskit.transpiler.passes.CXCancellation` was removed. It was deprecated in favor of class:.InverseCancellation, which is more generic. `CXCancellation` is fully semantically equivalent to `InverseCancellation([CXGate()])`.

*   The [`SolovayKitaev`](qiskit-transpiler-passes-solovay-kitaev#qiskit.transpiler.passes.SolovayKitaev "qiskit.transpiler.passes.SolovayKitaev") transpiler pass no longer raises an exception on circuits that contain single-qubit operations without a `to_matrix` method (such as measures, barriers, control-flow operations) or parameterized single-qubit operations, but will leave them unchanged.

*   Plugins for the [translation stage of the preset compiler](transpiler#transpiler-preset-stage-translation) are now required to respect gate directionality in the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") in their output. Previously, [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") would generate a [`PassManager`](qiskit-transpiler-pass-manager#qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") that contained fix-up passes if needed. You must now include these in your own custom stage, if your stage does not guarantee that it respects directionality.

    You can use the [`GateDirection`](qiskit-transpiler-passes-gate-direction#qiskit.transpiler.passes.GateDirection "qiskit.transpiler.passes.GateDirection") pass to perform the same fix-ups that Qiskit used to do. For example:

    ```c
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import GateDirection
    from qiskit.transpiler.preset_passmanagers.plugin import PassManagerStagePlugin

    class YourTranslationPlugin(PassManagerStagePlugin):
        def pass_manager(self, pass_manager_config, optimization_level):
            pm = PassManager([
                # ... whatever your current setup is ...
            ])
            # Add the two-qubit directionality-fixing pass.
            pm.append(GateDirection(
                pass_manager_config.coupling_map,
                pass_manager_config.target,
            ))
            return pm
    ```

*   The [preset pass managers](transpiler#transpiler-preset) no longer populate the implicit `pre_optimization` stage of their output [`StagedPassManager`](qiskit-transpiler-staged-pass-manager#qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager"). You can now safely assign your own [`PassManager`](qiskit-transpiler-pass-manager#qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") to this field. You could previously only append to the existing [`PassManager`](qiskit-transpiler-pass-manager#qiskit.transpiler.PassManager "qiskit.transpiler.PassManager").

*   The default value for the [`generate_routing_passmanager()`](transpiler-preset#qiskit.transpiler.preset_passmanagers.generate_routing_passmanager "qiskit.transpiler.preset_passmanagers.generate_routing_passmanager") argument `seed_transpiler` has changed from `None` to `-1`. This was done because this flag was only used to configure the [`VF2PostLayout`](qiskit-transpiler-passes-vf-2-post-layout#qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") transpiler pass in the output, and for that pass in particular the randomization typically only hurts performance and is not desirable. If you were relying on the previous default value you can restore this behavior by explicitly setting the argument `seed_transpiler=None`. If you were explicitly setting a seed value for this parameter there is no change in behavior.

<span id="relnotes-unreleased-notes-preview-visualization-upgrade-notes" />

### Visualization Upgrade Notes

*   The `idle_wires` parameter in all circuit drawers has been extended with a new option, `"auto"`, which is now the default behavior. If you still want to display wires without instructions, explicitly set `idle_wires=True`.

    When set to `"auto"`, the behavior is as follows: - If the circuit has a defined `.layout` attribute, `idle_wires` is automatically set to `False` (hiding idle wires). - Otherwise, `idle_wires` remains `True` (showing all wires, as previous default).

    Here an example. A circuit without a layout, using `idle_wires="auto"`:

    ```text
    qr_0: ────────
          ┌───┐┌─┐
    qr_1: ┤ H ├┤M├
          └───┘└╥┘
    cr_0: ══════╬═
                ║
    cr_1: ══════╩═
    ```

    Once a layout is applied, `idle_wires="auto"` sets `idle_wires` to `False`, hiding idle wires:

    ```text
              ┌───┐┌─┐
    qr_1 -> 1 ┤ H ├┤M├
              └───┘└╥┘
        cr_1: ══════╩═
    ```

    If you want to display all wires in a laid-out circuit, set `idle_wires=True` explicitly:

    ```text
         qr_0 -> 0 ────────
                   ┌───┐┌─┐
         qr_1 -> 1 ┤ H ├┤M├
                   └───┘└╥┘
    ancilla_0 -> 2 ──────╫─
                         ║
             cr_0: ══════╬═
                         ║
             cr_1: ══════╩═
    ```

    As quantum computers scale to more qubits, even small circuits can produce large circuit representations after transpilation. The `"auto"` setting helps improve readability by hiding unnecessary wires when possible.

*   The [`array_to_latex()`](qiskit-visualization-array-to-latex#qiskit.visualization.array_to_latex "qiskit.visualization.array_to_latex") and [`Operator.draw()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.draw "qiskit.quantum_info.Operator.draw") methods can now raise a `MissingOptionalLibrary` exception if the `sympy` library is not installed. In the Qiskit 1.x releases symengine and sympy were always guaranteed to be installed, but starting in 2.x this is no longer a hard requirement. The latex visualization for a matrix relies on the sympy library, so if you’re using this functionality you should ensure that you have sympy installed.

*   As a consequence of the removal of the `BackendV1` model, the [`plot_gate_map()`](qiskit-visualization-plot-gate-map#qiskit.visualization.plot_gate_map "qiskit.visualization.plot_gate_map"), [`plot_error_map()`](qiskit-visualization-plot-error-map#qiskit.visualization.plot_error_map "qiskit.visualization.plot_error_map") and [`plot_circuit_layout()`](qiskit-visualization-plot-circuit-layout#qiskit.visualization.plot_circuit_layout "qiskit.visualization.plot_circuit_layout") functions no longer accept inputs of type `BackendV1` in their `backend` input argument.

*   The timeline drawer now requires the target argument is specified when called. As instructions no longer contain duration attributes this extra argument is required to specify the durations for all the supported instructions. Without the argument the timeline drawer does not have access to this information.

*   As part of the Pulse removal in Qiskit 2.0, support for pulse drawing via `qiskit.visualization.pulse_drawer` has been removed.

<span id="relnotes-unreleased-notes-preview-misc-upgrade-notes" />

### Misc. Upgrade Notes

*   The minimum version of rustworkx required to run this release has been increased from 0.14.0 to 0.15.0. This is required because Qiskit is now using new functionality added in the rustworkx 0.15.0 release which improves performance.

*   The `deprecate_function` and `deprecate_arguments` decorators had been deprecated since 0.24, released on May 2023, and have been removed in 2.0. Current ``deprecate_func`()`` replaces `@deprecate_function` and current `deprecate_arg()` replaces `@deprecate_arguments`.

*   The `assemble` function and related capabilities (contained in the `assembler` module) have been removed from the codebase following their deprecation in Qiskit 1.2. `assemble` was used to generate `Qobj` in the context of the deprecated `BackendV1` workflow. The conversion is no longer necessary as the transpilation and primitives pipeline handles quantum circuits directly, rendering the `Qobj` obsolete.

    The removal includes the following public API components:

    > *   `qiskit.compiler.assemble` function
    > *   `qiskit.assembler.assemble_circuits` function
    > *   `qiskit.assembler.assemble_schedules` function
    > *   `qiskit.assembler.disassemble` function
    > *   `qiskit.assembler.RunConfig` class
    > *   `qiskit.circuit.Instruction.assemble` method

*   The `Qobj` structure and related classes, deprecated in Qiskit 1.2.0, have been removed. They were introduced as part of the `BackendV1` workflow and are no longer necessary for interacting with [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backends. This removal includes:

    *   `QobjExperimentHeader`
    *   `QobjHeader`
    *   `QasmQobj`
    *   `QasmQobjInstruction`
    *   `QasmQobjExperimentConfig`
    *   `QasmQobjExperiment`
    *   `QasmQobjConfig`
    *   `QasmExperimentCalibrations`
    *   `GateCalibration`
    *   `PulseQobj`
    *   `PulseQobjInstruction`
    *   `PulseQobjExperimentConfig`
    *   `PulseQobjExperiment`
    *   `PulseQobjConfig`
    *   `QobjMeasurementOption`
    *   `PulseLibraryItem`

*   The `MeasLevel` and :class\`.MeasReturnType\` classes, previously defined in `qobj/utils.py`, have been migrated to `result/models.py` following the removal of the `qobj` module. These classes were not part of the public API. The import path has been updated from: `from qiskit.qobj.utils import MeasLevel, MeasReturnType` to: `from qiskit.result import MeasLevel, MeasReturnType`.

*   The use of positional arguments in the constructor of [`Result`](qiskit-result-result#qiskit.result.Result "qiskit.result.Result") has been disabled. Please set all arguments using kwarg syntax, i.e: `Result(backend_name="name", ....)`. In addition to this, the `qobj_id` argument will no longer be used in the construction of the [`Result`](qiskit-result-result#qiskit.result.Result "qiskit.result.Result") internals. It is still possible to set `qobj_id` as a generic kwarg, which will land in the metadata field with the other generic kwargs.

*   As part of Pulse removal in Qiskit 2.0, the `sequence` and `schedule_circuit` functions from `qiskit.scheduler` together with the `ScheduleConfig` class have been removed.

*   The `qiskit.result.mitigation` module has been removed following its deprecation in Qiskit 1.3. The removal includes the `LocalReadoutMitigator` and `CorrelatedReadoutMitigator` classes as well as the associated utils.

    There is no alternative path in Qiskit, as their functionality had been superseded by the mthree package, found in [https://github.com/Qiskit/qiskit-addon-mthree](https://github.com/Qiskit/qiskit-addon-mthree).

<span id="relnotes-unreleased-notes-preview-deprecation-notes" />

### Deprecation Notes

*   The Qiskit Pulse package is being deprecated and will be removed in Qiskit 2.0.0. Pulse-level access is currently only supported on a subset of Eagle devices and not supported on the Heron architecture. Furthermore, newer IBM Quantum architectures will not support pulse-level access. As a consequence, supporting Pulse as a first-class citizen frontend in the Qiskit SDK itself makes little sense going forward. The deprecation includes all pulse code in `qiskit.pulse` as well as functionality dependant or related to pulse such as pulse visualization, serialization and custom calibration support. For more details see the deprecation sections.

    The Pulse package as a whole, along with directly related components in Qiskit, will be moved to the [Qiskit Dynamics](https://github.com/qiskit-community/qiskit-dynamics) repository to further enable pulse and low-level control simulation.

<span id="relnotes-unreleased-notes-preview-circuits-deprecations" />

### Circuits Deprecations

*   The following circuit methods were not intended for public use, but were accidentally left documented in the public API during the 1.0 release. They are now deprecated from Qiskit 1.2 and will be removed in Qiskit 2.0:

    > *   `QuantumCircuit.cast`
    > *   `QuantumCircuit.cls_instances`
    > *   `QuantumCircuit.cls_prefix`
    > *   `QuantumCircuit.cbit_argument_conversion`
    > *   `QuantumCircuit.qbit_argument_conversion`

*   Treating [`CircuitInstruction`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction "qiskit.circuit.CircuitInstruction") as a tuple-like iterable is deprecated, and this legacy path way will be removed in Qiskit 2.0. You should use the attribute-access fields [`operation`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.operation "qiskit.circuit.CircuitInstruction.operation"), [`qubits`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.qubits "qiskit.circuit.CircuitInstruction.qubits"), and [`clbits`](qiskit-circuit-circuit-instruction#qiskit.circuit.CircuitInstruction.clbits "qiskit.circuit.CircuitInstruction.clbits") instead. For example:

    ```c
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])

    # Deprecated.
    for op, qubits, clbits in qc.data:
        pass
    # New style.
    for instruction in qc.data:
        op = instruction.operation
        qubits = instruction.qubits
        clbits = instruction.clbits
    ```

*   Deprecated the `Instruction.condition` attribute and the `Instruction.c_if()` method. They will be removed in Qiskit 2.0, along with any uses in the Qiskit data model. This functionality has been superseded by the [`IfElseOp`](qiskit-circuit-if-else-op#qiskit.circuit.IfElseOp "qiskit.circuit.IfElseOp") class which can be used to describe a classical condition in a circuit. For example, a circuit using `Instruction.c_if()` like:

    ```c
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.x(0).c_if(0, 1)
    qc.z(1.c_if(1, 0)
    qc.measure(0, 0)
    qc.measure(1, 1)
    ```

    can be rewritten as:

    ```c
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    with expected.if_test((expected.clbits[0], True)):
        qc.x(0)
    with expected.if_test((expected.clbits[1], False)):
        qc.z(1)
    qc.measure(0, 0)
    qc.measure(1, 1)
    ```

    The now deprecated `ConvertConditionsToIfOps` transpiler pass can be used to automate this conversion for existing circuits.

*   ## As part of the Qiskit Pulse package deprecation, the following dependencies are deprecated as well:

    *   `qiskit.circuit.QuantumCircuit.calibrations`
    *   `qiskit.circuit.QuantumCircuit.has_calibration_for()`
    *   `qiskit.circuit.QuantumCircuit.add_calibration()`
    *   `qiskit.dagcircuit.DAGCircuit.calibrations`
    *   `qiskit.dagcircuit.DAGCircuit.has_calibration_for()`
    *   `qiskit.dagcircuit.DAGCircuit.add_calibration()`
    *   `qiskit.dagcircuit.DAGDependency.calibrations`

*   The [`QuantumCircuit.unit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.unit "qiskit.circuit.QuantumCircuit.unit") and [`QuantumCircuit.duration`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.duration "qiskit.circuit.QuantumCircuit.duration") attributes have been deprecated and will be removed in Qiskit 2.0.0. These attributes were used to track the estimated duration and unit of that duration to execute on the circuit. However, the values of these attributes were always limited, as they would only be properly populated if the transpiler were run with the correct settings. The duration was also only a guess based on the longest path on the sum of the duration of [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and wouldn’t ever correctly account for control flow or conditionals in the circuit.

*   The [`DAGCircuit.unit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.unit "qiskit.dagcircuit.DAGCircuit.unit") and [`DAGCircuit.duration`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.duration "qiskit.dagcircuit.DAGCircuit.duration") attributes have been deprecated and will be removed in Qiskit 2.0.0. These attributes were used to track the estimated duration and unit of that duration to execute on the circuit. However, the values of these attributes were always limited, as they would only be properly populated if the transpiler were run with the correct settings. The duration was also only a guess based on the longest path on the sum of the duration of [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") and wouldn’t ever correctly account for control flow or conditionals in the circuit.

*   The `Instruction.duration` and `Instruction.unit` attributes have been deprecated and will be removed in Qiskit 2.0.0. This includes setting the `unit` or `duration` arguments for any [`qiskit.circuit.Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") or subclass. These attributes were used to attach a custom execution duration and unit for that duration to an individual instruction. However, the source of truth of the duration of a gate is the [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") which contains the duration for each instruction supported on the backend. The duration of an instruction is not something that’s typically user adjustable and is an immutable property of the backend. If you were previously using this capability to experiment with different durations for gates you can mutate the [`InstructionProperties.duration`](qiskit-transpiler-instruction-properties#qiskit.transpiler.InstructionProperties.duration "qiskit.transpiler.InstructionProperties.duration") field in a given [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") to set a custom duration for an instruction on a backend (the unit is always in seconds in the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target")).

*   The deprecated [`QuantumCircuit.duration`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.duration "qiskit.circuit.QuantumCircuit.duration") attribute was not removed in this release as originally planned, it will be removed as part of the Qiskit 3.0.0 release instead. This functionality has been superseded by the [`QuantumCircuit.estimate_duration()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.estimate_duration "qiskit.circuit.QuantumCircuit.estimate_duration") method which should be used instead.

*   The Multiple-Control-Multiple-Target in `MCMT` is now deprecated and replaced by [`MCMTGate`](qiskit-circuit-library-mcmt-gate#qiskit.circuit.library.MCMTGate "qiskit.circuit.library.MCMTGate"), which is a proper [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate") subclass. Using a gate instead of a circuit allows the compiler to reason about the object at a higher level of abstraction and allows for multiple synthesis plugins.

<span id="relnotes-unreleased-notes-preview-primitives-deprecations" />

### Primitives Deprecations

*   Primitive V1 implementations and V1-exclusive non-versioned type aliases are now deprecated in favor of their V2 counterparts. The deprecation is extended to the following classes implementing V1 interfaces:

    *   `Estimator`, in favor of the V2 equivalent, [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator")
    *   `Sampler`, in favor of the V2 equivalent, [`StatevectorSampler`](qiskit-primitives-statevector-sampler#qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler")
    *   `BackendEstimator`, in favor of the V2 equivalent, [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2")
    *   `BackendSampler`, in favor of the V2 equivalent, [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2")

    As well as the following non-versioned type aliases:

    *   `BaseEstimator`, alias for [`BaseEstimatorV1`](qiskit-primitives-base-estimator-v1#qiskit.primitives.BaseEstimatorV1 "qiskit.primitives.BaseEstimatorV1")
    *   `BaseSampler`, alias for [`BaseSamplerV1`](qiskit-primitives-base-sampler-v1#qiskit.primitives.BaseSamplerV1 "qiskit.primitives.BaseSamplerV1")

    This deprecation does NOT affect the explicitly-versioned `BaseEstimatorV1` and `BaseSamplerV1` abstract interface definitions or related result and job classes.

    In addition, the following utility functions are deprecated:

    *   `init_circuit()`, to initialize a circuit from a [`Statevector`](qiskit-quantum-info-statevector#qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector"), use [`QuantumCircuit.initialize()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.initialize "qiskit.circuit.QuantumCircuit.initialize") instead,
    *   `init_observable()`, use the constructor of [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") instead,
    *   `final_measurement_mapping()`, use `QuantumCircuit.layout()` and [`SparsePauliOp.apply_layout()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.apply_layout "qiskit.quantum_info.SparsePauliOp.apply_layout") to adjust an operator for a layout. Otherwise, use `mthree.utils.final_measurement_mapping`. See [Mthree Utility functions](https://qiskit-extensions.github.io/mthree/apidocs/utils.html) for details.

<span id="relnotes-unreleased-notes-preview-providers-deprecations" />

### Providers Deprecations

*   The `BackendV1` class is deprecated and it will be removed not earlier than the next major release. There are several migration paths available depending on the main purpose of the backend object:

    ```c
    - To expose backend information with no access to execution (just a hardware description), consider constructing a :class:`.Target` directly.
    - To provides access to execution capabilities, consider relying on the primitives interfaces instead.
    - Alternatively, to continue providing simultaneous :class:`.Target` (hardware information) and ``run`` (execution) capabilities, consider moving to :class:`.BackendV2` (see <https://qisk.it/backendV1-to-V2>).
    ```

*   The models in `qiskit.providers.models` are part of the deprecated `BackendV1` workflow and no longer necessary for [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2"). If a user workflow requires these representations it likely relies on deprecated functionality and should be updated to use [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

*   The Qobj structure and related classes are now deprecated, they were introduced as part of the BackendV1 workflow and are no longer necessary for interacting with [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backends. Remote backend interaction should be done via QPY or OpenQASM instead.

*   The `BasicSimulator.configuration()` method is deprecated and will be removed in 2.0.0. This method returned a legacy `providers.models.BackendConfiguration` instance which is part of the deprecated `BackendV1` model. This model has been replaced with [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2"), where the constraints are stored directly in the backend instance or the underlying [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") (`backend.target`).

    Here is a quick guide for accessing the most common `BackendConfiguration` attributes in the `BackendV2` model:””

    > BackendV1 model (deprecated) ————> BackendV2 model —————————- ————— backend.configuration().backend\_name backend.name backend.configuration().backend\_version backend.backend\_version backend.configuration().n\_qubits backend.num\_qubits backend.configuration().num\_qubits backend.num\_qubits backend.configuration().basis\_gates backend.target.operation\_names (\*) backend.configuration().coupling\_map backend.target.build\_coupling\_map() backend.configuration().local No representation backend.configuration().simulator No representation backend.configuration().conditional No representation backend.configuration().open\_pulse No representation backend.configuration().memory No representation backend.configuration().max\_shots No representation

    (\*) Note that `backend.target.operation_names` includes `basis_gates` and additional non-gate instructions, in some implementations it might be necessary to filter the output.

    See [this guide](/migration-guides/qiskit-backendv1-to-v2) for more information on migrating to the `BackendV2` model.

*   ## As part of the Qiskit Pulse package deprecation, all pulse-related functionality in [`qiskit.providers.BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") class is being deprecated. This includes the following methods:

    *   `instruction_schedule_map()`
    *   `drive_channel()`
    *   `measure_channel()`
    *   `acquire_channel()`
    *   `control_channel()`

    Consequently, the corresponding channel methods in the `qiskit.providers.BackendV2Converter` and [`qiskit.providers.fake_provider.GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") classes are being deprecated as well.

    In addition, the pulse\_channels and calibrate\_instructions arguments in the [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") initializer method are being deprecated.

*   The defaults argument is being deprecated from the `qiskit.providers.backend_compat.convert_to_target()` function.

<span id="relnotes-unreleased-notes-preview-qpy-deprecations" />

### QPY Deprecations

*   As part of the Qiskit Pulse package deprecation, serializing a `qiskit.pulse.ScheduleBlock`-based payloads is being deprecated. In particular, passing `qiskit.pulse.ScheduleBlock` objects to the programs argument in the [`qiskit.qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") function is being deprecated.

<span id="relnotes-unreleased-notes-preview-transpiler-deprecations" />

### Transpiler Deprecations

*   The assemble function is now deprecated and will be removed in the 2.0 release. The function was primarily used to create a Qobj, which is no longer necessary in [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2")-based workflows. It was also used for binding parameters, a functionality fully covered by [`assign_parameters()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters").

*   Deprecated `StochasticSwap` which has been superseded by [`SabreSwap`](qiskit-transpiler-passes-sabre-swap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap"). If the class is called from the transpile function, the change would be, for example:

    ```c
    from qiskit import transpile
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler import CouplingMap
    from qiskit.providers.fake_provider import GenericBackendV2


    qc = QuantumCircuit(4)
    qc.h(0)
    qc.cx(0, range(1, 4))
    qc.measure_all()

    cmap = CouplingMap.from_heavy_hex(3)
    backend = GenericBackendV2(num_qubits=cmap.size(), coupling_map=cmap)

    tqc = transpile(
        qc,
        routing_method="stochastic",
        layout_method="dense",
        seed_transpiler=12342,
        target=backend.target
    )
    ```

    to:

    ```c
    tqc = transpile(
        qc,
        routing_method="sabre",
        layout_method="sabre",
        seed_transpiler=12342,
        target=backend.target
    )
    ```

    While for a pass manager, the change would be:

    ```c
    passmanager = PassManager(StochasticSwap(coupling, 20, 13))
    new_qc = passmanager.run(qc)
    ```

    to:

    ```c
    passmanager = PassManager(SabreSwap(backend.target, "basic"))
    new_qc = passmanager.run(qc)
    ```

*   The transpiler pass `ConvertConditionsToIfOps` has been deprecated and will be removed in Qiskit 2.0.0. This class is now deprecated because the underlying data model for `Instruction.condition` which this pass is converting from has been deprecated and will be removed in 2.0.0.

*   Providing custom gates through the `basis_gates` argument is deprecated for both [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and `generate_preset_pass_manager()`, this functionality will be removed in Qiskit 2.0. Custom gates are still supported in the [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") model, and can be provided through the `target` argument. One can build a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") instance from scratch or use the [`Target.from_configuration()`](qiskit-transpiler-target#qiskit.transpiler.Target.from_configuration "qiskit.transpiler.Target.from_configuration") method with the `custom_name_mapping` argument. For example:

    ```c
    from qiskit.circuit.library import XGate
    from qiskit.transpiler.target import Target

    basis_gates = ["my_x", "cx"]
    custom_name_mapping = {"my_x": XGate()}
    target = Target.from_configuration(
        basis_gates=basis_gates, num_qubits=2, custom_name_mapping=custom_name_mapping
    )
    ```

*   ## As part of the Qiskit Pulse package deprecation, pulse-related aspects in the [`qiskit.transpiler.Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") class are being deprecated. These include:

    *   `calibration`
    *   `update_from_instruction_schedule_map()`
    *   `has_calibration()`
    *   `get_calibration()`
    *   `instruction_schedule_map()`

    ## In addition the following transpiler passer are also being deprecated:

    *   `PulseGates`
    *   `ValidatePulseGates`
    *   `RXCalibrationBuilder`
    *   `RZXCalibrationBuilder`
    *   `EchoRZXWeylDecomposition`

*   The inst\_map argument in [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager"), `from_configuration()`, [`PassManagerConfig`](qiskit-transpiler-pass-manager-config#qiskit.transpiler.PassManagerConfig "qiskit.transpiler.PassManagerConfig") initializer and `generate_scheduling()` is being deprecated.

*   The calibration argument in [`InstructionProperties()`](qiskit-transpiler-instruction-properties#qiskit.transpiler.InstructionProperties "qiskit.transpiler.target.InstructionProperties") initializer methods is being deprecated.

*   The following [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") arguments are deprecated in favor of defining a custom [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target"): `instruction_durations`, `timing_constraints`, and `backend_properties`. These arguments can be used to build a target with [`Target.from_configuration()`](qiskit-transpiler-target#qiskit.transpiler.Target.from_configuration "qiskit.transpiler.Target.from_configuration"):

    ```c
    Target.from_configuration(
         ...
         backend_properties = backend_properties,
         instruction_durations = instruction_durations,
         timing_constraints = timing_constraints
    )
    ```

*   The method [`PassManagerConfig.from_backend()`](qiskit-transpiler-pass-manager-config#qiskit.transpiler.PassManagerConfig.from_backend "qiskit.transpiler.PassManagerConfig.from_backend") will stop supporting inputs of type `BackendV1` in the backend parameter in a future release no earlier than 2.0. `BackendV1` is deprecated and implementations should move to [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

*   The deprecated [`DAGCircuit.duration`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.duration "qiskit.dagcircuit.DAGCircuit.duration") attribute was not removed in this release as originally planned, it will be removed as part of the Qiskit 3.0.0 release instead. This functionality has been superseded by the [`QuantumCircuit.estimate_duration()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.estimate_duration "qiskit.circuit.QuantumCircuit.estimate_duration") method which should be used instead.

*   The `propagate_condition` argument of [`DAGCircuit.substitute_node()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node "qiskit.dagcircuit.DAGCircuit.substitute_node") and [`DAGCircuit.substitute_node_with_dag()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag "qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag") has been deprecated. With the removal of `Instruction.condition` from the Qiskit data model this option no longer serves a purpose. If it is set it no longer has any effect. It is not removed from the signature to maintain compatibility during the migration from Qiskit 1.x -> 2.0. This option will be removed in Qiskit 3.0.

*   The function [`generate_pre_op_passmanager()`](transpiler-preset#qiskit.transpiler.preset_passmanagers.generate_pre_op_passmanager "qiskit.transpiler.preset_passmanagers.generate_pre_op_passmanager") is deprecated. It is no longer used in the Qiskit preset pass managers, and its purpose is defunct; it originally generated a fix-up stage for translation plugins that did not respect ISA directionality. Translation stages are now required to respect directionality, so the functionality is not needed, and most likely, no replacement is required.

<span id="relnotes-unreleased-notes-preview-visualization-deprecations" />

### Visualization Deprecations

*   The `transition_visualization()` function has been deprecated and will be removed in the 2.0.0 release. This function had a number of limitations which limited it’s utility to only very specific use cases and didn’t fit in with the rest of the Qiskit visualization module.

*   The `justify` argument of `circuit_drawer()` or `QuantumCircuit.draw()`, will no longer support invalid values (previously changing them to the default), and in a future release they will error. Valid justify values are `"left"`, `"right"` or `"none"`.

*   As part of the Qiskit Pulse package deprecation, pulse drawing via `qiskit.visualization.pulse_drawer()` is being deprecated.

<span id="relnotes-unreleased-notes-preview-misc-deprecations" />

### Misc. Deprecations

*   The `qiskit.result.mitigation` module has been deprecated and will be removed in the 2.0 release. The deprecation includes the `LocalReadoutMitigator` and `CorrelatedReadoutMitigator` classes as well as the associated utils. Their functionality has been superseded by the mthree package, found in [https://github.com/Qiskit/qiskit-addon-mthree](https://github.com/Qiskit/qiskit-addon-mthree).

*   ## As part of the Qiskit Pulse package deprecation, the following functions and class are being deprecated as well:

    *   `qiskit.compiler.schedule()`
    *   `qiskit.compiler.sequence()`
    *   `qiskit.assembler.assemble_schedules()`
    *   `qiskit.scheduler.methods.as_soon_as_possible()`
    *   `qiskit.scheduler.methods.as_late_as_possible()`
    *   `qiskit.scheduler.schedule_circuit.schedule_circuit()`
    *   `qiskit.scheduler.ScheduleConfig`

<span id="relnotes-unreleased-notes-preview-security-issues" />

### Security Issues

*   Fixed a security vulnerability in [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") when loading payloads that use `sympy` to serialize [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") objects and other symbolic expressions. This potentially includes any QPY payload using QPY version \< 10, and optionally 10, 11, and 12 depending on the symbolic encoding used in the serialization step ([`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump")).

<span id="relnotes-unreleased-notes-preview-bug-fixes" />

### Bug Fixes

*   Fixes an issue with the visualizations of some backends/coupling maps that showed as folded on their own. The default \`\`neato\` setting \<[https://graphviz.org/docs/layouts/neato/](https://graphviz.org/docs/layouts/neato/)>\`\_ works well in most cases. However, `prism` overlap returns a more regular layout for other scenarios.

*   Fixed a series of issues when controlling parameterized standard gates. The controlled version of some gates (e.g. [`RXXGate`](qiskit-circuit-library-rxx-gate#qiskit.circuit.library.RXXGate "qiskit.circuit.library.RXXGate") or [`RYGate`](qiskit-circuit-library-ry-gate#qiskit.circuit.library.RYGate "qiskit.circuit.library.RYGate") for more than 1 control) cannot be synthesized if they contain unbound parameters. Previously, calling `.control()` but now we create an [`AnnotatedOperation`](qiskit-circuit-annotated-operation#qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") as placeholder. This allows to insert the controlled gate into a circuit, bind the parameters at a later stage, and then synthesize the operation. Fixes [#10311](https://github.com/Qiskit/qiskit/issues/10311), [#10697](https://github.com/Qiskit/qiskit/issues/10697), and [#12135](https://github.com/Qiskit/qiskit/issues/12135).

*   The [`SGate`](qiskit-circuit-library-s-gate#qiskit.circuit.library.SGate "qiskit.circuit.library.SGate") and [`SdgGate`](qiskit-circuit-library-sdg-gate#qiskit.circuit.library.SdgGate "qiskit.circuit.library.SdgGate") now correctly return a [`CSGate`](qiskit-circuit-library-cs-gate#qiskit.circuit.library.CSGate "qiskit.circuit.library.CSGate"), resp. [`CSdgGate`](qiskit-circuit-library-c-sdg-gate#qiskit.circuit.library.CSdgGate "qiskit.circuit.library.CSdgGate"), if they are controlled on a single control qubit.

*   Parametric controlled standard-library gates (such as [`CRXGate`](qiskit-circuit-library-crx-gate#qiskit.circuit.library.CRXGate "qiskit.circuit.library.CRXGate")) will now get correctly extracted to a Rust-space standard gate when using [`QuantumCircuit.append()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.append "qiskit.circuit.QuantumCircuit.append") and the gate object. Previously there was a discrepancy where using the [`QuantumCircuit.crx()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.crx "qiskit.circuit.QuantumCircuit.crx") method would cause a correct extraction in Rust space, but the `append()` form would not. The bug should generally not have caused any unsoundness from Python.

*   Fixed a bug in [`TwoQubitBasisDecomposer`](qiskit-synthesis-two-qubit-basis-decomposer#qiskit.synthesis.TwoQubitBasisDecomposer "qiskit.synthesis.TwoQubitBasisDecomposer") where the Rust-based code would panic if the given KAK gate wasn’t a Rust-space `StandardGate`.

*   Fixed a bug where [`InstructionDurations.from_backend()`](qiskit-transpiler-instruction-durations#qiskit.transpiler.InstructionDurations.from_backend "qiskit.transpiler.InstructionDurations.from_backend") did not work for [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backends. Fixed #12760 \<[https://github.com/Qiskit/qiskit/issues/12760](https://github.com/Qiskit/qiskit/issues/12760)>.

*   Fixed a bug in [`BitArray.from_counts()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.from_counts "qiskit.primitives.BitArray.from_counts") and [`BitArray.from_samples()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.from_samples "qiskit.primitives.BitArray.from_samples"). Previously these would raise an error if given data containing only zeros, and no value for the optional argument `num_bits`. Now they produce a [`BitArray`](qiskit-primitives-bit-array#qiskit.primitives.BitArray "qiskit.primitives.BitArray") with [`BitArray.num_bits`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.num_bits "qiskit.primitives.BitArray.num_bits") set to 1.

*   Fixed a bug in the [`ConsolidateBlocks`](qiskit-transpiler-passes-consolidate-blocks#qiskit.transpiler.passes.ConsolidateBlocks "qiskit.transpiler.passes.ConsolidateBlocks") transpiler pass, when the input circuit contains a custom opaque gate and neither the `basis_gates` or `target` options are set the pass would raise a `QiskitError` and fail. This has been corrected so that the in these situations the transpiler pass will not consolidate the block identified containing a custom gate instead of failing.

*   Fixed the definition of the [`CUGate`](qiskit-circuit-library-cu-gate#qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate") matrix in Rust-space. While this was not noticable while handling the [`CUGate`](qiskit-circuit-library-cu-gate#qiskit.circuit.library.CUGate "qiskit.circuit.library.CUGate") purely on Python side, this had knock-on effects when transpiler passes were using the Rust representation, such as could happen in `Consolidate2qBlocks`. Fixed [#13118](https://github.com/Qiskit/qiskit/issues/13118).

*   Fixed a bug in [`PadDynamicalDecoupling`](qiskit-transpiler-passes-pad-dynamical-decoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling"), which previously did not correctly display the error message that a delay is not pulse-aligned, if the previous or following node was an input/output node. Now, the error message is correctly displayed.

*   Fixed a bug in the transpiler pass [`ElidePermutations`](qiskit-transpiler-passes-elide-permutations#qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations") where the qubit mapping was not updated correctly in the presence of [`PermutationGate`](qiskit-circuit-library-permutation-gate#qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate")s.

*   Fixed a bug in [`HoareOptimizer`](qiskit-transpiler-passes-hoare-optimizer#qiskit.transpiler.passes.HoareOptimizer "qiskit.transpiler.passes.HoareOptimizer") where a controlled gate was simplified by removing its controls but the new gate was not handled correctly.

*   The keyword argument `order` of the function [`BitArray.from_bool_array()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.from_bool_array "qiskit.primitives.BitArray.from_bool_array") should be ‘little’ or ‘big’. Added checks to raise error if an invalid value is entered.

*   Improve the decomposition of the gate generated by [`QuantumCircuit.mcx()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.mcx "qiskit.circuit.QuantumCircuit.mcx") without using ancilla qubits, so that the number of [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") will grow quadratically in the number of qubits and not exponentially.

*   Fixed the behavior of `generate_preset_pass_manager()` to raise a ValueError exception if not provided with a non-negative integer seed\_transpiler argument.

*   Fixed a potential source of non-determinism in [`DenseLayout`](qiskit-transpiler-passes-dense-layout#qiskit.transpiler.passes.DenseLayout "qiskit.transpiler.passes.DenseLayout") (and by extension [`SabreLayout`](qiskit-transpiler-passes-sabre-layout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout")) when targeting a [`CouplingMap`](qiskit-transpiler-coupling-map#qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") or [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") that has more than one subgraph with the same degree of connectivity. In these case the exact output layout from the pass could previously fluctuate based on the number of local CPUs and thread execution speed.

*   The `HighLevelSynthesis` transpiler pass no longer raises an exception when encountering a custom gate that is called “qft” but is not an instance of [`QFTGate`](qiskit-circuit-library-qft-gate#qiskit.circuit.library.QFTGate "qiskit.circuit.library.QFTGate"). Instead, the synthesis plugins for QFT gates ignore such a gate, and the gate’s definition is used (if provided).

*   Fixed an issue introduced in the now [yanked](https://peps.python.org/pep-0592/) 1.2.3 bugfix release that would cause an exception with the error message “Qiskit doesn’t support loading a symengine payload generated with symengine >= 1.0” to be raised whenever loading a QPY file that was generated with a different symengine version from the version installed by the loading. This issue could only occur in 1.2.3.

*   Fixed an issue with [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") when loading a QPY file containing a [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"), if the versions of `symengine` installed in the generating and loading environments were not the same. For example, if a QPY file containing [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")s was generated using Qiskit 1.2.2 with `symengine==0.11.0` installed, Qiskit 1.2.2 with `syengine==0.13.0` installed would be unable to load it.

    Previously, an error would have been raised by `symengine` around this version mismatch. This has been worked around for `symengine` 0.11 and 0.13 (there was no 0.12), but if you’re trying to use different versions of `symengine` and there is a mismatch, this version of Qiskit still might not work.

*   Fixed an edge case in [`SabreLayout`](qiskit-transpiler-passes-sabre-layout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout"), where in rare cases on large devices and challenging circuits, the routing would fail. This was due to the release valve making more than one two-qubit gate routable, where only one was expected. Fixed [#13081](https://github.com/Qiskit/qiskit/issues/13081).

*   Fixed a bug in [`Split2QUnitaries`](qiskit-transpiler-passes-split-2-q-unitaries#qiskit.transpiler.passes.Split2QUnitaries "qiskit.transpiler.passes.Split2QUnitaries") where it would fail to run on circuits with custom gates that didn’t implement `__array__()`. See [#12984](https://github.com/Qiskit/qiskit/issues/12970).

*   Fixed a bug in [`StatePreparation`](qiskit-circuit-library-state-preparation#qiskit.circuit.library.StatePreparation "qiskit.circuit.library.StatePreparation") where the `normalize` argument was ignored for input arrays. Fixed [#12984](https://github.com/Qiskit/qiskit/issues/12984).

*   Fixed a bug of [`StatevectorSampler`](qiskit-primitives-statevector-sampler#qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler") that ignored gates with `c_if`. It will raise an error because [`Statevector`](qiskit-quantum-info-statevector#qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector") cannot handle `c_if`.

*   Fixed a bug where various synthesis methods created circuits without quantum or classical registers. This also affected functions that internally used the synthesis methods, such as [`Clifford.to_circuit()`](qiskit-quantum-info-clifford#qiskit.quantum_info.Clifford.to_circuit "qiskit.quantum_info.Clifford.to_circuit"). Fixed [#13041](https://github.com/Qiskit/qiskit/issues/13041).

*   Fix a bug that caused the method `Initialize.gates_to_uncompute()` fail.

*   [`MCXVChain`](qiskit-circuit-library-mcxv-chain#qiskit.circuit.library.MCXVChain "qiskit.circuit.library.MCXVChain") with k controls and k-2 dirty auxiliary qubits now requires 8k-6 cx gates.

*   Fixed an issue when running [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or [`run()`](qiskit-transpiler-staged-pass-manager#qiskit.transpiler.StagedPassManager.run "qiskit.transpiler.StagedPassManager.run") on a pass manager generated by [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") using `optimization_level` 2 or 3 when the `routing_method` argument is set to `"none"` to explicitly disable routing. Previously under these conditions the transpiler would run the `ElidePermutation` pass as part of the init stage as under normal conditions this is a useful optimization to remove [`SwapGate`](qiskit-circuit-library-swap-gate#qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") and [`PermutationGate`](qiskit-circuit-library-permutation-gate#qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate") instances from the circuit. But when `routing_method="none"` this optimization wasn’t expected as it permutes the circuit in a similar manner to routing which shouldn’t be performed when `routing_method="none"`. This has been fixed by no longer running `ElidePermutation` if `routing_method="none"` is set. Fixed [#13144](https://github.com/Qiskit/qiskit/issues/13144)

*   Fixed a bug in `synth_cnot_full_pmh()` where providing a `section_size` that did not divide the number of qubits without remainder could lead to wrong results. Now any `section_size` (at most equal to the number of qubits) synthesizes the correct circuit. For a (heuristically) optimal value, set `section_size=None`.

*   The OpenQASM 2 importer previously would output incorrect [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate") instances for gate calls referring to a `gate` definition that followed a prior `gate` definition that was being treated as a built-in operation by a [`CustomInstruction`](qasm-2#qiskit.qasm2.CustomInstruction "qiskit.qasm2.CustomInstruction"). See [#13339](https://github.com/Qiskit/qiskit/issues/13339) for more detail.

*   The OpenQASM 3 exporter will now correctly error when asked to use a keyword or other invalid identifier as a “basis gate”, as it has no way of putting out correct output in these cases.

*   The OpenQASM 3 exporter has restored its behavior of accepting non-standard-library include files in the `includes` argument to [`qasm3.dump()`](qasm-3#qiskit.qasm3.dump "qiskit.qasm3.dump"), [`dumps()`](qasm-3#qiskit.qasm3.dumps "qiskit.qasm3.dumps"), and [`Exporter`](qasm-3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter"). These will insert a suitable `include` statement into the output as before, and the exporter remains unaware of the intended gates in that include file; you should pass the gates you expect it to define in the `basis_gates` argument to the same functions.

    We expect to improve the export mechanism against non-standard include files in a future release of Qiskit.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm-3#module-qiskit.qasm3 "qiskit.qasm3")) will now correctly export multiple instances of [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate") from a circuit. Previously, only a single instance would be exported, and all other instances would silently use the same (incorrect) version.

*   The OpenQASM 3 exporter ([`qiskit.qasm3`](qasm-3#module-qiskit.qasm3 "qiskit.qasm3")) will now correctly escape gate names. Previously, a gate whose name was an invalid OpenQASM 3 identifier would cause invalid OpenQASM 3 to be generated.

*   Fixed an edge case when transpiling a circuit with `optimization_level` 2 or 3 with an incomplete 1-qubit basis gate set on a circuit containing 2-qubit gates, that can be implemented as a product of single qubit gates. This bug is resolved by restricting [`Split2QUnitaries`](qiskit-transpiler-passes-split-2-q-unitaries#qiskit.transpiler.passes.Split2QUnitaries "qiskit.transpiler.passes.Split2QUnitaries") to consider only [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") objects. Fixed [#12970](https://github.com/Qiskit/qiskit/issues/12970).

*   A series of input-handling inconsistencies between [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") have been fixed. These inconsistencies would lead to different transpilation outputs for the same inputs, or [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") failing for certain input combinations accepted by [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   Fixed a performance regression in [`QuantumCircuit.assign_parameters()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") introduced in Qiskit 1.2.0 when calling the method in a tight loop, binding only a small number of parameters out of a heavily parametric circuit on each iteration. If possible, it is still more performant to call [`assign_parameters()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") only once, with all assignments at the same time, as this reduces the proportion of time spent on input normalization and error-checking overhead.

*   Changes the way in which the [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2") class calculates the `std` to ensure that it matches the correct formula.

*   For [`BasicSimulator`](qiskit-providers-basic-provider-basic-simulator#qiskit.providers.basic_provider.BasicSimulator "qiskit.providers.basic_provider.BasicSimulator"), the `basis_gates` entry in the configuration instance returned by the `configuration()` is now a list rather than a `dict_keys` instance, matching the expected type and allowing for configuration instance to be deep copied.

*   Fixed an issue where `circuit_drawer()` or the `QuantumCircuit.draw()` method would not raise a warning when an invalid value was passed to the `justify` argument, before changing it to the default. Now, it will raise a warning if an invalid value is passed. Valid justify values are `"left"`, `"right"` or `"none"`. Refer to #12089 \<[https://github.com/Qiskit/qiskit/issues/12089](https://github.com/Qiskit/qiskit/issues/12089)> for more details.

*   Fixed an issue with [`DAGCircuit.apply_operation_back()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.apply_operation_back "qiskit.dagcircuit.DAGCircuit.apply_operation_back") and [`DAGCircuit.apply_operation_front()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.apply_operation_front "qiskit.dagcircuit.DAGCircuit.apply_operation_front") where previously if you set a [`Clbit`](circuit#qiskit.circuit.Clbit "qiskit.circuit.Clbit") object to the input for the `qargs` argument it would silently be accepted. This has been fixed so the type mismatch is correctly identified and an exception is raised.

*   Fixed [`SparsePauliOp.apply_layout()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.apply_layout "qiskit.quantum_info.SparsePauliOp.apply_layout") and [`Pauli.apply_layout()`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli.apply_layout "qiskit.quantum_info.Pauli.apply_layout") to raise [`QiskitError`](exceptions#qiskit.exceptions.QiskitError "qiskit.exceptions.QiskitError") if duplicate indices or negative indices are provided as part of a layout.

*   Fixed a missing decorator in [`C3SXGate`](qiskit-circuit-library-c-3-sx-gate#qiskit.circuit.library.C3SXGate "qiskit.circuit.library.C3SXGate") that made it fail if [`Gate.to_matrix()`](qiskit-circuit-gate#qiskit.circuit.Gate.to_matrix "qiskit.circuit.Gate.to_matrix") was called. The gate matrix is now return as expected.

*   Fixed a bug with the `"circular"` and `"sca"` entanglement for [`NLocal`](qiskit-circuit-library-n-local#qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") circuits and its derivatives. For entanglement blocks of more than 2 qubits, the circular entanglement was previously missing some connections. For example, for 4 qubits and a block size of 3 the code previously used:

    ```c
    [(2, 3, 0), (0, 1, 2), (1, 2, 3)]
    ```

    but now is correctly adding the `(3, 0, 1)` connections, that is:

    ```c
    [(2, 3, 0), (3, 0, 1), (0, 1, 2), (1, 2, 3)]
    ```

    As such, the `"circular"` and `"sca"` entanglements use `num_qubits` entangling blocks per layer.

*   Add more Clifford gates to the [`CollectCliffords()`](qiskit-transpiler-passes-collect-cliffords#qiskit.transpiler.passes.CollectCliffords "qiskit.transpiler.passes.CollectCliffords") transpiler pass. In particular, we have added the gates `ECRGate()`, `DCXGate()`, `iSWAPGate()`, `SXGate()` and `SXdgGate()` to this transpiler pass.

*   Fixed a bug in [`QuantumCircuit.decompose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.decompose "qiskit.circuit.QuantumCircuit.decompose") where objects that could be synthesized with [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") were first synthesized and then decomposed immediately (i.e., they were decomposed twice instead of once). This affected, e.g., [`MCXGate`](qiskit-circuit-library-mcx-gate#qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") or [`Clifford`](qiskit-quantum-info-clifford#qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford"), among others.

*   Fixed a bug in [`QuantumCircuit.decompose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.decompose "qiskit.circuit.QuantumCircuit.decompose"), where high-level objects without a definition were not decomposed if they were explicitly set via the `"gates_to_decompose"` argument. For example, previously the following did not perform a decomposition but now works as expected:

    ```c
    from qiskit import QuantumCircuit
    from qiskit.quantum_info import Clifford
    from qiskit.transpiler.passes import Decompose

    cliff = Clifford(HGate())
    circuit = QuantumCircuit(1)
    circuit.append(cliff, [0])

    decomposed = Decompose(gates_to_decompose=["clifford"])(circuit)
    ```

*   Fix a bug in [`Isometry`](qiskit-circuit-library-isometry#qiskit.circuit.library.Isometry "qiskit.circuit.library.Isometry") due to an unnecessary assertion, that led to an error in [`UnitaryGate.control()`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate.control "qiskit.circuit.library.UnitaryGate.control") when [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") had more that two qubits.

*   The [`QuantumCircuit.parameters`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.parameters "qiskit.circuit.QuantumCircuit.parameters") attribute will now correctly be empty when using [`QuantumCircuit.copy_empty_like()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.copy_empty_like "qiskit.circuit.QuantumCircuit.copy_empty_like") on a parametric circuit. Previously, an internal cache would be copied over without invalidation. Fix [#12617](https://github.com/Qiskit/qiskit/issues/12617).

*   [`QuantumCircuit.depth()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.depth "qiskit.circuit.QuantumCircuit.depth") will now correctly handle operations that do not have operands, such as [`GlobalPhaseGate`](qiskit-circuit-library-global-phase-gate#qiskit.circuit.library.GlobalPhaseGate "qiskit.circuit.library.GlobalPhaseGate").

*   [`QuantumCircuit.depth()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.depth "qiskit.circuit.QuantumCircuit.depth") will now count the variables and clbits used in real-time expressions as part of the depth calculation.

*   Fix the [`SolovayKitaev`](qiskit-transpiler-passes-solovay-kitaev#qiskit.transpiler.passes.SolovayKitaev "qiskit.transpiler.passes.SolovayKitaev") transpiler pass when loading basic approximations from an exising `.npy` file. Previously, loading a stored approximation which allowed for further reductions (e.g. due to gate cancellations) could cause a runtime failure. Additionally, the global phase difference of the U(2) gate product and SO(3) representation was lost during a save-reload procedure. Fixes [Qiskit/qiskit#12576](https://github.com/Qiskit/qiskit/issues/12576).

*   Fixed [`SparsePauliOp.apply_layout()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.apply_layout "qiskit.quantum_info.SparsePauliOp.apply_layout") to work correctly with zero-qubit operators. For example, if you previously created a 0 qubit and applied a layout like:

    ```c
    op = SparsePauliOp("")
    op.apply_layout(None, 3)
    ```

    this would have previously raised an error. Now this will correctly return an operator of the form: `SparsePauliOp(['III'], coeffs=[1.+0.j])`

*   Fixed a bug when [`SparsePauliOp.paulis`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.paulis "qiskit.quantum_info.SparsePauliOp.paulis") is set to be a [`PauliList`](qiskit-quantum-info-pauli-list#qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") with nonzero phase, where subsequent calls to several [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") methods would produce incorrect results. Now when [`SparsePauliOp.paulis`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.paulis "qiskit.quantum_info.SparsePauliOp.paulis") is set to a [`PauliList`](qiskit-quantum-info-pauli-list#qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") with nonzero phase, the phase is absorbed into [`SparsePauliOp.coeffs`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.coeffs "qiskit.quantum_info.SparsePauliOp.coeffs"), and the phase of the input [`PauliList`](qiskit-quantum-info-pauli-list#qiskit.quantum_info.PauliList "qiskit.quantum_info.PauliList") is set to zero.

*   Fixed an oversight in the [`Commuting2qGateRouter`](qiskit-transpiler-passes-commuting-2-q-gate-router#qiskit.transpiler.passes.Commuting2qGateRouter "qiskit.transpiler.passes.Commuting2qGateRouter") transpiler pass where the qreg permutations were not added to the pass property set, so they would have to be tracked manually by the user. Now it’s possible to access the permutation through the output circuit’s `layout` property and plug the pass into any transpilation pipeline without loss of information.

*   Fixed a floating-point imprecision when scaling certain pulse units between seconds and nanoseconds. If the pulse was symbolically defined, an unnecessary floating-point error could be introduced by the scaling for certain builds of `symengine`, which could manifest in unexpected results once the symbols were fully bound. See [#12392](https://github.com/Qiskit/qiskit/pull/12392).

*   Fixed a bug in `qiskit.visualization.pulse_v2.interface.draw()` that didn’t draw pulse schedules when the draw function was called with a [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") argument. Because the V2 backend doesn’t report hardware channel frequencies, the generated drawing will show ‘no freq.’ below each channel label.

*   Fixed an issue with [`dag_drawer()`](qiskit-visualization-dag-drawer#qiskit.visualization.dag_drawer "qiskit.visualization.dag_drawer") and [`DAGCircuit.draw()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.draw "qiskit.dagcircuit.DAGCircuit.draw") when attempting to visualize a [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") instance that contained [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") wires. The visualizer would raise an exception trying to do this which has been fixed so the expected visualization will be generated.

*   The [`VF2Layout`](qiskit-transpiler-passes-vf-2-layout#qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") pass would raise an exception when provided with a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") instance without connectivity constraints. This would be the case with targets from Aer 0.13. The issue is now fixed.

*   Fixes an error when calling the method `UnitaryGate.repeat()`. Refer to [#11990](https://github.com/Qiskit/qiskit/issues/11990) for more details.

*   The constructor [`GenericBackendV2`](qiskit-providers-fake-provider-generic-backend-v2#qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") was allowing to create malformed backends because it accepted basis gates that couldn’t be allocated in the backend size . That is, a backend with a single qubit should not accept a basis with two-qubit gates.

*   [`PassManager.run()`](qiskit-transpiler-pass-manager#qiskit.transpiler.PassManager.run "qiskit.transpiler.PassManager.run") will no longer waste time serializing itself when given multiple inputs if it is only going to work in serial.

*   [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") was updated so that fully bound instances that compare equal to instances of Python’s built-in numeric types (like `float` and `int`) also have hash values that match those of the other instances. This change ensures that these types can be used interchangeably as dictionary keys. See [#12488](https://github.com/Qiskit/qiskit/pull/12488).

*   Fixed that the entanglement in [`PauliFeatureMap`](qiskit-circuit-library-pauli-feature-map#qiskit.circuit.library.PauliFeatureMap "qiskit.circuit.library.PauliFeatureMap") and [`ZZFeatureMap`](qiskit-circuit-library-zz-feature-map#qiskit.circuit.library.ZZFeatureMap "qiskit.circuit.library.ZZFeatureMap") could be given as `List[int]` or `List[List[int]]`, which was incompatible with the fact that entanglement blocks of different sizes are used. Instead, the entanglement can be given as dictionary with `{block_size: entanglement}` pairs.

*   Fixed a bug in `plot_coupling_map()` that caused the edges of the coupling map to be colored incorrectly. See [https://github.com/Qiskit/qiskit/pull/12369](https://github.com/Qiskit/qiskit/pull/12369) for details.

*   The OpenQASM 2 parser ([`qiskit.qasm2`](qasm-2#module-qiskit.qasm2 "qiskit.qasm2")) can now handle conditionals with integers that do not fit within a 64-bit integer. Fixed [#12773](https://github.com/Qiskit/qiskit/issues/12773).

*   The OpenQASM 2.0 parser ([`qasm2.load()`](qasm-2#qiskit.qasm2.load "qiskit.qasm2.load") and [`qasm2.loads()`](qasm-2#qiskit.qasm2.loads "qiskit.qasm2.loads")) can now evaluate gate-angle expressions including integer operands that would overflow the system-size integer. These will be evaluated in a double-precision floating-point context, just like the rest of the expression always has been. Beware: an arbitrarily large integer will not necessarily be exactly representable in double-precision floating-point, so there is a chance that however the circuit was generated, it had already lost all numerical precision modulo $2\pi$.

*   Custom gates (those stemming from a `gate` statement) in imported OpenQASM 2 programs will now have an [`Gate.to_matrix()`](qiskit-circuit-gate#qiskit.circuit.Gate.to_matrix "qiskit.circuit.Gate.to_matrix") implementation. Previously they would have no matrix definition, meaning that roundtrips through OpenQASM 2 could needlessly lose the ability to derive the gate matrix. Note, though, that the matrix is calculated by recursively finding the matrices of the inner gate definitions, as [`Operator`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator "qiskit.quantum_info.Operator") does, which might be less performant than before the round-trip.

*   Previously, [`DAGCircuit.replace_block_with_op()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.replace_block_with_op "qiskit.dagcircuit.DAGCircuit.replace_block_with_op") allowed to place an `n`-qubit operation onto a block of `m` qubits, leaving the DAG in an invalid state. This behavior has been fixed, and the attempt will raise a [`DAGCircuitError`](dagcircuit#qiskit.dagcircuit.DAGCircuitError "qiskit.dagcircuit.DAGCircuitError").

*   Fixed [`Operator.power()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.power "qiskit.quantum_info.Operator.power") when called with non-integer powers on a matrix whose Schur form is not diagonal (for example, most non-unitary matrices).

*   [`Operator.power()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.power "qiskit.quantum_info.Operator.power") will now more reliably return the expected principal value from a fractional matrix power of a unitary matrix with a $-1$ eigenvalue. This is tricky in general, because floating-point rounding effects can cause a matrix to \_truly\_ have an eigenvalue on the negative side of the branch cut (even if its exact mathematical relation would not), and imprecision in various BLAS calls can falsely find the wrong side of the branch cut.

    [`Operator.power()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.power "qiskit.quantum_info.Operator.power") now shifts the branch-cut location for matrix powers to be a small complex rotation away from $-1$. This does not solve the problem, it just shifts it to a place where it is far less likely to be noticeable for the types of operators that usually appear. Use the new `branch_cut_rotation` parameter to have more control over this.

    See [#13305](https://github.com/Qiskit/qiskit/issues/13305).

*   `Target.has_calibration()` has been updated so that it does not raise an exception for an instruction that has been added to the target with `None` for its instruction properties. Fixes [#12525](https://github.com/Qiskit/qiskit/issues/12525).

*   Fixed a bug where the barrier labels were incorrectly positioned when using the `reverse_bits = True` parameter in the [`QuantumCircuit.draw()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw") method. The bug caused the labels on barrier operations to be misaligned, leading to potential confusion in circuit visualizations. Fixed [#13609](https://github.com/Qiskit/qiskit/issues/13609).

*   Fixed an inconsistency in dealing with close-to-identity gates in the transpilation process, where gates that are close to the identity were assumed to commute with everything, but not removed. The underlying issue were different metrics used in [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") and [`CommutationAnalysis`](qiskit-transpiler-passes-commutation-analysis#qiskit.transpiler.passes.CommutationAnalysis "qiskit.transpiler.passes.CommutationAnalysis") (and, by extension, [`CommutativeInverseCancellation`](qiskit-transpiler-passes-commutative-inverse-cancellation#qiskit.transpiler.passes.CommutativeInverseCancellation "qiskit.transpiler.passes.CommutativeInverseCancellation")). Both now use the average gate fidelity and the same threshold to assess whether a gate should be treated as identity (such as a rotation gate with very small angle). See either of the aforementioned classes’ docstrings for more information. Fixed [#13547](https://github.com/Qiskit/qiskit/issues/13547).

*   Applied a small regularisation factor against ill-conditioned Hermitian matrices in super-operator representations.

*   Commutation relations of [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction")s with float-only `params` were eagerly cached by the [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker"), using the `params` as key to query the relation. This could lead to faulty results, if the instruction’s definition depended on additional information that just the [`params`](qiskit-circuit-instruction#qiskit.circuit.Instruction.params "qiskit.circuit.Instruction.params") attribute, such as e.g. the case for [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"). This behavior is now fixed, and the commutation checker only conservatively caches commutations for Qiskit-native standard gates. This can incur a performance cost if you were relying on your custom gates being cached, however, we cannot guarantee safe caching for custom gates, as they might rely on information beyond [`params`](qiskit-circuit-instruction#qiskit.circuit.Instruction.params "qiskit.circuit.Instruction.params").

*   Fixed a bug in the `CommmutationChecker`, where checking commutation of instruction with non-numeric values in the [`params`](qiskit-circuit-instruction#qiskit.circuit.Instruction.params "qiskit.circuit.Instruction.params") attribute (such as the [`PauliGate`](qiskit-circuit-library-pauli-gate#qiskit.circuit.library.PauliGate "qiskit.circuit.library.PauliGate")) could raise an error. Fixed [#13570](https://github.com/Qiskit/qiskit/issues/13570).

*   Fixed a bug where calling [`QuantumCircuit.decompose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.decompose "qiskit.circuit.QuantumCircuit.decompose") on an instruction that had no definition inside a `c_if` block would raise an error. Fixed [#13493](https://github.com/Qiskit/qiskit/issues/13493).

*   Operations inside a control flow (e.g. [`QuantumCircuit.for_loop()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.for_loop "qiskit.circuit.QuantumCircuit.for_loop")) were not correctly decomposed when calling [`QuantumCircuit.decompose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.decompose "qiskit.circuit.QuantumCircuit.decompose"). This behavior is now fixed and instructions are unrolled. Fixed [#13544](https://github.com/Qiskit/qiskit/issues/13544).

*   Comparisons of [`Delay`](circuit#qiskit.circuit.Delay "qiskit.circuit.Delay") instructions, including within circuits, now require the units to be equal as well as the duration value.

*   The [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") did not handle commutations of the [`CRXGate`](qiskit-circuit-library-crx-gate#qiskit.circuit.library.CRXGate "qiskit.circuit.library.CRXGate"), [`CRYGate`](qiskit-circuit-library-cry-gate#qiskit.circuit.library.CRYGate "qiskit.circuit.library.CRYGate") and [`CRZGate`](qiskit-circuit-library-crz-gate#qiskit.circuit.library.CRZGate "qiskit.circuit.library.CRZGate") correctly for angles $\pi(4k + 2)$ for $k \in \mathbb Z$. In these cases, the controlled rotations were falsely assumed to commute with any gate. Now these gates correctly commute with any gate if the rotation angle is a multiple of $4\pi$.

*   Added default definitions for [`FullAdderGate`](qiskit-circuit-library-full-adder-gate#qiskit.circuit.library.FullAdderGate "qiskit.circuit.library.FullAdderGate"), [`HalfAdderGate`](qiskit-circuit-library-half-adder-gate#qiskit.circuit.library.HalfAdderGate "qiskit.circuit.library.HalfAdderGate"), [`ModularAdderGate`](qiskit-circuit-library-modular-adder-gate#qiskit.circuit.library.ModularAdderGate "qiskit.circuit.library.ModularAdderGate") and [`MultiplierGate`](qiskit-circuit-library-multiplier-gate#qiskit.circuit.library.MultiplierGate "qiskit.circuit.library.MultiplierGate") gates, allowing to contruct [`Operator`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")s from quantum circuits containing these gates.

*   Fixed the number of clean ancilla qubits required by [`FullAdderSynthesisV95`](qiskit-transpiler-passes-synthesis-hls-plugins-full-adder-synthesis-v95#qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisV95 "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisV95"), [`HalfAdderSynthesisV95`](qiskit-transpiler-passes-synthesis-hls-plugins-half-adder-synthesis-v95#qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisV95 "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisV95"), and [`ModularAdderSynthesisV95`](qiskit-transpiler-passes-synthesis-hls-plugins-modular-adder-synthesis-v95#qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisV95 "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisV95") plugins.

*   Added missing [`FullAdderSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-full-adder-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.FullAdderSynthesisDefault") plugin that chooses the best decomposition for [`FullAdderGate`](qiskit-circuit-library-full-adder-gate#qiskit.circuit.library.FullAdderGate "qiskit.circuit.library.FullAdderGate") based on the number of clean ancilla qubits available.

*   Fixed [`HalfAdderSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-half-adder-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.HalfAdderSynthesisDefault") and [`ModularAdderSynthesisDefault`](qiskit-transpiler-passes-synthesis-hls-plugins-modular-adder-synthesis-default#qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisDefault "qiskit.transpiler.passes.synthesis.hls_plugins.ModularAdderSynthesisDefault") plugins, for [`HalfAdderGate`](qiskit-circuit-library-half-adder-gate#qiskit.circuit.library.HalfAdderGate "qiskit.circuit.library.HalfAdderGate") and [`ModularAdderGate`](qiskit-circuit-library-modular-adder-gate#qiskit.circuit.library.ModularAdderGate "qiskit.circuit.library.ModularAdderGate") respectively, to choose the best decomposition based on the number of clean ancilla qubits available.

*   Fix incorrect behavior in `CircuitData` in which, upon parameter assignment, we attempted to modify the cached operation inside of a `PackedInstruction`. Now we instead discard said cache prompting the `PackedInstruction` to build a new Python operation should it be needed.

*   Fixed a bug in [`QuantumCircuit.assign_parameters()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters"), occurring when assigning parameters to standard gates whose definition has already been triggered. In this case, the new values were not properly propagated to the gate instances. While the circuit itself was still compiled as expected, inspecting the individual operations would still show the old parameter.

    For example:

    ```c
    from qiskit.circuit.library import EfficientSU2

    circuit = EfficientSU2(2, flatten=True)
    circuit.assign_parameters([1.25] * circuit.num_parameters, inplace=True)
    print(circuit.data[0].operation.params)  # would print θ[0] instead of 1.25
    ```

    Fixed [#13478](https://github.com/Qiskit/qiskit/issues/13478).

*   Fixed a bug in the [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") which could fail upon checking the commutation relation of a two-qubit Pauli rotation with a gate that is not in the commutation cache. For example:

    ```c
    import numpy as np
    from qiskit.circuit.library import RXXGate, RGate
    from qiskit.circuit.commutation_library import SessionCommutationChecker as scc

    res = scc.commute(RGate(2, 2), [1], [], RXXGate(np.pi / 2), [0, 1], [])
    ```

    This behavior is now resolved and the commutation relation correctly computed. Fixed [#13742](https://github.com/Qiskit/qiskit/issues/13742).

*   Fixed a bug that caused the circuit library functions `efficient_su2()`, `real_amplitudes()`, `excitation_preserving()` and `pauli_two_design()` to error out when constructed for `num_qubits==1`. For a single qubit these circuits will not contain any 2-qubit gates.

*   Fixed a series of bugs when processing circuit with parameterized global phases, where upon assignment the global phase was not correctly assigned. Known cases this affected include:

    *   assigning parameters after calling [`QuantumCircuit.decompose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.decompose "qiskit.circuit.QuantumCircuit.decompose") on a circuit, where the decomposition introduces a global phase
    *   assigning parameters on a circuit constructed from a DAG via [`dag_to_circuit()`](converters#qiskit.converters.dag_to_circuit "qiskit.converters.dag_to_circuit")
    *   assigning parameters on circuits created with [`pauli_twirl_2q_gates()`](circuit#qiskit.circuit.pauli_twirl_2q_gates "qiskit.circuit.pauli_twirl_2q_gates"), where the circuit to be twirled had a parameterized global phase

    Fixed [#13534](https://github.com/Qiskit/qiskit/issues/13534).

*   Previously the [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass synthesized an instruction for which a synthesis plugin is available, regardless of whether the instruction is already supported by the target or a part of the explicitly passed `basis_gates`. This behavior is now fixed, so that such already supported instructions are no longer synthesized.

*   An issue where [`QuantumCircuit.qubit_stop_time()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.qubit_stop_time "qiskit.circuit.QuantumCircuit.qubit_stop_time") and [`QuantumCircuit.qubit_duration()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.qubit_duration "qiskit.circuit.QuantumCircuit.qubit_duration") returned incorrect time (duration) was fixed. It was triggered when some qubits have instructions but other qubits are idle. Fixes [#8729](https://github.com/Qiskit/qiskit/issues/8729).

*   The transpilation pass [`InverseCancellation`](qiskit-transpiler-passes-inverse-cancellation#qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation") now runs inside of flow controlled blocks. Previously, it ignored the pairs of gates in classical blocks that could be cancelled. Refer to [#13437](https://github.com/Qiskit/qiskit/issues/13437) for more details.

*   Fixed a bug where any instruction called `"mcmt"` would be passed into the high-level synthesis routine for a [`MCMTGate`](qiskit-circuit-library-mcmt-gate#qiskit.circuit.library.MCMTGate "qiskit.circuit.library.MCMTGate"), which causes a failure or invalid result. In particular, this could happen accidentally when handling the [`MCMT`](qiskit-circuit-library-mcmt#qiskit.circuit.library.MCMT "qiskit.circuit.library.MCMT") \_circuit\_, named `"mcmt"`, and implicitly converting it into an instruction e.g. when appending it to a circuit. Fixed [#13563](https://github.com/Qiskit/qiskit/issues/13563).

*   Fixed a bug in [`RZGate.control()`](qiskit-circuit-library-rz-gate#qiskit.circuit.library.RZGate.control "qiskit.circuit.library.RZGate.control") for more than 1 control qubit, which used an unnecessarily expensive decomposition. Fixed [#13473](https://github.com/Qiskit/qiskit/issues/13473).

*   Fixed a bug in the basis approximation generation for [`SolovayKitaev`](qiskit-transpiler-passes-solovay-kitaev#qiskit.transpiler.passes.SolovayKitaev "qiskit.transpiler.passes.SolovayKitaev"). Previously, generating discrete basis approximations using `generate_basis_approximations` for a basis containing `"sx"` or `"sxdg"` gates would fail. This has now been fixed.

*   Fix a bug in the multi-controlled rotation circuit methods [`QuantumCircuit.mcrx()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.mcrx "qiskit.circuit.QuantumCircuit.mcrx"), [`QuantumCircuit.mcry()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.mcry "qiskit.circuit.QuantumCircuit.mcry"), and [`QuantumCircuit.mcrz()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.mcrz "qiskit.circuit.QuantumCircuit.mcrz"), when the user provides an unbounded parameter, as well as when calling [`RXGate.control()`](qiskit-circuit-library-rx-gate#qiskit.circuit.library.RXGate.control "qiskit.circuit.library.RXGate.control"), [`RYGate.control()`](qiskit-circuit-library-ry-gate#qiskit.circuit.library.RYGate.control "qiskit.circuit.library.RYGate.control") or [`RZGate.control()`](qiskit-circuit-library-rz-gate#qiskit.circuit.library.RZGate.control "qiskit.circuit.library.RZGate.control") where the rotation angle is a [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"). Previously, the user got an error that this gate cannot be synthesized with unbound parameter, and now these multi-controlled rotation circuits can be synthesized without raising an error.

*   The [`PauliEvolutionGate`](qiskit-circuit-library-pauli-evolution-gate#qiskit.circuit.library.PauliEvolutionGate "qiskit.circuit.library.PauliEvolutionGate"), if used with a product formula synthesis (this is the default), did not correctly handle all-identity terms in the operator. The all-identity term should introduce a global phase equal to `-evolution_time`, but was off by a factor of 2 and could break for parameterized times. This behavior is now fixed. Fixed [#13625](https://github.com/Qiskit/qiskit/issues/13625).

*   Fixed an inconsistency in the circuit generated by a Pauli evolution synthesis with [`SuzukiTrotter`](qiskit-synthesis-suzuki-trotter#qiskit.synthesis.SuzukiTrotter "qiskit.synthesis.SuzukiTrotter") or [`LieTrotter`](qiskit-synthesis-lie-trotter#qiskit.synthesis.LieTrotter "qiskit.synthesis.LieTrotter") (the default) method. For parameterized evolution times, the resulting circuits contained parameters with a spurious, zero complex part, which affected the output of [`ParameterExpression.sympify()`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression.sympify "qiskit.circuit.ParameterExpression.sympify"). The output now correctly is only real. Fixed [#13642](https://github.com/Qiskit/qiskit/pull/13642).

*   Fixed a bug that caused [`PauliList.insert()`](qiskit-quantum-info-pauli-list#qiskit.quantum_info.PauliList.insert "qiskit.quantum_info.PauliList.insert") with `qubit=True` to produce a phase attribute with the wrong shape when the original object was length 1. Fixed [#13623](https://github.com/Qiskit/qiskit/issues/13623).

*   Fixed a bug in the [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") transpiler pass, where gates close to identity up to a global phase were removed from the circuit, but the global phase of the circuit was not updated. In particular, [`RemoveIdentityEquivalent`](qiskit-transpiler-passes-remove-identity-equivalent#qiskit.transpiler.passes.RemoveIdentityEquivalent "qiskit.transpiler.passes.RemoveIdentityEquivalent") now removes non-parameterized [`GlobalPhaseGate`](qiskit-circuit-library-global-phase-gate#qiskit.circuit.library.GlobalPhaseGate "qiskit.circuit.library.GlobalPhaseGate") gates.

*   Circuits compiled using a preset passmanager constructed by [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") will now correctly retain their [`name`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.name "qiskit.circuit.QuantumCircuit.name") attribute, as they do with [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile").

*   Fix a bug in [`qasm3.Exporter`](qasm-3#qiskit.qasm3.Exporter "qiskit.qasm3.Exporter") that caused the exporter to crash when handling a unitary gate due to incorrect processing of its `params` field.

*   Fixed a bug in [`random_clifford()`](quantum-info#qiskit.quantum_info.random_clifford "qiskit.quantum_info.random_clifford") that stopped it from sampling the full Clifford group.

*   Fixed a bug in the [`Target.instruction_supported()`](qiskit-transpiler-target#qiskit.transpiler.Target.instruction_supported "qiskit.transpiler.Target.instruction_supported") method where targets with `self.num_qubits==None` would always return `false` independently of the supported basis set.

*   Fixed a bug in the [`UnitarySynthesis`](qiskit-transpiler-passes-unitary-synthesis#qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass, where blocks of [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate")s on 3 qubits or more were not correctly synthesized. This led, e.g., to the circuit being overwritten with the last processed block or to internal panics when encountering measurements after such a block. Fixed [#13586](https://github.com/Qiskit/qiskit/issues/13586).

*   Fixed a bug in the [`UnitarySynthesis`](qiskit-transpiler-passes-unitary-synthesis#qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass where non-2-qubit gates would be included in the available 2 qubit basis, causing the `TwoQubitWeylDecomposition` to panic because of the dimension mismatch.

*   Fixed a bug that caused [`Statevector.expectation_value()`](qiskit-quantum-info-statevector#qiskit.quantum_info.Statevector.expectation_value "qiskit.quantum_info.Statevector.expectation_value") to yield incorrect results for the identity operator when the statevector was not normalized.

*   Calling an [`AnalysisPass`](qiskit-transpiler-analysis-pass#qiskit.transpiler.AnalysisPass "qiskit.transpiler.AnalysisPass") or a [`TransformationPass`](qiskit-transpiler-transformation-pass#qiskit.transpiler.TransformationPass "qiskit.transpiler.TransformationPass") like a function (as in `pass_ = MyPass(); pass_(qc)`) will now respect any requirements that the pass might have. For example, scheduling passes such as [`ALAPScheduleAnalysis`](qiskit-transpiler-passes-alap-schedule-analysis#qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis") require that [`TimeUnitConversion`](qiskit-transpiler-passes-time-unit-conversion#qiskit.transpiler.passes.TimeUnitConversion "qiskit.transpiler.passes.TimeUnitConversion") runs before them. Running the pass via a [`PassManager`](qiskit-transpiler-pass-manager#qiskit.transpiler.PassManager "qiskit.transpiler.PassManager") always respected this requirement, but until this note, it was not respected by calling the pass directly.

*   When a [`TranspilerError`](transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") subclass is raised by a pass inside a call to `PassManger.run()`, the exception will now be propagated through losslessly, rather than becoming a chained exception with an erased type.

*   [`SabreSwap`](qiskit-transpiler-passes-sabre-swap#qiskit.transpiler.passes.SabreSwap "qiskit.transpiler.passes.SabreSwap") will no longer contract idle qubit wires out of control-flow blocks during routing. This was generally a valid optimization, but not an expected side effect of a routing pass. You can now use the [`ContractIdleWiresInControlFlow`](qiskit-transpiler-passes-contract-idle-wires-in-control-flow#qiskit.transpiler.passes.ContractIdleWiresInControlFlow "qiskit.transpiler.passes.ContractIdleWiresInControlFlow") pass to perform this contraction.

*   When [`SabreLayout`](qiskit-transpiler-passes-sabre-layout#qiskit.transpiler.passes.SabreLayout "qiskit.transpiler.passes.SabreLayout") is used to do both layout and routing simultaneously (as is the case for the default options to [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager")) on a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") or [`CouplingMap`](qiskit-transpiler-coupling-map#qiskit.transpiler.CouplingMap "qiskit.transpiler.CouplingMap") with disjoint connectivity, and the input circuit fits into a single component of the coupling map, the routing permutation will now be tracked correctly.

    Previously, any qubits in the coupling map that were not connected, even indirectly, to a qubit used by the routed circuit would not be included in the final routing permutation. This could cause surprising behaviour a long way from the point of failure, even if compilation appeared to succeed, such as calls to [`TranspileLayout.final_index_layout()`](qiskit-transpiler-transpile-layout#qiskit.transpiler.TranspileLayout.final_index_layout "qiskit.transpiler.TranspileLayout.final_index_layout") raising [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError "(in Python v3.13)").

    This bug did not affect backends that were fully connected, as most are.

*   Fixed a bug where a initializing [`SparsePauliOp`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp "qiskit.quantum_info.SparsePauliOp") with a large number of Pauli-`Y` terms (typically $\geq 100$) and no explicit `coeffs` would result in a coefficient close to 1 but with a floating point error. The coefficient is now correctly 1 per default. Fixed [#13522](https://github.com/Qiskit/qiskit/issues/13522).

*   Fixed a per-process based non-determinism in SparsePauliOp.to\_matrix. The exact order of the floating-point operations in the summation would previously vary per process, but will now be identical between different invocations of the same script. See [#13413](https://github.com/Qiskit/qiskit/issues/13413).

*   Fixed a bug in [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") that would cause output [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes to become input nodes during `deepcopy` and pickling.

<span id="rc1" />

<span id="relnotes-1-1-0rc1" />

## 1.1.0rc1

<span id="relnotes-1-1-0rc1-new-features" />

<span id="id5" />

### New Features

*   Extended the commutation analysis performed by [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") to only operate on hardware circuits to also work with abstract circuits, i.e. each operation in the input quantum circuit is now checked for its matrix representation before proceeding to the analysis. In addition, the operation is now checked for its ability to be cached in the session commutation library. For example, this now enables computing whether [`AnnotatedOperation`](qiskit-circuit-annotated-operation#qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") commute. This enables transpiler passes that rely on [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") internally, such as [`CommutativeCancellation`](qiskit-transpiler-passes-commutative-cancellation#qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation"), during earlier stages of a default transpilation pipeline (prior to basis translation).

*   The methods [`power()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.power "qiskit.circuit.QuantumCircuit.power"), [`power()`](qiskit-circuit-gate#qiskit.circuit.Gate.power "qiskit.circuit.Gate.power"), as well as the similar methods of subclasses of [`Gate`](qiskit-circuit-gate#qiskit.circuit.Gate "qiskit.circuit.Gate") (such as of [`SGate`](qiskit-circuit-library-s-gate#qiskit.circuit.library.SGate "qiskit.circuit.library.SGate")) all have an additional argument `annotated`. The default value of `False` corresponds to the existing behavior. Furthermore, for standard gates with an explicitly defined `power` method, the argument `annotated` has no effect, for example both `SGate().power(1.5, annotated=False)` and `SGate().power(1.5, annotated=True)` return a `PhaseGate`. The difference manifests for gates without an explicitly defined power method. The value of `False` returns a [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate"), just as before, while the value of `True` returns an [`AnnotatedOperation`](qiskit-circuit-annotated-operation#qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") that represents the instruction modified with the “power modifier”.

*   The implementation [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2") of [`BaseEstimatorV2`](qiskit-primitives-base-estimator-v2#qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2") was added. This estimator supports `BackendV1` and [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2").

    ```python
    import numpy as np
    from qiskit import transpile
    from qiskit.circuit.library import IQP
    from qiskit.primitives import BackendEstimatorV2
    from qiskit.providers.fake_provider import Fake7QPulseV1
    from qiskit.quantum_info import SparsePauliOp, random_hermitian

    backend = Fake7QPulseV1()
    estimator = BackendEstimatorV2(backend=backend)
    n_qubits = 5
    mat = np.real(random_hermitian(n_qubits, seed=1234))
    circuit = IQP(mat)
    observable = SparsePauliOp("Z" * n_qubits)
    isa_circuit = transpile(circuit, backend=backend, optimization_level=1)
    isa_observable = observable.apply_layout(isa_circuit.layout)
    job = estimator.run([(isa_circuit, isa_observable)], precision=0.01)
    result = job.result()
    print(f"> Expectation value: {result[0].data.evs}")
    print(f"> Standard error: {result[0].data.stds}")
    print(f"> Metadata: {result[0].metadata}")
    ```

*   The implementation [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2") of [`BaseSamplerV2`](qiskit-primitives-base-sampler-v2#qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2") was added. This sampler supports `BackendV1` and [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") that allow `memory` option to compute bitstrings.

    ```python
    import numpy as np
    from qiskit import transpile
    from qiskit.circuit.library import IQP
    from qiskit.primitives import BackendSamplerV2
    from qiskit.providers.fake_provider import Fake7QPulseV1
    from qiskit.quantum_info import random_hermitian

    backend = Fake7QPulseV1()
    sampler = BackendSamplerV2(backend=backend)
    n_qubits = 5
    mat = np.real(random_hermitian(n_qubits, seed=1234))
    circuit = IQP(mat)
    circuit.measure_all()
    isa_circuit = transpile(circuit, backend=backend, optimization_level=1)
    job = sampler.run([isa_circuit], shots=100)
    result = job.result()
    print(f"> bitstrings: {result[0].data.meas.get_bitstrings()}")
    print(f"> counts: {result[0].data.meas.get_counts()}")
    print(f"> Metadata: {result[0].metadata}")
    ```

*   Added `ctrl_state` parameter to `QuantumCircuit.mcp()` and `MCPhaseGate()`.

    The `QuantumCircuit.mcp()` function and `MCPhaseGate()` have been updated to include a `ctrl_state` parameter. This enhancement allows users to specify the control state of the multi-controlled phase gate. The parameter can accept either a decimal value or a bitstring and defaults to controlling the ‘1’ state if not provided.

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(4)
    qc.mcp(0.2,[0,1,2],3,ctrl_state=2)
    ```

*   The transpiler pass [`ElidePermutations`](qiskit-transpiler-passes-elide-permutations#qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations") runs by default with optimization level 2 and 3. Intuitively, removing [`SwapGate`](qiskit-circuit-library-swap-gate#qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate")s and [`PermutationGate`](qiskit-circuit-library-permutation-gate#qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate")s in a virtual circuit is almost always beneficial, as it makes the circuit shorter and easier to route. As `OptimizeSwapBeforeMeasure` is a special case of [`ElidePermutations`](qiskit-transpiler-passes-elide-permutations#qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations"), it has been removed from optimization level 3.

*   Added a new optimization transpiler pass, [`ElidePermutations`](qiskit-transpiler-passes-elide-permutations#qiskit.transpiler.passes.ElidePermutations "qiskit.transpiler.passes.ElidePermutations"), which is designed to run prior to the [Layout stage](transpiler#transpiler-preset-stage-layout) and will optimize away any [`SwapGate`](qiskit-circuit-library-swap-gate#qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate")s and [`PermutationGate`](qiskit-circuit-library-permutation-gate#qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate")s in a circuit by permuting virtual qubits. For example, taking a circuit with [`SwapGate`](qiskit-circuit-library-swap-gate#qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate")s:

    ![\_images/release\_notes-7.png](/images/api/qiskit-c/release_notes-7.avif)

    will remove the swaps when the pass is run:

    ```python
    from qiskit.transpiler.passes import ElidePermutations
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(3)
    qc.h(0)
    qc.swap(0, 1)
    qc.swap(2, 0)
    qc.cx(1, 0)
    qc.measure_all()

    ElidePermutations()(qc).draw("mpl")
    ```

    ![\_images/release\_notes-8.png](/images/api/qiskit-c/release_notes-8.avif)

    The pass also sets the `virtual_permutation_layout` property set, storing the permutation of the virtual qubits that was optimized away.

*   The [`KMSSynthesisLinearFunction`](qiskit-transpiler-passes-synthesis-hls-plugins-kms-synthesis-linear-function#qiskit.transpiler.passes.synthesis.hls_plugins.KMSSynthesisLinearFunction "qiskit.transpiler.passes.synthesis.hls_plugins.KMSSynthesisLinearFunction") plugin for synthesizing [`LinearFunction`](qiskit-circuit-library-linear-function#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") objects now accepts two additional options `use_inverted` and `use_transposed`. These option modify the matrix on which the underlying synthesis algorithm runs by possibly inverting and/or transposing it, and then suitably adjust the synthesized circuit. By varying these options, we generally get different synthesized circuits, and in cases may obtain better results than for their default values.

*   The [`PMHSynthesisLinearFunction`](qiskit-transpiler-passes-synthesis-hls-plugins-pmh-synthesis-linear-function#qiskit.transpiler.passes.synthesis.hls_plugins.PMHSynthesisLinearFunction "qiskit.transpiler.passes.synthesis.hls_plugins.PMHSynthesisLinearFunction") plugin for synthesizing [`LinearFunction`](qiskit-circuit-library-linear-function#qiskit.circuit.library.LinearFunction "qiskit.circuit.library.LinearFunction") objects now accepts several additional options. The option `section_size` is passed to the underlying synthesis method. The options `use_inverted` and `use_transposed` modify the matrix on which the underlying synthesis algorithm runs by possibly inverting and/or transposing it, and then suitably adjust the synthesized circuit. By varying these options, we generally get different synthesized circuits, and in cases may obtain better results than for their default values.

*   The [`HLSConfig`](qiskit-transpiler-passes-hls-config#qiskit.transpiler.passes.HLSConfig "qiskit.transpiler.passes.HLSConfig") now has two additional optional arguments. The argument `plugin_selection` can be set either to `"sequential"` or to `"all"`. If set to “sequential” (default), for every higher-level-object the [`HighLevelSynthesis`](qiskit-transpiler-passes-high-level-synthesis#qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") pass will consider the specified methods sequentially, in the order they appear in the list, stopping at the first method that is able to synthesize the object. If set to “all”, all the specified methods will be considered, and the best synthesized circuit, according to `plugin_evaluation_fn` will be chosen. The argument `plugin_evaluation_fn` is an optional callable that evaluates the quality of the synthesized quantum circuit; a smaller value means a better circuit. When set to `None`, the quality of the circuit is its size (i.e. the number of gates that it contains).

    The following example illustrates the new functionality:

    ```c
    from qiskit import QuantumCircuit
    from qiskit.circuit.library import LinearFunction
    from qiskit.synthesis.linear import random_invertible_binary_matrix
    from qiskit.transpiler.passes import HighLevelSynthesis, HLSConfig

    # Create a circuit with a linear function
    mat = random_invertible_binary_matrix(7, seed=37)
    qc = QuantumCircuit(7)
    qc.append(LinearFunction(mat), [0, 1, 2, 3, 4, 5, 6])

    # Run different methods with different parameters,
    # choosing the best result in terms of depth.
    hls_config = HLSConfig(
        linear_function=[
            ("pmh", {}),
            ("pmh", {"use_inverted": True}),
            ("pmh", {"use_transposed": True}),
            ("pmh", {"use_inverted": True, "use_transposed": True}),
            ("pmh", {"section_size": 1}),
            ("pmh", {"section_size": 3}),
            ("kms", {}),
            ("kms", {"use_inverted": True}),
        ],
        plugin_selection="all",
        plugin_evaluation_fn=lambda circuit: circuit.depth(),
    )

    # synthesize
    qct = HighLevelSynthesis(hls_config=hls_config)(qc)
    ```

    In the example, we run multiple synthesis methods with different parameters, choosing the best circuit in terms of depth. Note that optimizing `circuit.size()` instead would pick a different circuit.

*   Added ctrl\_state parameter to `QuantumCircuit.mcx()`.

    The `QuantumCircuit.mcx()` function in the quantum circuit library has been enhanced to include a ctrl\_state parameter, allowing users to specify the control state of the multi-controlled X gate. This parameter can accept either a decimal value or a bitstring and defaults to controlling the ‘1’ state if not provided.

    ```python
    from qiskit import QuantumCircuit

    qc = QuantumCircuit(3, 3)
    qc.mcx([0, 1], 2, ctrl_state="00")
    ```

*   Added the [`CommutativeCancellation`](qiskit-transpiler-passes-commutative-cancellation#qiskit.transpiler.passes.CommutativeCancellation "qiskit.transpiler.passes.CommutativeCancellation") pass to the `init` stage of the preset pass managers for optimization levels 2 and 3. This enables the preset pass managers to cancel additional logical operations at the beginning of the compilation pipeline.

*   Added a new method [`Layout.inverse()`](qiskit-transpiler-layout#qiskit.transpiler.Layout.inverse "qiskit.transpiler.Layout.inverse") which is used for taking the inverse of a [`Layout`](qiskit-transpiler-layout#qiskit.transpiler.Layout "qiskit.transpiler.Layout") object. Added a new method [`Layout.compose()`](qiskit-transpiler-layout#qiskit.transpiler.Layout.compose "qiskit.transpiler.Layout.compose") which is used for composing two [`Layout`](qiskit-transpiler-layout#qiskit.transpiler.Layout "qiskit.transpiler.Layout") objects together. Added a new method [`Layout.to_permutation()`](qiskit-transpiler-layout#qiskit.transpiler.Layout.to_permutation "qiskit.transpiler.Layout.to_permutation") which is used for creating a permutation corresponding to a [`Layout`](qiskit-transpiler-layout#qiskit.transpiler.Layout "qiskit.transpiler.Layout") object.

*   This release of Qiskit finalizes support for NumPy 2.0. Qiskit will continue to support both Numpy 1.x and 2.x for the foreseeable future.

*   Added a new reduction to the [`OptimizeAnnotated`](qiskit-transpiler-passes-optimize-annotated#qiskit.transpiler.passes.OptimizeAnnotated "qiskit.transpiler.passes.OptimizeAnnotated") transpiler pass. This reduction looks for annotated operations (objects of type [`AnnotatedOperation`](qiskit-circuit-annotated-operation#qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") that consist of a base operation `B` and a list `M` of control, inverse and power modifiers) with the following properties:

    *   the base operation `B` needs to be synthesized (i.e. it’s not already supported by the target or belongs to the equivalence library)
    *   the definition circuit for `B` can be expressed as `P -- Q -- R` with $R = P^{-1}$

    In this case the modifiers can be moved to the `Q`-part only. As a specific example, controlled QFT-based adders have the form `control - [QFT -- U -- IQFT]`, which can be simplified to `QFT -- control-[U] -- IQFT`. By removing the controls over `QFT` and `IQFT` parts of the circuit, one obtains significantly fewer gates in the transpiled circuit.

*   Added two new methods to the [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") class: [`qiskit.dagcircuit.DAGCircuit.op_successors()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.op_successors "qiskit.dagcircuit.DAGCircuit.op_successors") returns an iterator to [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") successors of a node, and [`qiskit.dagcircuit.DAGCircuit.op_successors()`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit.op_successors "qiskit.dagcircuit.DAGCircuit.op_successors") returns an iterator to [`DAGOpNode`](qiskit-dagcircuit-dag-op-node#qiskit.dagcircuit.DAGOpNode "qiskit.dagcircuit.DAGOpNode") predecessors of a node.

*   Added a new transpiler pass, [`RemoveFinalReset`](qiskit-transpiler-passes-remove-final-reset#qiskit.transpiler.passes.RemoveFinalReset "qiskit.transpiler.passes.RemoveFinalReset"), which will remove any [`Reset`](circuit#qiskit.circuit.Reset "qiskit.circuit.Reset") operation which is the final instruction on a qubit wire. For example, taking a circuit with final [`Reset`](circuit#qiskit.circuit.Reset "qiskit.circuit.Reset")s:

    ![\_images/release\_notes-9.png](/images/api/qiskit-c/release_notes-9.avif)

    will remove the final resets when the pass is run:

    ```python
    from qiskit.transpiler.passes import RemoveFinalReset
    from qiskit.circuit import QuantumCircuit

    qc = QuantumCircuit(3, 1)
    qc.reset(0)
    qc.h(range(3))
    qc.cx(1, 0)
    qc.measure(0, 0)
    qc.reset(range(3))
    RemoveFinalReset()(qc).draw("mpl")
    ```

    ![\_images/release\_notes-10.png](/images/api/qiskit-c/release_notes-10.avif)

*   The performance of [`SparsePauliOp.to_matrix()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.to_matrix "qiskit.quantum_info.SparsePauliOp.to_matrix") has been greatly improved for both dense and sparse forms. By default, both will now take advantage of threaded parallelism available on your system, subject to the `RAYON_NUM_THREADS` environment variable. You can temporarily force serial execution using the new `force_serial` Boolean argument to [`to_matrix()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.to_matrix "qiskit.quantum_info.SparsePauliOp.to_matrix").

*   Added a new transpiler pass [`StarPreRouting`](qiskit-transpiler-passes-star-pre-routing#qiskit.transpiler.passes.StarPreRouting "qiskit.transpiler.passes.StarPreRouting") which is designed to identify star connectivity subcircuits and then replace them with an optimal linear routing. This is useful for certain circuits that are composed of this circuit connectivity such as Bernstein Vazirani and QFT. For example:

    >

<span id="relnotes-1-1-0rc1-circuits-features" />

<span id="id6" />

### Circuits Features

*   A [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") can now contain typed classical variables:

    ```c
    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister
    from qiskit.circuit.classical import expr, types

    qr = QuantumRegister(2, "q")
    cr = ClassicalRegister(2, "c")
    qc = QuantumCircuit(qr, cr)
    # Add two input variables to the circuit with different types.
    a = qc.add_input("a", types.Bool())
    mask = qc.add_input("mask", types.Uint(2))

    # Test whether the input variable was true at runtime.
    with qc.if_test(a) as else_:
        qc.x(0)
    with else_:
        qc.h(0)

    qc.cx(0, 1)
    qc.measure(qr, cr)

    # Add a typed variable manually, initialized to the same value as the classical register.
    b = qc.add_var("b", expr.lift(cr))

    qc.reset([0, 1])
    qc.h(0)
    qc.cx(0, 1)
    qc.measure(qr, cr)

    # Store some calculated value into the `b` variable.
    qc.store(b, expr.bit_and(b, cr))
    # Test whether we had equality, up to a mask.
    with qc.if_test(expr.equal(expr.bit_and(b, mask), mask)):
        qc.x(0)
    ```

    These variables can be specified either as *inputs* to the circuit, or as scoped variables. The circuit object does not yet have support for representing typed classical-variable *outputs*, but this will be added later when hardware and the result interfaces are in more of a position to support it. Circuits that represent a block of an inner scope may also capture variables from outer scopes.

    A variable is a [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") node, which can now contain an arbitrary type, and represents a unique memory location within its live range when added to a circuit. These can be constructed in a circuit using [`QuantumCircuit.add_var()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.add_var "qiskit.circuit.QuantumCircuit.add_var") and [`add_input()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.add_input "qiskit.circuit.QuantumCircuit.add_input"), or at a lower level using [`Var.new()`](circuit-classical#qiskit.circuit.classical.expr.Var.new "qiskit.circuit.classical.expr.Var.new").

    Variables can be manually stored to, using the [`Store`](circuit#qiskit.circuit.Store "qiskit.circuit.Store") instruction and its corresponding circuit method [`QuantumCircuit.store()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.store "qiskit.circuit.QuantumCircuit.store"). This includes writing to [`Clbit`](circuit#qiskit.circuit.Clbit "qiskit.circuit.Clbit") and [`ClassicalRegister`](circuit#qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") instances wrapped in [`Var`](circuit-classical#qiskit.circuit.classical.expr.Var "qiskit.circuit.classical.expr.Var") nodes.

    Variables can be used wherever classical expressions (see [`qiskit.circuit.classical.expr`](circuit-classical#module-qiskit.circuit.classical.expr "qiskit.circuit.classical.expr")) are valid. Currently this is the target expressions of control-flow operations, though we plan to expand this to gate parameters in the future, as the type and expression system are expanded.

    See [Real-time classical computation](circuit#circuit-repr-real-time-classical) for more discussion of these variables, and the associated data model.

    These are supported throughout the transpiler, through QPY serialization ([`qiskit.qpy`](qpy#module-qiskit.qpy "qiskit.qpy")), OpenQASM 3 export ([`qiskit.qasm3`](qasm-3#module-qiskit.qasm3 "qiskit.qasm3")), and have initial support through the circuit visualizers (see [`QuantumCircuit.draw()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw")).

    <Admonition title="Note" type="note">
      The new classical variables and storage will take some time to become supported on hardware and simulator backends. They are not supported in the primitives interfaces ([`qiskit.primitives`](primitives#module-qiskit.primitives "qiskit.primitives")), but will likely inform those interfaces as they evolve.
    </Admonition>

*   The classical realtime-expressions module [`qiskit.circuit.classical`](circuit-classical#module-qiskit.circuit.classical "qiskit.circuit.classical") can now represent indexing and bitshifting of unsigned integers and bitlikes (e.g. [`ClassicalRegister`](circuit#qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")). For example, it is now possible to compare one register with the bitshift of another:

    ```c
    from qiskit.circuit import QuantumCircuit, ClassicalRegister
    from qiskit.circuit.classical import expr

    cr1 = ClassicalRegister(4, "cr1")
    cr2 = ClassicalRegister(4, "cr2")
    qc = QuantumCircuit(cr1, cr2)
    with qc.if_test(expr.equal(cr1, expr.shift_left(cr2, 2))):
        pass
    ```

    Qiskit can also represent a condition that dynamically indexes into a register:

    ```c
    with qc.if_test(expr.index(cr1, cr2)):
        pass
    ```

*   The construction performance of [`NLocal`](qiskit-circuit-library-n-local#qiskit.circuit.library.NLocal "qiskit.circuit.library.NLocal") and its derived circuit-library subclasses (e.g. [`EfficientSU2`](qiskit-circuit-library-efficient-su-2#qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2") and [`RealAmplitudes`](qiskit-circuit-library-real-amplitudes#qiskit.circuit.library.RealAmplitudes "qiskit.circuit.library.RealAmplitudes")) has significantly improved, when the rotation and/or entanglement subblocks are simple applications of a single Qiskit standard-library gate. Since these circuits are constructed lazily, you might not see the improvement immediately on instantiation of the class, but instead on first access to its internal structure. Performance improvements are on the order of ten times faster.

*   [`QuantumCircuit.append()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.append "qiskit.circuit.QuantumCircuit.append") now has a `copy` keyword argument, which defaults to `True`. When an instruction with runtime parameters ([`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression")s) is appended to a circuit, by default, the circuit has always created a copy of the instruction so that if [`QuantumCircuit.assign_parameters()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") attempts to mutate the instruction in place, it does not affect other references to the same instruction. Now, setting `copy=False` allows you to override this, so you can avoid the copy penalty if you know your instructions will not be used in other locations.

*   [`QuantumCircuit.compose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose") now has a `copy` keyword argument, which defaults to `True`. By default, [`compose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose") copies all instructions, so that mutations from one circuit do not affect any other. If `copy=False`, then instructions from the other circuit will become directly owned by the new circuit, which may involve mutating them in place. The other circuit must not be used afterwards, in this case.

*   Construction time for [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") circuits has been significantly improved, on the order of 10x or a bit more. The internal SU4 gates will now also use more bits of randomness during their generation, leading to more representative volume circuits, especially at large widths and depths.

*   [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") now has a `flatten` keyword argument. This defaults to `False`, where the constructed circuit contains a single instruction that in turn contains the actual volume structure. If set `True`, the circuit will directly have the volumetric SU4 matrices.

*   [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") now accepts an optional `num_qubits` argument. The only effect of this is to skip the inference of the qubit count, which can be helpful for performance when many gates are being constructed.

*   All of the “standard gates” in the circuit library ([`qiskit.circuit.library`](circuit-library#module-qiskit.circuit.library "qiskit.circuit.library")) can now be specified by string name for the entangling operations in [`TwoLocal`](qiskit-circuit-library-two-local#qiskit.circuit.library.TwoLocal "qiskit.circuit.library.TwoLocal") circuits, such as [`RealAmplitudes`](qiskit-circuit-library-real-amplitudes#qiskit.circuit.library.RealAmplitudes "qiskit.circuit.library.RealAmplitudes") and [`EfficientSU2`](qiskit-circuit-library-efficient-su-2#qiskit.circuit.library.EfficientSU2 "qiskit.circuit.library.EfficientSU2").

<span id="relnotes-1-1-0rc1-primitives-features" />

<span id="id7" />

### Primitives Features

*   Version 2 of the primitives is introduced via a new base class for both the sampler and the estimator, along with new types for their inputs and outputs. The emphasis of this new version is on performing vectorized calls to the primitive `run()` methods, so that sweeps over parameter value sets and observables can be efficiently specified. See [`StatevectorSampler`](qiskit-primitives-statevector-sampler#qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler") and [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator") for reference implementations of the V2 primitives.

    Moreover, the estimator has gained a `precision` argument in the [`run()`](qiskit-primitives-base-estimator-v2#qiskit.primitives.BaseEstimatorV2.run "qiskit.primitives.BaseEstimatorV2.run") method that specifies the targeted precision of the expectation value estimates. Analogously, the sampler has moved `shots` out of the options and into the arguments of the [`run()`](qiskit-primitives-base-sampler-v2#qiskit.primitives.BaseSamplerV2.run "qiskit.primitives.BaseSamplerV2.run") method. The sampler has also been changed to return the outputs (e.g. bitstrings) from every shot, rather than providing a [`Counts`](qiskit-result-counts#qiskit.result.Counts "qiskit.result.Counts")-like return, and also to store data from separate [`ClassicalRegister`](circuit#qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")s . This enables derived classes to implement sampler support for circuits with classical control flow.

    The primitive V2 base classes are:

    *   [`BaseSamplerV2`](qiskit-primitives-base-sampler-v2#qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2")
    *   [`BaseEstimatorV2`](qiskit-primitives-base-estimator-v2#qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2")

    The new types which are used for inputs and outputs are:

    *   `SamplerPubLike`: primitive unified bloc (PUB) of sampler inputs; a union type of allowed inputs to a sampler
    *   `EstimatorPubLike`: Primitive unified bloc (PUB) of estimator inputs; a union type of allowed inputs to an estimator
    *   [`PubResult`](qiskit-primitives-pub-result#qiskit.primitives.PubResult "qiskit.primitives.PubResult"): the data and metadata resulting from a single PUB’s execution
    *   [`DataBin`](qiskit-primitives-data-bin#qiskit.primitives.DataBin "qiskit.primitives.DataBin"): A namespace to hold data from a single PUB’s execution
    *   [`BitArray`](qiskit-primitives-bit-array#qiskit.primitives.BitArray "qiskit.primitives.BitArray"): an array-valued collection of bit values in a dense format
    *   [`PrimitiveResult`](qiskit-primitives-primitive-result#qiskit.primitives.PrimitiveResult "qiskit.primitives.PrimitiveResult"): an iterable of [`PubResult`](qiskit-primitives-pub-result#qiskit.primitives.PubResult "qiskit.primitives.PubResult")s along with metadata

*   The reference implementation [`StatevectorEstimator`](qiskit-primitives-statevector-estimator#qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator") of [`BaseEstimatorV2`](qiskit-primitives-base-estimator-v2#qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2") was added. As seen in the example below, this estimator (and all V2 estimators) supports providing arrays of observables and/or arrays of parameter value sets that are attached to particular circuits.

    Each tuple of `(circuit, observables, <optional> parameter values, <optional> precision)`, called an estimator primitive unified bloc (PUB), produces its own array-based result. The `run()` method can be given many pubs at once.

    ```python
    from qiskit.circuit import Parameter, QuantumCircuit
    from qiskit.primitives import StatevectorEstimator
    from qiskit.quantum_info import Pauli, SparsePauliOp

    import matplotlib.pyplot as plt
    import numpy as np

    # Define a circuit with two parameters.
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.ry(Parameter("a"), 0)
    circuit.rz(Parameter("b"), 0)
    circuit.cx(0, 1)
    circuit.h(0)

    # Define a sweep over parameter values, where the second axis is over
    # the two parameters in the circuit.
    params = np.vstack([
        np.linspace(-np.pi, np.pi, 100),
        np.linspace(-4 * np.pi, 4 * np.pi, 100)
    ]).T

    # Define three observables. Many formats are supported here including
    # classes such as qiskit.quantum_info.SparsePauliOp. The inner length-1
    # lists cause this array of observables to have shape (3, 1), rather
    # than shape (3,) if they were omitted.
    observables = [
        [SparsePauliOp(["XX", "IY"], [0.5, 0.5])],
        [Pauli("XX")],
        [Pauli("IY")]
    ]

    # Instantiate a new statevector simulation based estimator object.
    estimator = StatevectorEstimator()

    # Estimate the expectation value for all 300 combinations of
    # observables and parameter values, where the pub result will have
    # shape (3, 100). This shape is due to our array of parameter
    # bindings having shape (100,), combined with our array of observables
    # having shape (3, 1)
    pub = (circuit, observables, params)
    job = estimator.run([pub])

    # Extract the result for the 0th pub (this example only has one pub).
    result = job.result()[0]

    # Error-bar information is also available, but the error is 0
    # for this StatevectorEstimator.
    result.data.stds

    # Pull out the array-based expectation value estimate data from the
    # result and plot a trace for each observable.
    for idx, pauli in enumerate(observables):
        plt.plot(result.data.evs[idx], label=pauli)
    plt.legend()
    ```

*   The reference implementation [`StatevectorSampler`](qiskit-primitives-statevector-sampler#qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler") of [`BaseSamplerV2`](qiskit-primitives-base-sampler-v2#qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2") was added. As seen in the example below, this sampler (and all V2 samplers) supports providing arrays of parameter value sets to bind against a single circuit.

    Each tuple of `(circuit, <optional> parameter values, <optional> shots)`, called a sampler primitive unified bloc (PUB), produces its own array-based result. The `run()` method can be given many pubs at once.

    ```python
    from qiskit.circuit import (
        Parameter, QuantumCircuit, ClassicalRegister, QuantumRegister
    )
    from qiskit.primitives import StatevectorSampler

    import matplotlib.pyplot as plt
    import numpy as np

    # Define our circuit registers, including classical registers
    # called 'alpha' and 'beta'.
    qreg = QuantumRegister(3)
    alpha = ClassicalRegister(2, "alpha")
    beta = ClassicalRegister(1, "beta")

    # Define a quantum circuit with two parameters.
    circuit = QuantumCircuit(qreg, alpha, beta)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.cx(1, 2)
    circuit.ry(Parameter("a"), 0)
    circuit.rz(Parameter("b"), 0)
    circuit.cx(1, 2)
    circuit.cx(0, 1)
    circuit.h(0)
    circuit.measure([0, 1], alpha)
    circuit.measure([2], beta)

    # Define a sweep over parameter values, where the second axis is over.
    # the two parameters in the circuit.
    params = np.vstack([
        np.linspace(-np.pi, np.pi, 100),
        np.linspace(-4 * np.pi, 4 * np.pi, 100)
    ]).T

    # Instantiate a new statevector simulation based sampler object.
    sampler = StatevectorSampler()

    # Start a job that will return shots for all 100 parameter value sets.
    pub = (circuit, params)
    job = sampler.run([pub], shots=256)

    # Extract the result for the 0th pub (this example only has one pub).
    result = job.result()[0]

    # There is one BitArray object for each ClassicalRegister in the
    # circuit. Here, we can see that the BitArray for alpha contains data
    # for all 100 sweep points, and that it is indeed storing data for 2
    # bits over 256 shots.
    assert result.data.alpha.shape == (100,)
    assert result.data.alpha.num_bits == 2
    assert result.data.alpha.num_shots == 256

    # We can work directly with a binary array in performant applications.
    raw = result.data.alpha.array

    # For small registers where it is anticipated to have many counts
    # associated with the same bitstrings, we can turn the data from,
    # for example, the 22nd sweep index into a dictionary of counts.
    counts = result.data.alpha.get_counts(22)

    # Or, convert into a list of bitstrings that preserve shot order.
    bitstrings = result.data.alpha.get_bitstrings(22)
    print(bitstrings)
    ```

*   Added methods to join multiple [`BitArray`](qiskit-primitives-bit-array#qiskit.primitives.BitArray "qiskit.primitives.BitArray") objects along various axes.

    *   [`concatenate()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.concatenate "qiskit.primitives.BitArray.concatenate"): join arrays along an existing axis of the arrays.
    *   [`concatenate_bits()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.concatenate_bits "qiskit.primitives.BitArray.concatenate_bits"): join arrays along the bit axis.
    *   [`concatenate_shots()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.concatenate_shots "qiskit.primitives.BitArray.concatenate_shots"): join arrays along the shots axis.

    ```c
    ba = BitArray.from_samples(['00', '11'])
    print(ba)
    # BitArray(<shape=(), num_shots=2, num_bits=2>)

    # reshape the bit array because `concatenate` requires an axis.
    ba_ = ba.reshape(1, 2)
    print(ba_)
    # BitArray(<shape=(1,), num_shots=2, num_bits=2>)

    ba2 = BitArray.concatenate([ba_, ba_])
    print(ba2.get_bitstrings())
    # ['00', '11', '00', '11']

    # `concatenate_bits` and `concatenates_shots` do not require any axis.

    ba3 = BitArray.concatenate_bits([ba, ba])
    print(ba3.get_bitstrings())
    # ['0000', '1111']

    ba4 = BitArray.concatenate_shots([ba, ba])
    print(ba4.get_bitstrings())
    # ['00', '11', '00', '11']
    ```

*   Added methods to generate a subset of [`BitArray`](qiskit-primitives-bit-array#qiskit.primitives.BitArray "qiskit.primitives.BitArray") object by slicing along various axes.

    *   `__getitem__()`: slice the array along an existing axis of the array.
    *   [`slice_bits()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.slice_bits "qiskit.primitives.BitArray.slice_bits"): slice the array along the bit axis.
    *   [`slice_shots()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.slice_shots "qiskit.primitives.BitArray.slice_shots"): slice the array along the shot axis.

    ```c
    ba = BitArray.from_samples(['0000', '0001', '0010', '0011'], 4)
    print(ba)
    # BitArray(<shape=(), num_shots=4, num_bits=4>)
    print(ba.get_bitstrings())
    # ['0000', '0001', '0010', '0011']

    ba2 = ba.reshape(2, 2)
    print(ba2)
    # BitArray(<shape=(2,), num_shots=2, num_bits=2>)
    print(ba2[0].get_bitstrings())
    # ['0000', '0001']
    print(ba2[1].get_bitstrings())
    # ['0010', '0011']

    ba3 = ba.slice_bits([0, 2])
    print(ba3.get_bitstrings())
    # ['00', '01', '00', '01']

    ba4 = ba.slice_shots([0, 2])
    print(ba3.get_bitstrings())
    # ['0000', '0010']
    ```

*   Added a method [`transpose()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.transpose "qiskit.primitives.BitArray.transpose") to transpose a [`BitArray`](qiskit-primitives-bit-array#qiskit.primitives.BitArray "qiskit.primitives.BitArray").

    ```c
    ba = BitArray.from_samples(['00', '11']).reshape(2, 1, 1)
    print(ba)
    # BitArray(<shape=(2, 1), num_shots=1, num_bits=2>)
    print(ba.transpose())
    # BitArray(<shape=(1, 2), num_shots=1, num_bits=2>)
    ```

*   Added a method [`expectation_values()`](qiskit-primitives-bit-array#qiskit.primitives.BitArray.expectation_values "qiskit.primitives.BitArray.expectation_values") to compute expectation values of diagonal operators.

    ```c
    ba = BitArray.from_samples(['01', '11'])
    print(ba.expectation_values(["IZ", "ZI", "01"]))
    # [-1.   0.   0.5]
    ```

*   qiskit.primitives.containers.DataBin now satisfies the qiskit.primitives.containers.Shaped protocol. This means that every DataBin instance now has the additional attributes \* shape: tuple\[int, …] the leading shape of every entry in the instance \* ndim: int the length of shape \* size: int the product of the entries of shape The shape can be passed to the constructor.

*   Added mapping-like features to [`DataBin`](qiskit-primitives-data-bin#qiskit.primitives.DataBin "qiskit.primitives.DataBin"), i.e., `__getitem__`, `__contains__`, `__iter__`, [`keys()`](qiskit-primitives-data-bin#qiskit.primitives.DataBin.keys "qiskit.primitives.DataBin.keys"), [`values()`](qiskit-primitives-data-bin#qiskit.primitives.DataBin.values "qiskit.primitives.DataBin.values"), and [`items()`](qiskit-primitives-data-bin#qiskit.primitives.DataBin.items "qiskit.primitives.DataBin.items").

    ```python
    from qiskit import QuantumCircuit
    from qiskit.primitives import StatevectorSampler

    circuit = QuantumCircuit(1)
    circuit.h(0)
    circuit.measure_all()

    sampler = StatevectorSampler()
    result = sampler.run([circuit]).result()
    databin = result[0].data
    for creg, arr in databin.items():
        print(creg, arr)
    for creg in databin:
        print(creg, databin[creg])
    ```

*   The subclass [`SamplerPubResult`](qiskit-primitives-sampler-pub-result#qiskit.primitives.SamplerPubResult "qiskit.primitives.SamplerPubResult") of [`PubResult`](qiskit-primitives-pub-result#qiskit.primitives.PubResult "qiskit.primitives.PubResult") was added, which [`BaseSamplerV2`](qiskit-primitives-base-sampler-v2#qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2") implementations can return. The main feature added in this new subclass is [`join_data()`](qiskit-primitives-sampler-pub-result#qiskit.primitives.SamplerPubResult.join_data "qiskit.primitives.SamplerPubResult.join_data"), which joins together (a subset of) the contents of [`data`](qiskit-primitives-pub-result#qiskit.primitives.PubResult.data "qiskit.primitives.PubResult.data") into a single object. This enables the following patterns:

    ```python
    job_result =  sampler.run([pub1, pub2, pub3], shots=123).result()

    # assuming all returned data entries are BitArrays
    counts1 = job_result[0].join_data().get_counts()
    bistrings2 = job_result[1].join_data().get_bitstrings()
    array3 = job_result[2].join_data().array
    ```

<span id="relnotes-1-1-0rc1-providers-features" />

<span id="id8" />

### Providers Features

*   The [`BasicSimulator`](qiskit-providers-basic-provider-basic-simulator#qiskit.providers.basic_provider.BasicSimulator "qiskit.providers.basic_provider.BasicSimulator") python-based simulator included in [`qiskit.providers.basic_provider`](providers-basic-provider#module-qiskit.providers.basic_provider "qiskit.providers.basic_provider") now includes all the standard gates (`qiskit.circuit.library .standard_gates`) up to 3 qubits.

<span id="relnotes-1-1-0rc1-pulse-features" />

### Pulse Features

*   It is now possible to assign parameters to pulse `Schedule` and `ScheduleBlock` objects by specifying the parameter name as a string. The parameter name can be used to assign values to all parameters within the Schedule or ScheduleBlock that have the same name. Moreover, the parameter name of a ParameterVector can be used to assign all values of the vector simultaneously (the list of values should therefore match the length of the vector).

*   The `assign_parameters` methods of `Schedule` and `ScheduleBlock` now support assigning a [`ParameterVector`](qiskit-circuit-parameter-vector#qiskit.circuit.ParameterVector "qiskit.circuit.ParameterVector") to a list of parameter values simultaneously in addition to assigning individual [`Parameter`](qiskit-circuit-parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances to individual values.

<span id="relnotes-1-1-0rc1-quantum-information-features" />

<span id="id9" />

### Quantum Information Features

*   Added a new [`apply_layout()`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli.apply_layout "qiskit.quantum_info.Pauli.apply_layout") method that is equivalent to [`apply_layout()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.apply_layout "qiskit.quantum_info.SparsePauliOp.apply_layout"). This method is used to apply a [`TranspileLayout`](qiskit-transpiler-transpile-layout#qiskit.transpiler.TranspileLayout "qiskit.transpiler.TranspileLayout") layout from the transpiler to a [`Pauli`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli") observable that was built for an input circuit. This enables working with `BaseEstimator` / [`BaseEstimatorV2`](qiskit-primitives-base-estimator-v2#qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2") implementations and local transpilation when the input is of type [`Pauli`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli "qiskit.quantum_info.Pauli"). For example:

    ```c
    from qiskit.circuit.library import RealAmplitudes
    from qiskit.primitives import BackendEstimatorV2
    from qiskit.providers.fake_provider import GenericBackendV2
    from qiskit.quantum_info import Pauli
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

    psi = RealAmplitudes(num_qubits=2, reps=2)
    H1 = Pauli("XI")
    backend = GenericBackendV2(num_qubits=7)
    estimator = BackendEstimatorV2(backend=backend)
    thetas = [0, 1, 1, 2, 3, 5]
    pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
    transpiled_psi = pm.run(psi)
    permuted_op = H1.apply_layout(transpiled_psi.layout)
    res = estimator.run([(transpiled_psi, permuted_op, thetas)]).result()
    ```

    where an input circuit is transpiled locally before it’s passed to `run`. Transpilation expands the original circuit from 2 to 7 qubits (the size of `backend`) and permutes its layout, which is then applied to `H1` using [`apply_layout()`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli.apply_layout "qiskit.quantum_info.Pauli.apply_layout") to reflect the transformations performed by `pm.run()`.

*   Adds the [`PauliList.noncommutation_graph()`](qiskit-quantum-info-pauli-list#qiskit.quantum_info.PauliList.noncommutation_graph "qiskit.quantum_info.PauliList.noncommutation_graph") and [`SparsePauliOp.noncommutation_graph()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.noncommutation_graph "qiskit.quantum_info.SparsePauliOp.noncommutation_graph") methods, exposing the construction of non-commutation graphs, recasting the measurement operator grouping problem into a graph coloring problem. This permits users to work with these graphs directly, for example to explore coloring algorithms other than the one used by [`SparsePauliOp.group_commuting()`](qiskit-quantum-info-sparse-pauli-op#qiskit.quantum_info.SparsePauliOp.group_commuting "qiskit.quantum_info.SparsePauliOp.group_commuting").

<span id="relnotes-1-1-0rc1-synthesis-features" />

<span id="id10" />

### Synthesis Features

*   Added a new argument, `use_dag`, to the [`TwoQubitBasisDecomposer.__call__()`](qiskit-synthesis-two-qubit-basis-decomposer#qiskit.synthesis.TwoQubitBasisDecomposer.__call__ "qiskit.synthesis.TwoQubitBasisDecomposer.__call__") and [`XXDecomposer.__call__()`](qiskit-synthesis-xx-decomposer#qiskit.synthesis.XXDecomposer.__call__ "qiskit.synthesis.XXDecomposer.__call__") methods. This argument is used to control whether a [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") is returned when calling a [`TwoQubitBasisDecomposer`](qiskit-synthesis-two-qubit-basis-decomposer#qiskit.synthesis.TwoQubitBasisDecomposer "qiskit.synthesis.TwoQubitBasisDecomposer") or [`XXDecomposer`](qiskit-synthesis-xx-decomposer#qiskit.synthesis.XXDecomposer "qiskit.synthesis.XXDecomposer") instance instead of the default [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). For example:

    ```c
    from qiskit.circuit.library import CXGate
    from qiskit.quantum_info import random_unitary
    from qiskit.synthesis import TwoQubitBasisDecomposer

    decomposer = TwoQubitBasisDecomposer(CXGate(), euler_basis="PSX")
    decomposer(random_unitary(4), use_dag=True)
    ```

    will return a [`DAGCircuit`](qiskit-dagcircuit-dag-circuit#qiskit.dagcircuit.DAGCircuit "qiskit.dagcircuit.DAGCircuit") when calling the [`TwoQubitBasisDecomposer`](qiskit-synthesis-two-qubit-basis-decomposer#qiskit.synthesis.TwoQubitBasisDecomposer "qiskit.synthesis.TwoQubitBasisDecomposer") instance `decomposer`.

*   [`LieTrotter.synthesize()`](qiskit-synthesis-lie-trotter#qiskit.synthesis.LieTrotter.synthesize "qiskit.synthesis.LieTrotter.synthesize") now uses [`QuantumCircuit.repeat()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.repeat "qiskit.circuit.QuantumCircuit.repeat") to generate additional reps after the first. This reduces the number of [`QuantumCircuit.compose()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.compose "qiskit.circuit.QuantumCircuit.compose") calls by a factor of `reps` and significantly reduces the runtime for larger operators.

*   Add a new synthesis method [`synth_permutation_reverse_lnn_kms()`](synthesis#qiskit.synthesis.synth_permutation_reverse_lnn_kms "qiskit.synthesis.synth_permutation_reverse_lnn_kms") of reverse permutations for linear nearest-neighbor architectures using Kutin, Moulton, Smithline method. This algorithm synthesizes the reverse permutation on $n$ qubits over a linear nearest-neighbor architecture using CX gates with depth $2 * n + 2$.

*   The [`TwoQubitBasisDecomposer`](qiskit-synthesis-two-qubit-basis-decomposer#qiskit.synthesis.TwoQubitBasisDecomposer "qiskit.synthesis.TwoQubitBasisDecomposer") class has been rewritten in Rust which greatly improves the runtime performance.

*   The [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition") synthesis class has been rewritten in Rust for better performance.

<span id="relnotes-1-1-0rc1-transpiler-features" />

<span id="id11" />

### Transpiler Features

*   The following analysis passes now accept constraints encoded in a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target") thanks to a new `target` input argument:

    > *   [`InstructionDurationCheck`](qiskit-transpiler-passes-instruction-duration-check#qiskit.transpiler.passes.InstructionDurationCheck "qiskit.transpiler.passes.InstructionDurationCheck")
    > *   [`ConstrainedReschedule`](qiskit-transpiler-passes-constrained-reschedule#qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule")
    > *   `ValidatePulseGates`

    The target constraints will have priority over user-provided constraints, for coherence with the rest of the transpiler pipeline.

<span id="relnotes-1-1-0rc1-upgrade-notes" />

<span id="id12" />

### Upgrade Notes

*   Removes the hard-coding of style options for [`plot_histogram()`](qiskit-visualization-plot-histogram#qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram"). This allows Matplotlib style files to be faithfully applied to the figures. Users looking to go beyond the defaults set by Matplotlib can make their own style files, or pass a Matplotlib `Axes` object to `plot_histogram` and post-apply any customizations.

*   The [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function has been upgraded to internally convert backend inputs of type `BackendV1` to [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2"), which allows the transpilation pipeline to now access the backend constraints through a [`Target`](qiskit-transpiler-target#qiskit.transpiler.Target "qiskit.transpiler.Target"). This change does not require any user action.

<span id="relnotes-1-1-0rc1-circuits-upgrade-notes" />

<span id="id13" />

### Circuits Upgrade Notes

*   The random-number usage of [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") has changed, so you will get a different circuit for a fixed seed between older versions of Qiskit and this version. The random-unitary generation now uses more bits of entropy, so large circuits will be less biased.

*   The internal [`UnitaryGate`](qiskit-circuit-library-unitary-gate#qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") instances in the definition of a [`QuantumVolume`](qiskit-circuit-library-quantum-volume#qiskit.circuit.library.QuantumVolume "qiskit.circuit.library.QuantumVolume") circuit will no longer have a [`label`](qiskit-circuit-instruction#qiskit.circuit.Instruction.label "qiskit.circuit.Instruction.label") field set. Previously this was set to the string `su4_<seed>` where `<seed>` was a three-digit number denoting the seed of an internal Numpy pRNG instance for that gate. Doing this was a serious performance problem, and the seed ought not to have been useful; if you need to retrieve the matrix from the gate, simply use the [`Gate.to_matrix()`](qiskit-circuit-gate#qiskit.circuit.Gate.to_matrix "qiskit.circuit.Gate.to_matrix") method.

<span id="relnotes-1-1-0rc1-primitives-upgrade-notes" />

<span id="id14" />

### Primitives Upgrade Notes

*   The function qiskit.primitives.containers.make\_data\_bin() no longer creates and returns a qiskit.primitives.containers.DataBin subclass. It instead always returns the DataBin class. However, it continues to exist for backwards compatibility, though will eventually be deprecated. All users should migrate to construct DataBin instances directly, instead of instantiating subclasses as output by make\_data\_bin().

<span id="relnotes-1-1-0rc1-synthesis-upgrade-notes" />

<span id="id15" />

### Synthesis Upgrade Notes

*   The [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition") no longer will self-specialize into a subclass on creation. This was an internal detail of the [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition") previously, and was not a documented public behavior as all the subclasses behaved the same and were only used for internal dispatch. However, as it was discoverable behavior this release note is to document that this will no longer occur and all instances of [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition") will be of the same type. There is no change in behavior for public methods of the class.

<span id="relnotes-1-1-0rc1-transpiler-upgrade-notes" />

<span id="id16" />

### Transpiler Upgrade Notes

*   The preset [`StagedPassManager`](qiskit-transpiler-staged-pass-manager#qiskit.transpiler.StagedPassManager "qiskit.transpiler.StagedPassManager") returned for optimization level 2 by [`generate_preset_pass_manager()`](qiskit-transpiler-generate-preset-pass-manager#qiskit.transpiler.generate_preset_pass_manager "qiskit.transpiler.generate_preset_pass_manager") and [`level_2_pass_manager()`](transpiler-preset#qiskit.transpiler.preset_passmanagers.level_2_pass_manager "qiskit.transpiler.preset_passmanagers.level_2_pass_manager") have been reworked to provide a better balance between runtime and optimization. This means the output circuits will change compared to earlier releases. If you need an exact pass manager from level 2 in earlier releases you can either build it manually or use it from an earlier release and save the circuits with [`qpy`](qpy#module-qiskit.qpy "qiskit.qpy") to load with a newer release.

<span id="relnotes-1-1-0rc1-deprecation-notes" />

<span id="id17" />

### Deprecation Notes

*   Support for running Qiskit with Python 3.8 has been deprecated and will be removed in the Qiskit 1.3.0 release. The 1.3.0 is the first release after Python 3.8 goes end of life and is no longer supported. \[1] This means that starting in the 1.3.0 release you will need to upgrade the Python version you’re using to Python 3.9 or above.

    \[1] [https://devguide.python.org/versions/](https://devguide.python.org/versions/)

*   The parameters `show_idle` and `show_barrier` in the timeline drawers had been replaced by `idle_wires` and `plot_barriers` respectively to match the circuit drawer parameters. Their previous names are now deprecated and will be removed in the next major release. The new parameters are fully equivalent.

<span id="relnotes-1-1-0rc1-providers-deprecations" />

<span id="id18" />

### Providers Deprecations

*   The abstract base classes `Provider` and `ProviderV1` are now deprecated and will be removed in Qiskit 2.0.0. The abstraction provided by these interface definitions were not providing a huge value. solely just the attributes `name`, `backends`, and a `get_backend()`. A \_provider\_, as a concept, will continue existing as a collection of backends. If you’re implementing a provider currently you can adjust your code by simply removing `ProviderV1` as the parent class of your implementation. As part of this you probably would want to add an implementation of `get_backend` for backwards compatibility. For example:

    ```c
    def get_backend(self, name=None, **kwargs):
      backend = self.backends(name, **kwargs)
      if len(backends) > 1:
          raise QiskitBackendNotFoundError("More than one backend matches the criteria")
      if not backends:
          raise QiskitBackendNotFoundError("No backend matches the criteria")
      return backends[0]
    ```

<span id="relnotes-1-1-0rc1-synthesis-deprecations" />

### Synthesis Deprecations

*   The [`TwoQubitWeylDecomposition.specialize()`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition.specialize "qiskit.synthesis.TwoQubitWeylDecomposition.specialize") method is now deprecated and will be removed in the Qiskit 2.0.0 release. This method never had a public purpose and was unsafe for an end user to call as it would mutate the calculated decomposition in the object and produce invalid fields in the object. It was only used internally to construct a new [`TwoQubitWeylDecomposition`](qiskit-synthesis-two-qubit-weyl-decomposition#qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition") object. Despite this it was still a documented part of the public API for the class and is now being deprecated without any potential replacement. This release it always will raise a `NotImplementedError` when called because the specialization subclassing has been removed as part of the Rust rewrite of the class.

<span id="relnotes-1-1-0rc1-transpiler-deprecations" />

<span id="id19" />

### Transpiler Deprecations

*   The pass `qiskit.transpiler.passes.CXCancellation` was deprecated in favor of class:.InverseCancellation, which is more generic. `CXCancellation` is fully semantically equivalent to `InverseCancellation([CXGate()])`.

*   The transpilation pass `qiskit.transpiler.passes.ALAPSchedule` is now deprecated. It was pending for deprecation since Qiskit 0.37 (with Terra 0.21), released on June 2022. The pass is replaced by [`ALAPScheduleAnalysis`](qiskit-transpiler-passes-alap-schedule-analysis#qiskit.transpiler.passes.ALAPScheduleAnalysis "qiskit.transpiler.passes.ALAPScheduleAnalysis"), which is an analysis pass.

*   The transpilation pass `qiskit.transpiler.passes.ASAPSchedule` is now deprecated. It was pending for deprecation since Qiskit 0.37 (with Terra 0.21), released on June 2022. It has been superseded by [`ASAPScheduleAnalysis`](qiskit-transpiler-passes-asap-schedule-analysis#qiskit.transpiler.passes.ASAPScheduleAnalysis "qiskit.transpiler.passes.ASAPScheduleAnalysis") and the new scheduling workflow.

*   The transpilation pass `qiskit.transpiler.passes.DynamicalDecoupling` is now deprecated. It was pending for deprecation since Qiskit 0.37 (with Terra 0.21), released on June 2022. Instead, use [`PadDynamicalDecoupling`](qiskit-transpiler-passes-pad-dynamical-decoupling#qiskit.transpiler.passes.PadDynamicalDecoupling "qiskit.transpiler.passes.PadDynamicalDecoupling"), which performs the same function but requires scheduling and alignment analysis passes to run prior to it.

*   The transpilation pass `qiskit.transpiler.passes.AlignMeasures` is now deprecated. It was pending for deprecation since Qiskit 0.37 (with Terra 0.21), released on June 2022. Instead, use [`ConstrainedReschedule`](qiskit-transpiler-passes-constrained-reschedule#qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule"), which performs the same function and also supports aligning to additional timing constraints.

<span id="relnotes-1-1-0rc1-bug-fixes" />

<span id="id20" />

### Bug Fixes

*   Fixed an issue with the [`qpy.dump()`](qpy#qiskit.qpy.dump "qiskit.qpy.dump") function where, when the `use_symengine` flag was set to a truthy object that evaluated to `True` but was not actually the boolean `True`, the generated QPY payload would be corrupt. For example, if you set `use_symengine` to [`HAS_SYMENGINE`](utils#qiskit.utils.optionals.HAS_SYMENGINE "qiskit.utils.optionals.HAS_SYMENGINE"), this object evaluates to `True` when cast as a bool, but isn’t actually `True`.

*   Fixed an issue with the [`circuit_drawer()`](qiskit-visualization-circuit-drawer#qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`QuantumCircuit.draw()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw") method when loading a matplotlib style via the user configuration file.

*   Fixed an issue where the [`ConstrainedReschedule`](qiskit-transpiler-passes-constrained-reschedule#qiskit.transpiler.passes.ConstrainedReschedule "qiskit.transpiler.passes.ConstrainedReschedule") transpiler pass would previously error if the circuit contained a [`Reset`](circuit#qiskit.circuit.Reset "qiskit.circuit.Reset") instruction. This has been corrected so that the pass no longer errors, however an actual hardware may behave differently from what Qiskit scheduler assumes especially for mid-circuit measurements and resets. Qiskit scheduler raises `RuntimeWarning` if it encounters circuit containing either. Fixed [#10354](https://github.com/Qiskit/qiskit/issues/10354)

*   Fixed an issue with the [`CommutationChecker`](qiskit-circuit-commutation-checker#qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") class where it would error if a gate’s [`name`](qiskit-circuit-gate#qiskit.circuit.Gate.name "qiskit.circuit.Gate.name") attribute was UTF8 encoded. Previously only gate names with ascii encoding would work. Fixed [#12501](https://github.com/Qiskit/qiskit/issues/12051)

*   Fixed a performance issue in the [`BackendSamplerV2`](qiskit-primitives-backend-sampler-v2#qiskit.primitives.BackendSamplerV2 "qiskit.primitives.BackendSamplerV2") and [`BackendEstimatorV2`](qiskit-primitives-backend-estimator-v2#qiskit.primitives.BackendEstimatorV2 "qiskit.primitives.BackendEstimatorV2"). Fixed [#12290](https://github.com/Qiskit/qiskit-terra/issues/12290)

*   Fixed an issue with the `convert_to_target()` where the converter would incorrectly ignore control flow instructions if they were specified in the `BackendConfiguration.supported_instructions` attribute which is the typical location that control flow instructions are specified in a `BackendConfiguration` object. Fixed [#11872](https://github.com/Qiskit/qiskit/issues/11872).

*   Fixed an issue with the `circuit_drawer()` or `QuantumCircuit.draw()` when using the `mpl` output option where the program would hang if the circuit being drawn had a ControlFlow operation in it and the `fold` option was set to -1 (meaning no fold). Fixed [#12012](https://github.com/Qiskit/qiskit/issues/12012).

*   Fixed a bug in the conversion of custom pulse instructions to the legacy `qiskit.qobj` format. The bug was introduced in Qiskit 1.0.0 and caused conversion of instructions with custom pulse shapes to raise an error. After the fix, the conversion is carried out correctly, and the custom pulse is converted to `pulse.Waveform` as it should. Fixed [#11828](https://github.com/Qiskit/qiskit/issues/11828).

*   A bug in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") has been fixed where custom `instruction_durations`, `dt` and `backend_properties` constraints would be ignored when provided at the same time as a backend of type [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2"). The behavior after the fix is now independent of whether the provided backend is of type `BackendV1` or type [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2"). Similarly, custom `timing_constraints` are now overridden by `target` inputs but take precedence over `BackendV1` and [`BackendV2`](qiskit-providers-backend-v2#qiskit.providers.BackendV2 "qiskit.providers.BackendV2") inputs.

*   Calling [`EquivalenceLibrary.set_entry()`](qiskit-circuit-equivalence-library#qiskit.circuit.EquivalenceLibrary.set_entry "qiskit.circuit.EquivalenceLibrary.set_entry") will now correctly update the internal graph object of the library. Previously, the metadata would be updated, but the graph structure would be unaltered, meaning that users like [`BasisTranslator`](qiskit-transpiler-passes-basis-translator#qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") would still use the old rules. Fixed [#11958](https://github.com/Qiskit/qiskit/issues/11958).

*   The [`EvolvedOperatorAnsatz`](qiskit-circuit-library-evolved-operator-ansatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz") now correctly handles the case where the operators argument is an empty list. Previously, this would result in an error.

*   From now on, [`EvolvedOperatorAnsatz`](qiskit-circuit-library-evolved-operator-ansatz#qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz") will not have any qregs when thera are zero qubits, instead of having a [`QuantumRegister`](circuit#qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") instance with zero qubits. This behavior aligns more consistently with its superclass [`QuantumCircuit`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit").

*   The method [`Instruction.repeat()`](qiskit-circuit-instruction#qiskit.circuit.Instruction.repeat "qiskit.circuit.Instruction.repeat") now moves a set `condition` to the outer returned [`Instruction`](qiskit-circuit-instruction#qiskit.circuit.Instruction "qiskit.circuit.Instruction") and leave the inner gates of its definition unconditional. Previously, the method would leave [`ClassicalRegister`](circuit#qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") instances within the inner definition, which was an invalid state, and would manifest itself as seemingly unrelated bugs later, such as during transpilation or export. Fixed [#11935](https://github.com/Qiskit/qiskit/issues/11935).

*   Fixed an issue in the [`InverseCancellation`](qiskit-transpiler-passes-inverse-cancellation#qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation") transpiler pass where in some cases it would incorrectly cancel a self-inverse parameterized gate even if the parameter value didn’t match. Fixed [#11815](https://github.com/Qiskit/qiskit/issues/11815)

*   Improve the decomposition of the gates [`MCXGate`](qiskit-circuit-library-mcx-gate#qiskit.circuit.library.MCXGate "qiskit.circuit.library.MCXGate") and [`MCPhaseGate`](qiskit-circuit-library-mc-phase-gate#qiskit.circuit.library.MCPhaseGate "qiskit.circuit.library.MCPhaseGate") without using ancilla qubits, so that the number of [`CXGate`](qiskit-circuit-library-cx-gate#qiskit.circuit.library.CXGate "qiskit.circuit.library.CXGate") will grow quadratically in the number of qubits and not exponentially.

*   A bug that crashes the `convert_to_target()` function when qubit properties (either T1, T2 or frequency) are missing was fixed. The missing property values in [`QubitProperties`](qiskit-providers-qubit-properties#qiskit.providers.QubitProperties "qiskit.providers.QubitProperties") are filled with `None`.

*   [`BasePassManager.run()`](qiskit-passmanager-base-pass-manager#qiskit.passmanager.BasePassManager.run "qiskit.passmanager.BasePassManager.run") will no longer leak the previous [`PropertySet`](qiskit-passmanager-property-set#qiskit.passmanager.PropertySet "qiskit.passmanager.PropertySet") into new workflows when called more than once. Previously, the same [`PropertySet`](qiskit-passmanager-property-set#qiskit.passmanager.PropertySet "qiskit.passmanager.PropertySet") as before would be used to initialize follow-on runs, which could mean that invalid property information was being given to tasks. The behavior now matches that of Qiskit 0.44. Fixed [#11784](https://github.com/Qiskit/qiskit/issues/11784).

*   [`Pauli.evolve()`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli.evolve "qiskit.quantum_info.Pauli.evolve") now correctly handles quantum circuits containing ECR gates. Formerly they were not recognized as Clifford gates, and an error was raised.

*   Fixed a bug in [`Pauli.evolve()`](qiskit-quantum-info-pauli#qiskit.quantum_info.Pauli.evolve "qiskit.quantum_info.Pauli.evolve") where evolving by a circuit with a name matching certain Clifford gates (‘cx’, ‘cz’, etc) would evolve the Pauli according to the name of the circuit, not by the contents of the circuit. This bug occurred only with the non-default option `frame='s'`.

*   Fixed a performance issue in the [`qpy.load()`](qpy#qiskit.qpy.load "qiskit.qpy.load") function when deserializing QPY payloads with large numbers of qubits or clbits in a circuit.

*   Fixed a bug where `qiskit.primitives.containers.estimator_pub.EstimatorPub.coerce()` and `qiskit.primitives.containers.sampler_pub.SamplerPub.coerce()` improperly handle the case where the parameter values are a `BindingsArray` instance, giving rise to a `ValueError` whenever it is attempted.

*   Fixed a bug in the handling of `default_alignment` argument of `build()`. Inputs of type `AlignmentKind` are now correctly processed as default alignments.

*   Fixed a bug in `qiskit.pulse.utils.format_parameter_value()` function that unintentionally converts large enough integer numbers into float values or causes unexpected rounding. See [qiskit/#11971](https://github.com/Qiskit/qiskit/issues/11971) for details.

*   Fix incorrect implemention of qDRIFT, negative coefficients of the Hamiltonian are now added back whereas they were always forced to be positive.

*   A bug has been fixed in `convert_durations_to_dt()` where the function would blindly apply a conversion from seconds to `dt` on circuit durations, independently of the original units of the attribute. This could lead to wrong orders of magnitude in the reported circuit durations.

*   The preset pass managers of [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") will no longer fail on circuits with control flow, if no hardware target or basis-gate set is specified. They will now treat such abstract targets as permitting all control-flow operations. Fixed [#11906](https://github.com/Qiskit/qiskit/issues/11906).

*   The method `qiskit.instruction.Instruction.soft_compare()` is meant to compare whether two gates match in their name, number of qubits, number of clbits, and the number of parameters. However, there was a typo where it would not check the number of qubits and number of clbits for a match. This resolves the apparent typo.

*   The default `init` plugin was not properly raising a [`TranspilerError`](transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") when called with an invalid optimization level.

*   Fixed qiskit.primitives.containers.observables\_array.ObservablesArray.coerce() so that it returns a 0-d array when the input is a single, unnested observable. Previously, it erroneously upgraded to a single dimension, with shape (1,).

*   Fixed an issue with the [`Operator.from_circuit()`](qiskit-quantum-info-operator#qiskit.quantum_info.Operator.from_circuit "qiskit.quantum_info.Operator.from_circuit") constructor method where it would incorrectly interpret the final layout permutation resulting in an invalid Operator being constructed. Previously, the final layout was processed without regards for the initial layout, i.e. the initialization was incorrect for all quantum circuits that have a non-trivial initial layout.

*   [`Parameter`](qiskit-circuit-parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") was updated so that instances that compare equal always have the same hash. Previously, only the [`Parameter.uuid`](qiskit-circuit-parameter#qiskit.circuit.Parameter.uuid "qiskit.circuit.Parameter.uuid") was compared, so `Paramemter` instances with different names could compare equal if they had been constructed using a common value for the `uuid` parameter (which is usually not passed explicitly).

*   [`Parameter`](qiskit-circuit-parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances used as stand-ins for `input` variables in OpenQASM 3 programs will now have their names escaped to avoid collisions with built-in gates during the export to OpenQASM 3. Previously there could be a naming clash, and the exporter would generate invalid OpenQASM 3.

*   Fixed bug in [`QuantumCircuit.draw()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.draw "qiskit.circuit.QuantumCircuit.draw") that was causing custom style dictionaries for the Matplotlib drawer to be modified upon execution.

*   [`QuantumCircuit.append()`](qiskit-circuit-quantum-circuit#qiskit.circuit.QuantumCircuit.append "qiskit.circuit.QuantumCircuit.append") with `copy=True` (its default) will now correctly copy instructions parametrized by [`ParameterExpression`](qiskit-circuit-parameter-expression#qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression") instances, and not just by [`Parameter`](qiskit-circuit-parameter#qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances.

*   The internal handling of custom circuit calibrations and [`InstructionDurations`](qiskit-transpiler-instruction-durations#qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") has been offloaded from the [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function to the individual transpiler passes: `qiskit.transpiler.passes.scheduling.DynamicalDecoupling`, `qiskit.transpiler.passes.scheduling.padding.DynamicalDecoupling`. Before, instruction durations from circuit calibrations would not be taken into account unless they were manually incorporated into instruction\_durations input argument, but the passes that need it now analyze the circuit and pick the most relevant duration value according to the following priority order: target > custom input > circuit calibrations.

*   Fixed a bug in [`transpile()`](compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") where the `num_processes` argument would only be used if `dt` or `instruction_durations` were provided.

<span id="relnotes-1-1-0rc1-other-notes" />

### Other Notes

*   Support for the arm64 macOS platform has been promoted from Tier 3 to Tier 1. Previously the platform was at Tier 3 because there was no available CI environment for testing Qiskit on the platform. Now that Github has made an arm64 macOS environment available to open source projects <span id="id21" />[\[1\]](#id22) we’re testing the platform along with the other Tier 1 supported platforms.

    <span id="id22" />

    \[[1](#id21)]

    [https://github.blog/changelog/2024-01-30-github-actions-introducing-the-new-m1-macos-runner-available-to-open-source/](https://github.blog/changelog/2024-01-30-github-actions-introducing-the-new-m1-macos-runner-available-to-open-source/)

