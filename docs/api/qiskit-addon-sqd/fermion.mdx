---
title: fermion (latest version)
description: API reference for qiskit_addon_sqd.fermion in the latest version of qiskit-addon-sqd
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit_addon_sqd.fermion
---

<span id="module-qiskit_addon_sqd.fermion" />

<span id="fermion-qiskit-addon-sqd-fermion" />

# Fermion

`qiskit_addon_sqd.fermion`

Functions for the study of fermionic systems.

### SCIState

<Class id="qiskit_addon_sqd.fermion.SCIState" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L37-L102" signature="SCIState(amplitudes, ci_strs_a, ci_strs_b, norb, nelec)" modifiers="class">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)")

  The amplitudes and determinants describing a quantum state.

  **Parameters**

  *   **amplitudes** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"))
  *   **ci\_strs\_a** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"))
  *   **ci\_strs\_b** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"))
  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"))
  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*]*)

  #### amplitudes

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.amplitudes" attributeTypeHint="ndarray">
    An $M \times N$ array where $M =$ len(`ci_strs_a`) and $N$ = len(`ci_strs_b`). `amplitudes[i][j]` is the amplitude of the determinant pair (`ci_strs_a[i]`, `ci_strs_b[j]`).
  </Attribute>

  #### ci\_strs\_a

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.ci_strs_a" attributeTypeHint="ndarray">
    The alpha determinants.
  </Attribute>

  #### ci\_strs\_b

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.ci_strs_b" attributeTypeHint="ndarray">
    The beta determinants.
  </Attribute>

  #### load

  <Function id="qiskit_addon_sqd.fermion.SCIState.load" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L76-L80" signature="load(filename)" modifiers="classmethod">
    Load an SCIState object from an .npz file.
  </Function>

  #### nelec

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.nelec" attributeTypeHint="tuple[int, int]">
    The numbers of alpha and beta electrons.
  </Attribute>

  #### norb

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.norb" attributeTypeHint="int">
    The number of spatial orbitals.
  </Attribute>

  #### orbital\_occupancies

  <Function id="qiskit_addon_sqd.fermion.SCIState.orbital_occupancies" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L99-L102" signature="orbital_occupancies()">
    Average orbital occupancies.

    **Return type**

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")]
  </Function>

  #### rdm

  <Function id="qiskit_addon_sqd.fermion.SCIState.rdm" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L82-L97" signature="rdm(rank=1, spin_summed=False)">
    Compute reduced density matrix.

    **Parameters**

    *   **rank** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"))
    *   **spin\_summed** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"))

    **Return type**

    [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")
  </Function>

  #### save

  <Function id="qiskit_addon_sqd.fermion.SCIState.save" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L70-L74" signature="save(filename)">
    Save the SCIState object to an .npz file.
  </Function>
</Class>

### bitstring\_matrix\_to\_ci\_strs

<Function id="qiskit_addon_sqd.fermion.bitstring_matrix_to_ci_strs" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L686-L730" signature="bitstring_matrix_to_ci_strs(bitstring_matrix, open_shell=False)">
  Convert bitstrings (rows) in a `bitstring_matrix` into integer representations of determinants.

  This function separates each bitstring in `bitstring_matrix` in half, flips the bits and translates them into integer representations, and finally appends them to their respective (spin-up or spin-down) lists. Those lists are sorted and output from this function.

  **Parameters**

  *   **bitstring\_matrix** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – A 2D array of `bool` representations of bit values such that each row represents a single bitstring
  *   **open\_shell** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)")) – A flag specifying whether unique configurations from the left and right halves of the bitstrings should be kept separate. If `False`, configurations from the left and right halves of the bitstrings are combined into a single set of unique configurations. That combined set will be returned for both the left and right bitstrings.

  **Returns**

  A length-2 tuple of determinant lists representing the right (spin-up) and left (spin-down) halves of the bitstrings, respectively.

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")]
</Function>

### diagonalize\_fermionic\_hamiltonian

<Function id="qiskit_addon_sqd.fermion.diagonalize_fermionic_hamiltonian" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L125-L324" signature="diagonalize_fermionic_hamiltonian(one_body_tensor, two_body_tensor, bit_array, samples_per_batch, norb, nelec, *, num_batches=1, energy_tol=1e-08, occupancies_tol=1e-05, max_iterations=100, sci_solver=None, symmetrize_spin=False, include_configurations=None, initial_occupancies=None, carryover_threshold=0.0001, callback=None, seed=None)">
  Run the sample-based quantum diagonalization (SQD) algorithm.

  **Parameters**

  *   **one\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The one-body tensor of the Hamiltonian.

  *   **two\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The two-body tensor of the Hamiltonian.

  *   **bit\_array** ([*BitArray*](/docs/api/qiskit/qiskit.primitives.BitArray "(in Qiskit v2.0)")) – Array of sampled bitstrings. Each bitstring should have both the alpha part and beta part concatenated together, with the alpha part concatenated on the right-hand side, like this: `[b_N, ..., b_0, a_N, ..., a_0]`.

  *   **samples\_per\_batch** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of bitstrings to include in each subsampled batch of bitstrings.

  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of spatial orbitals.

  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*]*) – The numbers of alpha and beta electrons.

  *   **num\_batches** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of batches to subsample in each configuration recovery iteration. This argument indirectly controls the dimensions of the diagonalization subspaces. A higher value will yield larger subspace dimensions.

  *   **energy\_tol** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")) – Numerical tolerance for convergence of the energy. If the change in energy between iterations is smaller than this value, then the configuration recovery loop will exit, if the occupancies have also converged (see the `occupancies_tol` argument).

  *   **occupancies\_tol** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")) – Numerical tolerance for convergence of the average orbital occupancies. If the maximum change in absolute value of the average occupancy of an orbital between iterations is smaller than this value, then the configuration recovery loop will exit, if the energy has also converged (see the `energy_tol` argument).

  *   **max\_iterations** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – Limit on the number of configuration recovery iterations.

  *   **sci\_solver** ([*Callable*](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)")*\[\[*[*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*]],* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*,* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*]],* [*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[SCIResult]] | None*) –

      Selected configuration interaction solver function.

      Inputs:

      *   List of pairs (strings\_a, strings\_b) of arrays of spin-alpha CI strings and spin-beta CI strings whose Cartesian product give the basis of the subspace in which to perform a diagonalization. A list is passed to allow the solver function to perform the diagonalizations in parallel.
      *   One-body tensor of the Hamiltonian.
      *   Two-body tensor of the Hamiltonian.
      *   The number of spatial orbitals.
      *   A pair (n\_alpha, n\_beta) indicating the numbers of alpha and beta electrons.

      Output: List of (energy, sci\_state, occupancies) triplets, where each triplet contains the result of the corresponding diagonalization.

  *   **symmetrize\_spin** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)")) – Whether to always merge spin-alpha and spin-beta CI strings into a single list, so that the diagonalization subspace is invariant with respect to the exchange of spin alpha with spin beta.

  *   **include\_configurations** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*],* [*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*]] | None*) – Configurations to always include in the diagonalization subspace. You can specify either a single list of single-spin strings to use for both spin sectors, or a pair (alpha\_strings, beta\_strings) of lists of single-spin strings, one for each spin.

  *   **initial\_occupancies** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*] | None*) – Initial guess for the average occupancies of the orbitals.

  *   **carryover\_threshold** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")) – Threshold for carrying over bitstrings with large CI weight from one iteration of configuration recovery to the next. All single-spin CI strings associated with configurations whose coefficient has absolute value greater than this threshold will be included in the diagonalization subspace for the next iteration. A smaller threshold will retain more configurations, leading to a larger subspace and hence a more costly diagonalization.

  *   **callback** ([*Callable*](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)")*\[\[*[*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[SCIResult]], None] | None*) – A callback function to be called after each configuration recovery iteration. The function will be passed the output of the sci\_solver function, which is a list of (energy, sci\_state, occupancies) triplets, where each triplet contains the result of a diagonalization.

  *   **seed** ([*Generator*](https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator "(in NumPy v2.2)")  *|*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)") *| None*) – A seed for the pseudorandom number generator.

  **Returns**

  The estimate of the energy and the SCI state with that energy.

  **Return type**

  *SCIResult*
</Function>

### enlarge\_batch\_from\_transitions

<Function id="qiskit_addon_sqd.fermion.enlarge_batch_from_transitions" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L733-L756" signature="enlarge_batch_from_transitions(bitstring_matrix, transition_operators)">
  Apply the set of transition operators to the configurations represented in `bitstring_matrix`.

  **Parameters**

  *   **bitstring\_matrix** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – A 2D array of `bool` representations of bit values such that each row represents a single bitstring.
  *   **transition\_operators** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – A 1D or 2D array `I`, `+`, `-`, and `n` strings representing the action of the identity, creation, annihilation, or number operators. Each row represents a transition operator.

  **Returns**

  Bitstring matrix representing the augmented set of electronic configurations after applying the excitation operators.

  **Return type**

  [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")
</Function>

### solve\_fermion

<Function id="qiskit_addon_sqd.fermion.solve_fermion" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L429-L529" signature="solve_fermion(bitstring_matrix, /, hcore, eri, *, open_shell=False, spin_sq=None, shift=0.1, **kwargs)">
  Approximate the ground state given molecular integrals and a set of electronic configurations.

  **Parameters**

  *   **bitstring\_matrix** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*] |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) –

      A set of configurations defining the subspace onto which the Hamiltonian will be projected and diagonalized.

      This may be specified in two ways:

      *   Bitstring matrix: A 2D `numpy.ndarray` of `bool` values, where each row represents a bitstring. The spin-up configurations should occupy column indices `(N, N/2]`, and the spin-down configurations should occupy column indices `(N/2, 0]`, where `N` is the number of qubits.
      *   CI strings: A tuple of two sequences containing integer representations of spin-up and spin-down determinants, respectively. The expected format is `([a_str_0, ..., a_str_N], [b_str_0, ..., b_str_M])`.

  *   **hcore** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – Core Hamiltonian matrix representing single-electron integrals

  *   **eri** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – Electronic repulsion integrals representing two-electron integrals

  *   **open\_shell** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)")) – A flag specifying whether configurations from the left and right halves of the bitstrings should be kept separate. If `False`, CI strings from the left and right halves of the bitstrings are combined into a single set of unique configurations and used for both the alpha and beta subspaces.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)") *| None*) – Target value for the total spin squared for the ground state, $S^2 = s(s + 1)$. If `None`, no spin will be imposed.

  *   **shift** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")) – Level shift for states which have different spin. $(H + shift * S^2)|ψ> = E|ψ>$

  *   **\*\*kwargs** – Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  *   Minimum energy from SCI calculation
  *   The SCI ground state
  *   Tuple containing orbital occupancies for spin-up and spin-down orbitals. Formatted as: `(array([occ_a_0, ..., occ_a_N]), array([occ_b_0, ..., occ_b_N]))`
  *   Expectation value of spin-squared

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"), [*SCIState*](#qiskit_addon_sqd.fermion.SCIState "qiskit_addon_sqd.fermion.SCIState"), [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")], [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")]
</Function>

### solve\_sci

<Function id="qiskit_addon_sqd.fermion.solve_sci" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L368-L426" signature="solve_sci(ci_strings, one_body_tensor, two_body_tensor, norb, nelec, *, spin_sq=None, **kwargs)">
  Diagonalize Hamiltonian in subspace defined by CI strings.

  **Parameters**

  *   **ci\_strings** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*]*) – Pair (strings\_a, strings\_b) of arrays of spin-alpha CI strings and spin-beta CI strings whose Cartesian product give the basis of the subspace in which to perform a diagonalization.

  *   **one\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The one-body tensor of the Hamiltonian.

  *   **two\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The two-body tensor of the Hamiltonian.

  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of spatial orbitals.

  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*]*) – The numbers of alpha and beta electrons.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)") *| None*) – Target value for the total spin squared for the ground state. If `None`, no spin will be imposed.

  *   **\*\*kwargs** –

      Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  The diagonalization result.

  **Return type**

  *SCIResult*
</Function>

### solve\_sci\_batch

<Function id="qiskit_addon_sqd.fermion.solve_sci_batch" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L327-L365" signature="solve_sci_batch(ci_strings, one_body_tensor, two_body_tensor, norb, nelec, *, spin_sq=None, **kwargs)">
  Diagonalize Hamiltonian in subspaces.

  **Parameters**

  *   **ci\_strings** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")*\[*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*]]*) – List of pairs (strings\_a, strings\_b) of arrays of spin-alpha CI strings and spin-beta CI strings whose Cartesian product give the basis of the subspace in which to perform a diagonalization.

  *   **one\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The one-body tensor of the Hamiltonian.

  *   **two\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – The two-body tensor of the Hamiltonian.

  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of spatial orbitals.

  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")*]*) – The numbers of alpha and beta electrons.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)") *| None*) – Target value for the total spin squared for the ground state. If `None`, no spin will be imposed.

  *   **\*\*kwargs** –

      Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  The results of the diagonalizations in the subspaces given by ci\_strings.

  **Return type**

  [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)")\[*SCIResult*]
</Function>

### optimize\_orbitals

<Function id="qiskit_addon_sqd.fermion.optimize_orbitals" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L532-L643" signature="optimize_orbitals(bitstring_matrix, /, hcore, eri, k_flat, *, open_shell=False, spin_sq=0.0, num_iters=10, num_steps_grad=10000, learning_rate=0.01, **kwargs)">
  Optimize orbitals to produce a minimal ground state.

  The process involves iterating over 3 steps:

  **For `num_iters` iterations:**

  *   Rotate the integrals with respect to the parameters, `k_flat`
  *   Diagonalize and approximate the groundstate energy and wavefunction amplitudes
  *   Optimize `k_flat` using gradient descent and the wavefunction amplitudes found in Step 2

  Refer to [Sec. II A 4](https://arxiv.org/pdf/2405.05068) for more detailed discussion on this orbital optimization technique.

  **Parameters**

  *   **bitstring\_matrix** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")*] |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) –

      A set of configurations defining the subspace onto which the Hamiltonian will be projected and diagonalized.

      This may be specified in two ways:

      *   Bitstring matrix: A 2D `numpy.ndarray` of `bool` values, where each row represents a bitstring. The spin-up configurations should occupy column indices `(N, N/2]`, and the spin-down configurations should occupy column indices `(N/2, 0]`, where `N` is the number of qubits.
      *   CI strings: A tuple of two sequences containing integer representations of spin-up and spin-down determinants, respectively. The expected format is `([a_str_0, ..., a_str_N], [b_str_0, ..., b_str_M])`.

  *   **hcore** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – Core Hamiltonian matrix representing single-electron integrals

  *   **eri** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – Electronic repulsion integrals representing two-electron integrals

  *   **k\_flat** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – 1D array defining the orbital transform, `K`. The array should specify the upper triangle of the anti-symmetric transform operator in row-major order, excluding the diagonal.

  *   **open\_shell** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)")) – A flag specifying whether configurations from the left and right halves of the bitstrings should be kept separate. If `False`, CI strings from the left and right halves of the bitstrings are combined into a single set of unique configurations and used for both the alpha and beta subspaces.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")) – Target value for the total spin squared for the ground state

  *   **num\_iters** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of iterations of orbital optimization to perform

  *   **num\_steps\_grad** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)")) – The number of steps of gradient descent to perform during each optimization iteration

  *   **learning\_rate** ([*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)")) – The learning rate to use during gradient descent

  *   **\*\*kwargs** –

      Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  *   The groundstate energy found during the last optimization iteration
  *   An optimized 1D array defining the orbital transform
  *   Tuple containing orbital occupancies for spin-up and spin-down orbitals. Formatted as: `(array([occ_a_0, ..., occ_a_N]), array([occ_b_0, ..., occ_b_N]))`

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"), [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")]]
</Function>

### rotate\_integrals

<Function id="qiskit_addon_sqd.fermion.rotate_integrals" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L646-L683" signature="rotate_integrals(hcore, eri, k_flat)">
  Perform a similarity transform on the integrals.

  The transformation is described as:

$$
\hat{\widetilde{H}} = \hat{U^{\dagger}}(k)\hat{H}\hat{U}(k)
$$

  For more information on how $\hat{U}$ and $\hat{U^{\dagger}}$ are generated from `k_flat` and applied to the one- and two-body integrals, refer to [Sec. II A 4](https://arxiv.org/pdf/2405.05068).

  **Parameters**

  *   **hcore** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – Core Hamiltonian matrix representing single-electron integrals
  *   **eri** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – Electronic repulsion integrals representing two-electron integrals
  *   **k\_flat** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")) – 1D array defining the orbital transform, `K`. The array should specify the upper triangle of the anti-symmetric transform operator in row-major order, excluding the diagonal.

  **Returns**

  *   The rotated core Hamiltonian matrix
  *   The rotated ERI matrix

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)")\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)")]
</Function>

