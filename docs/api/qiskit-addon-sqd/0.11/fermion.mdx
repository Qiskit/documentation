---
title: fermion (v0.11)
description: API reference for qiskit_addon_sqd.fermion in qiskit-addon-sqd v0.11
in_page_toc_min_heading_level: 2
python_api_type: module
python_api_name: qiskit_addon_sqd.fermion
---

<span id="module-qiskit_addon_sqd.fermion" />

<span id="fermion-qiskit-addon-sqd-fermion" />

# Fermion

`qiskit_addon_sqd.fermion`

Functions for the study of fermionic systems.

### SCIState

<Class id="qiskit_addon_sqd.fermion.SCIState" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L37-L102" signature="SCIState(amplitudes, ci_strs_a, ci_strs_b, norb, nelec)" modifiers="class">
  Bases: [`object`](https://docs.python.org/3/library/functions.html#object)

  The amplitudes and determinants describing a quantum state.

  **Parameters**

  *   **amplitudes** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray))
  *   **ci\_strs\_a** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray))
  *   **ci\_strs\_b** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray))
  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int))
  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*,* [*int*](https://docs.python.org/3/library/functions.html#int)*]*)

  #### amplitudes

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.amplitudes" attributeTypeHint="ndarray">
    An $M \times N$ array where $M =$ len(`ci_strs_a`) and $N$ = len(`ci_strs_b`). `amplitudes[i][j]` is the amplitude of the determinant pair (`ci_strs_a[i]`, `ci_strs_b[j]`).
  </Attribute>

  #### ci\_strs\_a

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.ci_strs_a" attributeTypeHint="ndarray">
    The alpha determinants.
  </Attribute>

  #### ci\_strs\_b

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.ci_strs_b" attributeTypeHint="ndarray">
    The beta determinants.
  </Attribute>

  #### load

  <Function id="qiskit_addon_sqd.fermion.SCIState.load" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L76-L80" signature="load(filename)" modifiers="classmethod">
    Load an SCIState object from an .npz file.
  </Function>

  #### nelec

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.nelec" attributeTypeHint="tuple[int, int]">
    The numbers of alpha and beta electrons.
  </Attribute>

  #### norb

  <Attribute id="qiskit_addon_sqd.fermion.SCIState.norb" attributeTypeHint="int">
    The number of spatial orbitals.
  </Attribute>

  #### orbital\_occupancies

  <Function id="qiskit_addon_sqd.fermion.SCIState.orbital_occupancies" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L99-L102" signature="orbital_occupancies()">
    Average orbital occupancies.

    **Return type**

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)]
  </Function>

  #### rdm

  <Function id="qiskit_addon_sqd.fermion.SCIState.rdm" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L82-L97" signature="rdm(rank=1, spin_summed=False)">
    Compute reduced density matrix.

    **Parameters**

    *   **rank** ([*int*](https://docs.python.org/3/library/functions.html#int))
    *   **spin\_summed** ([*bool*](https://docs.python.org/3/library/functions.html#bool))

    **Return type**

    [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)
  </Function>

  #### save

  <Function id="qiskit_addon_sqd.fermion.SCIState.save" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L70-L74" signature="save(filename)">
    Save the SCIState object to an .npz file.
  </Function>
</Class>

### bitstring\_matrix\_to\_ci\_strs

<Function id="qiskit_addon_sqd.fermion.bitstring_matrix_to_ci_strs" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L686-L730" signature="bitstring_matrix_to_ci_strs(bitstring_matrix, open_shell=False)">
  Convert bitstrings (rows) in a `bitstring_matrix` into integer representations of determinants.

  This function separates each bitstring in `bitstring_matrix` in half, flips the bits and translates them into integer representations, and finally appends them to their respective (spin-up or spin-down) lists. Those lists are sorted and output from this function.

  **Parameters**

  *   **bitstring\_matrix** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – A 2D array of `bool` representations of bit values such that each row represents a single bitstring
  *   **open\_shell** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – A flag specifying whether unique configurations from the left and right halves of the bitstrings should be kept separate. If `False`, configurations from the left and right halves of the bitstrings are combined into a single set of unique configurations. That combined set will be returned for both the left and right bitstrings.

  **Returns**

  A length-2 tuple of determinant lists representing the right (spin-up) and left (spin-down) halves of the bitstrings, respectively.

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)]
</Function>

### diagonalize\_fermionic\_hamiltonian

<Function id="qiskit_addon_sqd.fermion.diagonalize_fermionic_hamiltonian" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L125-L324" signature="diagonalize_fermionic_hamiltonian(one_body_tensor, two_body_tensor, bit_array, samples_per_batch, norb, nelec, *, num_batches=1, energy_tol=1e-08, occupancies_tol=1e-05, max_iterations=100, sci_solver=None, symmetrize_spin=False, include_configurations=None, initial_occupancies=None, carryover_threshold=0.0001, callback=None, seed=None)">
  Run the sample-based quantum diagonalization (SQD) algorithm.

  **Parameters**

  *   **one\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – The one-body tensor of the Hamiltonian.

  *   **two\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – The two-body tensor of the Hamiltonian.

  *   **bit\_array** ([*BitArray*](/docs/api/qiskit/qiskit.primitives.BitArray)) – Array of sampled bitstrings. Each bitstring should have both the alpha part and beta part concatenated together, with the alpha part concatenated on the right-hand side, like this: `[b_N, ..., b_0, a_N, ..., a_0]`.

  *   **samples\_per\_batch** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of bitstrings to include in each subsampled batch of bitstrings.

  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of spatial orbitals.

  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*,* [*int*](https://docs.python.org/3/library/functions.html#int)*]*) – The numbers of alpha and beta electrons.

  *   **num\_batches** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of batches to subsample in each configuration recovery iteration. This argument indirectly controls the dimensions of the diagonalization subspaces. A higher value will yield larger subspace dimensions.

  *   **energy\_tol** ([*float*](https://docs.python.org/3/library/functions.html#float)) – Numerical tolerance for convergence of the energy. If the change in energy between iterations is smaller than this value, then the configuration recovery loop will exit, if the occupancies have also converged (see the `occupancies_tol` argument).

  *   **occupancies\_tol** ([*float*](https://docs.python.org/3/library/functions.html#float)) – Numerical tolerance for convergence of the average orbital occupancies. If the maximum change in absolute value of the average occupancy of an orbital between iterations is smaller than this value, then the configuration recovery loop will exit, if the energy has also converged (see the `energy_tol` argument).

  *   **max\_iterations** ([*int*](https://docs.python.org/3/library/functions.html#int)) – Limit on the number of configuration recovery iterations.

  *   **sci\_solver** ([*Callable*](https://docs.python.org/3/library/typing.html#typing.Callable)*\[\[*[*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*]],* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*int*](https://docs.python.org/3/library/functions.html#int)*,* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*,* [*int*](https://docs.python.org/3/library/functions.html#int)*]],* [*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[SCIResult]] | None*) –

      Selected configuration interaction solver function.

      Inputs:

      *   List of pairs (strings\_a, strings\_b) of arrays of spin-alpha CI strings and spin-beta CI strings whose Cartesian product give the basis of the subspace in which to perform a diagonalization. A list is passed to allow the solver function to perform the diagonalizations in parallel.
      *   One-body tensor of the Hamiltonian.
      *   Two-body tensor of the Hamiltonian.
      *   The number of spatial orbitals.
      *   A pair (n\_alpha, n\_beta) indicating the numbers of alpha and beta electrons.

      Output: List of (energy, sci\_state, occupancies) triplets, where each triplet contains the result of the corresponding diagonalization.

  *   **symmetrize\_spin** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – Whether to always merge spin-alpha and spin-beta CI strings into a single list, so that the diagonalization subspace is invariant with respect to the exchange of spin alpha with spin beta.

  *   **include\_configurations** ([*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*] |* [*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*],* [*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*]] | None*) – Configurations to always include in the diagonalization subspace. You can specify either a single list of single-spin strings to use for both spin sectors, or a pair (alpha\_strings, beta\_strings) of lists of single-spin strings, one for each spin.

  *   **initial\_occupancies** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*] | None*) – Initial guess for the average occupancies of the orbitals.

  *   **carryover\_threshold** ([*float*](https://docs.python.org/3/library/functions.html#float)) – Threshold for carrying over bitstrings with large CI weight from one iteration of configuration recovery to the next. All single-spin CI strings associated with configurations whose coefficient has absolute value greater than this threshold will be included in the diagonalization subspace for the next iteration. A smaller threshold will retain more configurations, leading to a larger subspace and hence a more costly diagonalization.

  *   **callback** ([*Callable*](https://docs.python.org/3/library/typing.html#typing.Callable)*\[\[*[*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[SCIResult]], None] | None*) – A callback function to be called after each configuration recovery iteration. The function will be passed the output of the sci\_solver function, which is a list of (energy, sci\_state, occupancies) triplets, where each triplet contains the result of a diagonalization.

  *   **seed** ([*Generator*](https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator)  *|*[*int*](https://docs.python.org/3/library/functions.html#int) *| None*) – A seed for the pseudorandom number generator.

  **Returns**

  The estimate of the energy and the SCI state with that energy.

  **Return type**

  *SCIResult*
</Function>

### enlarge\_batch\_from\_transitions

<Function id="qiskit_addon_sqd.fermion.enlarge_batch_from_transitions" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L733-L756" signature="enlarge_batch_from_transitions(bitstring_matrix, transition_operators)">
  Apply the set of transition operators to the configurations represented in `bitstring_matrix`.

  **Parameters**

  *   **bitstring\_matrix** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – A 2D array of `bool` representations of bit values such that each row represents a single bitstring.
  *   **transition\_operators** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – A 1D or 2D array `I`, `+`, `-`, and `n` strings representing the action of the identity, creation, annihilation, or number operators. Each row represents a transition operator.

  **Returns**

  Bitstring matrix representing the augmented set of electronic configurations after applying the excitation operators.

  **Return type**

  [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)
</Function>

### solve\_fermion

<Function id="qiskit_addon_sqd.fermion.solve_fermion" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L429-L529" signature="solve_fermion(bitstring_matrix, /, hcore, eri, *, open_shell=False, spin_sq=None, shift=0.1, **kwargs)">
  Approximate the ground state given molecular integrals and a set of electronic configurations.

  **Parameters**

  *   **bitstring\_matrix** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*] |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) –

      A set of configurations defining the subspace onto which the Hamiltonian will be projected and diagonalized.

      This may be specified in two ways:

      *   Bitstring matrix: A 2D `numpy.ndarray` of `bool` values, where each row represents a bitstring. The spin-up configurations should occupy column indices `(N, N/2]`, and the spin-down configurations should occupy column indices `(N/2, 0]`, where `N` is the number of qubits.
      *   CI strings: A tuple of two sequences containing integer representations of spin-up and spin-down determinants, respectively. The expected format is `([a_str_0, ..., a_str_N], [b_str_0, ..., b_str_M])`.

  *   **hcore** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – Core Hamiltonian matrix representing single-electron integrals

  *   **eri** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – Electronic repulsion integrals representing two-electron integrals

  *   **open\_shell** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – A flag specifying whether configurations from the left and right halves of the bitstrings should be kept separate. If `False`, CI strings from the left and right halves of the bitstrings are combined into a single set of unique configurations and used for both the alpha and beta subspaces.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float) *| None*) – Target value for the total spin squared for the ground state, $S^2 = s(s + 1)$. If `None`, no spin will be imposed.

  *   **shift** ([*float*](https://docs.python.org/3/library/functions.html#float)) – Level shift for states which have different spin. $(H + shift * S^2)|ψ> = E|ψ>$

  *   **\*\*kwargs** – Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  *   Minimum energy from SCI calculation
  *   The SCI ground state
  *   Tuple containing orbital occupancies for spin-up and spin-down orbitals. Formatted as: `(array([occ_a_0, ..., occ_a_N]), array([occ_b_0, ..., occ_b_N]))`
  *   Expectation value of spin-squared

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[float](https://docs.python.org/3/library/functions.html#float), [*SCIState*](#qiskit_addon_sqd.fermion.SCIState "qiskit_addon_sqd.fermion.SCIState"), [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)], [float](https://docs.python.org/3/library/functions.html#float)]
</Function>

### solve\_sci

<Function id="qiskit_addon_sqd.fermion.solve_sci" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L368-L426" signature="solve_sci(ci_strings, one_body_tensor, two_body_tensor, norb, nelec, *, spin_sq=None, **kwargs)">
  Diagonalize Hamiltonian in subspace defined by CI strings.

  **Parameters**

  *   **ci\_strings** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*]*) – Pair (strings\_a, strings\_b) of arrays of spin-alpha CI strings and spin-beta CI strings whose Cartesian product give the basis of the subspace in which to perform a diagonalization.

  *   **one\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – The one-body tensor of the Hamiltonian.

  *   **two\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – The two-body tensor of the Hamiltonian.

  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of spatial orbitals.

  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*,* [*int*](https://docs.python.org/3/library/functions.html#int)*]*) – The numbers of alpha and beta electrons.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float) *| None*) – Target value for the total spin squared for the ground state. If `None`, no spin will be imposed.

  *   **\*\*kwargs** –

      Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  The diagonalization result.

  **Return type**

  *SCIResult*
</Function>

### solve\_sci\_batch

<Function id="qiskit_addon_sqd.fermion.solve_sci_batch" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L327-L365" signature="solve_sci_batch(ci_strings, one_body_tensor, two_body_tensor, norb, nelec, *, spin_sq=None, **kwargs)">
  Diagonalize Hamiltonian in subspaces.

  **Parameters**

  *   **ci\_strings** ([*list*](https://docs.python.org/3/library/stdtypes.html#list)*\[*[*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*]]*) – List of pairs (strings\_a, strings\_b) of arrays of spin-alpha CI strings and spin-beta CI strings whose Cartesian product give the basis of the subspace in which to perform a diagonalization.

  *   **one\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – The one-body tensor of the Hamiltonian.

  *   **two\_body\_tensor** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – The two-body tensor of the Hamiltonian.

  *   **norb** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of spatial orbitals.

  *   **nelec** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*int*](https://docs.python.org/3/library/functions.html#int)*,* [*int*](https://docs.python.org/3/library/functions.html#int)*]*) – The numbers of alpha and beta electrons.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float) *| None*) – Target value for the total spin squared for the ground state. If `None`, no spin will be imposed.

  *   **\*\*kwargs** –

      Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  The results of the diagonalizations in the subspaces given by ci\_strings.

  **Return type**

  [list](https://docs.python.org/3/library/stdtypes.html#list)\[*SCIResult*]
</Function>

### optimize\_orbitals

<Function id="qiskit_addon_sqd.fermion.optimize_orbitals" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L532-L643" signature="optimize_orbitals(bitstring_matrix, /, hcore, eri, k_flat, *, open_shell=False, spin_sq=0.0, num_iters=10, num_steps_grad=10000, learning_rate=0.01, **kwargs)">
  Optimize orbitals to produce a minimal ground state.

  The process involves iterating over 3 steps:

  **For `num_iters` iterations:**

  *   Rotate the integrals with respect to the parameters, `k_flat`
  *   Diagonalize and approximate the groundstate energy and wavefunction amplitudes
  *   Optimize `k_flat` using gradient descent and the wavefunction amplitudes found in Step 2

  Refer to [Sec. II A 4](https://arxiv.org/pdf/2405.05068) for more detailed discussion on this orbital optimization technique.

  **Parameters**

  *   **bitstring\_matrix** ([*tuple*](https://docs.python.org/3/library/stdtypes.html#tuple)*\[*[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*,* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)*] |* [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) –

      A set of configurations defining the subspace onto which the Hamiltonian will be projected and diagonalized.

      This may be specified in two ways:

      *   Bitstring matrix: A 2D `numpy.ndarray` of `bool` values, where each row represents a bitstring. The spin-up configurations should occupy column indices `(N, N/2]`, and the spin-down configurations should occupy column indices `(N/2, 0]`, where `N` is the number of qubits.
      *   CI strings: A tuple of two sequences containing integer representations of spin-up and spin-down determinants, respectively. The expected format is `([a_str_0, ..., a_str_N], [b_str_0, ..., b_str_M])`.

  *   **hcore** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – Core Hamiltonian matrix representing single-electron integrals

  *   **eri** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – Electronic repulsion integrals representing two-electron integrals

  *   **k\_flat** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – 1D array defining the orbital transform, `K`. The array should specify the upper triangle of the anti-symmetric transform operator in row-major order, excluding the diagonal.

  *   **open\_shell** ([*bool*](https://docs.python.org/3/library/functions.html#bool)) – A flag specifying whether configurations from the left and right halves of the bitstrings should be kept separate. If `False`, CI strings from the left and right halves of the bitstrings are combined into a single set of unique configurations and used for both the alpha and beta subspaces.

  *   **spin\_sq** ([*float*](https://docs.python.org/3/library/functions.html#float)) – Target value for the total spin squared for the ground state

  *   **num\_iters** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of iterations of orbital optimization to perform

  *   **num\_steps\_grad** ([*int*](https://docs.python.org/3/library/functions.html#int)) – The number of steps of gradient descent to perform during each optimization iteration

  *   **learning\_rate** ([*float*](https://docs.python.org/3/library/functions.html#float)) – The learning rate to use during gradient descent

  *   **\*\*kwargs** –

      Keyword arguments to pass to [pyscf.fci.selected\_ci.kernel\_fixed\_space](https://pyscf.org/pyscf_api_docs/pyscf.fci.html#pyscf.fci.selected_ci.kernel_fixed_space)

  **Returns**

  *   The groundstate energy found during the last optimization iteration
  *   An optimized 1D array defining the orbital transform
  *   Tuple containing orbital occupancies for spin-up and spin-down orbitals. Formatted as: `(array([occ_a_0, ..., occ_a_N]), array([occ_b_0, ..., occ_b_N]))`

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[float](https://docs.python.org/3/library/functions.html#float), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)]]
</Function>

### rotate\_integrals

<Function id="qiskit_addon_sqd.fermion.rotate_integrals" github="https://github.com/Qiskit/qiskit-addon-sqd/tree/stable/0.11/qiskit_addon_sqd/fermion.py#L646-L683" signature="rotate_integrals(hcore, eri, k_flat)">
  Perform a similarity transform on the integrals.

  The transformation is described as:

$$
\hat{\widetilde{H}} = \hat{U^{\dagger}}(k)\hat{H}\hat{U}(k)
$$

  For more information on how $\hat{U}$ and $\hat{U^{\dagger}}$ are generated from `k_flat` and applied to the one- and two-body integrals, refer to [Sec. II A 4](https://arxiv.org/pdf/2405.05068).

  **Parameters**

  *   **hcore** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – Core Hamiltonian matrix representing single-electron integrals
  *   **eri** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – Electronic repulsion integrals representing two-electron integrals
  *   **k\_flat** ([*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)) – 1D array defining the orbital transform, `K`. The array should specify the upper triangle of the anti-symmetric transform operator in row-major order, excluding the diagonal.

  **Returns**

  *   The rotated core Hamiltonian matrix
  *   The rotated ERI matrix

  **Return type**

  [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray), [*ndarray*](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray)]
</Function>

