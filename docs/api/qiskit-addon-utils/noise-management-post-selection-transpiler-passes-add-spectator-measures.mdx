---
title: AddSpectatorMeasures (latest version)
description: API reference for qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures in the latest version of qiskit-addon-utils
in_page_toc_min_heading_level: 1
python_api_type: class
python_api_name: qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures
---

# AddSpectatorMeasures

<Class id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures" isDedicatedPage={true} github="https://github.com/Qiskit/qiskit-addon-utils/tree/stable/0.3/qiskit_addon_utils/noise_management/post_selection/transpiler/passes/add_spectator_measures.py#L32-L157" signature="AddSpectatorMeasures(*args, **kwargs)" modifiers="class">
  Bases: [`TransformationPass`](/docs/api/qiskit/qiskit.transpiler.TransformationPass)

  Add measurements on spectator qubits.

  An active qubit is a qubit acted on in the circuit by a non-barrier instruction. A terminated qubit is one whose last action is a measurement. A spectator qubit is a qubit that is inactive, but adjacent to an active qubit under the coupling map. This pass adds a measurement to all spectator qubits and, optionally via `include_unmeasured`, to all active qubits that are not terminated qubits.

  The added measurements write to a new register that has one bit per spectator qubit and name `spectator_creg_name`.

  <Admonition title="Note" type="note">
    When this pass encounters a control flow operation, it iterates through all of its blocks. It marks as “active” every qubit that is active within at least one of the blocks, and as “terminated” every qubit that is terminated in every one of the blocks.
  </Admonition>

  Initialize the pass.

  **Parameters**

  *   **coupling\_map** – A coupling map or a list of tuples indicating pairs of neighboring qubits.
  *   **include\_unmeasured** – Whether the qubits that are active but are not terminated by a measurement should also be treated as spectators. If `True`, a terminal measurement is added on each of them.
  *   **spectator\_creg\_name** – The name of the classical register added for the measurements on the spectator qubits.
  *   **add\_barrier** – Whether to add a barrier acting on all active and spectator qubits prior to the spectator measurements.

  ## Attributes

  ### is\_analysis\_pass

  <Attribute id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures.is_analysis_pass">
    Check if the pass is an analysis pass.

    If the pass is an AnalysisPass, that means that the pass can analyze the DAG and write the results of that analysis in the property set. Modifications on the DAG are not allowed by this kind of pass.
  </Attribute>

  ### is\_transformation\_pass

  <Attribute id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures.is_transformation_pass">
    Check if the pass is a transformation pass.

    If the pass is a TransformationPass, that means that the pass can manipulate the DAG, but cannot modify the property set (but it can be read).
  </Attribute>

  ## Methods

  ### execute

  <Function id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures.execute" signature="execute(passmanager_ir, state, callback=None)">
    Execute optimization task for input Qiskit IR.

    **Parameters**

    *   **passmanager\_ir** ([*Any*](https://docs.python.org/3/library/typing.html#typing.Any)) – Qiskit IR to optimize.
    *   **state** ([*PassManagerState*](/docs/api/qiskit/qiskit.passmanager.PassManagerState)) – State associated with workflow execution by the pass manager itself.
    *   **callback** ([*Callable*](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable) *| None*) – A callback function which is caller per execution of optimization task.

    **Returns**

    Optimized Qiskit IR and state of the workflow.

    **Return type**

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple)\[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any), [*PassManagerState*](/docs/api/qiskit/qiskit.passmanager.PassManagerState)]
  </Function>

  ### name

  <Function id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures.name" signature="name()">
    Name of the pass.

    **Return type**

    [str](https://docs.python.org/3/library/stdtypes.html#str)
  </Function>

  ### run

  <Function id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures.run" github="https://github.com/Qiskit/qiskit-addon-utils/tree/stable/0.3/qiskit_addon_utils/noise_management/post_selection/transpiler/passes/add_spectator_measures.py#L78-L107" signature="run(dag)">
    Run a pass on the DAGCircuit. This is implemented by the pass developer.

    **Parameters**

    **dag** ([*DAGCircuit*](/docs/api/qiskit/qiskit.dagcircuit.DAGCircuit)) – the dag on which the pass is run.

    **Raises**

    [**NotImplementedError**](https://docs.python.org/3/library/exceptions.html#NotImplementedError) – when this is left unimplemented for a pass.
  </Function>

  ### update\_status

  <Function id="qiskit_addon_utils.noise_management.post_selection.transpiler.passes.AddSpectatorMeasures.update_status" signature="update_status(state, run_state)">
    Update workflow status.

    **Parameters**

    *   **state** ([*PassManagerState*](/docs/api/qiskit/qiskit.passmanager.PassManagerState)) – Pass manager state to update.
    *   **run\_state** (*RunState*) – Completion status of current task.

    **Returns**

    Updated pass manager state.

    **Return type**

    [*PassManagerState*](/docs/api/qiskit/qiskit.passmanager.PassManagerState)
  </Function>
</Class>

