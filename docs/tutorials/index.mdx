---
title: Tutorials
description: Browse tutorials on utility-scale workflows or Qiskit capabilities and learn how to use Qiskit to common use cases.
---

# Tutorials

Use these tutorials to learn how to apply Qiskit to common quantum computing use cases. You can browse tutorials by workflow or capability in the left navigation bar. The section on workflows towards utility contains end-to-end examples of using the quantum computer to solve a real-world problem. We focus on examples of algorithms which are promising candidates for achieving computational advantange of a quantum computer versus a classical computer. The section on Qiskit capabilities contains examples of leveraging the latest and most advanced techniques present in Qiskit and its ecosystem to improve part or the whole of a particular workflow.


## Explore workflows towards utility

Tutorials in this section cover large scale demonstrations of quantum algorithms. These are classified into three categories: Verifiable sampling algorithms, Observable estimation and Fault tolerant algorithms. 


<details>
  <summary>**Verifiable sampling algorithms**</summary>

The algorithms in this category focus on quantum circuits whose output distributions encode solutions to structured problems and whose output can be validated. Verifiability here refers to the ability to check consistency between measured data either through evaluating the chosen bitstring or knowledge that false positive are known to not occur. The tutorials highlight techniques where repeated sampling enables estimation of problem-specific quantities (e.g., cost function values or spectral weights). These methods are particularly relevant for optimization and simulation tasks with symmetries.

* [Sample-based quantum diagonalization of a chemistry Hamiltonian](/docs/tutorials/sample-based-quantum-diagonalization)

* [Compute dissociation curves for strong coupling systems with QunaSys QSCI](/docs/tutorials/compute-dissociation-curves-for-strong-coupling-systems-with-quna-sys-qsci)

* [Quantum approximate optimization algorithm](/docs/tutorials/quantum-approximate-optimization-algorithm)

* [Advanced Techniques for QAOA](/docs/tutorials/advanced-techniques-for-qaoa)

* [Pauli Correlation Encoding to reduce Maxcut requirements](/docs/tutorials/pauli-correlation-encoding-for-qaoa)

* [Higher-order binary optimization with Q-CTRL's Optimization Solver](/docs/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver.)


</details>

<details>
  <summary>**Observable estimation**</summary>

These tutorials focus on estimating physically meaningful quantities—such as energy or correlation values—by preparing quantum states and measuring observables. Techniques include both variational and trotterized circuit approaches that balance circuit expressiveness with circuit-depth efficiency. Emphasis in our development is placed on workflows that reduce quantum resource demands while maintaining accuracy, enabling practical estimation of observables in chemical and physical systems.

* [Krylov quantum diagonalization of lattice Hamiltonians](/docs/tutorials/krylov-quantum-diagonalization)

* [Nishimori phase transition](/docs/tutorials/nishimori-phase-transition)

* [Dissociation PES curves with Qunova HiVQE](/docs/tutorials/qunova-hivqe)

* [Variational quantum eigensolver](/docs/tutorials/variational-quantum-eigensolver)

* [Ground state energy estimation of the Heisenberg chain with VQE](/docs/tutorials/spin-chain-vqe)

* [Quantum kernel training](/docs/tutorials/quantum-kernel-training)

* [CHSH inequality](/docs/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Fault tolerant algorithms**</summary>

This section features algorithms with well-defined theoretical guarantees that are designed to run on future error-corrected quantum hardware. The circuits or sampling overhead for these algorithms scale in a manner which is not depth-efficient and are thereby more likely to demonstrate quantum advantage when there exist a fault-tolerant quantum computer. Tutorials illustrate how these methods operate in idealized settings and have demonstration for small scale examples.

* [Grover's algorithm](/docs/tutorials/grovers-algorithm)

</details>



## Leverage Qiskit capabilities

This section introduces advanced capabilities within the Qiskit ecosystem that enhance performance, reliability, and speed when executing quantum algorithms.


<details>
  <summary>**Workload optimization**</summary>

Workload optimization focuses on either efficient orchestration of classical and quantum resources or tailored methods for improving manipulating quantum circuits. 

* [Qiskit AI-powered transpiler service introduction](/docs/tutorials/ai-transpiler-introduction)

* [Transpilation Optimizations with SABRE](/docs/tutorials/transpilation-optimizations-with-sabre

* [Compare transpiler settings](/docs/tutorials/circuit-transpilation-settings)

* [Long-range entanglement with dynamic circuits](/docs/tutorials/long-range-entanglement)


</details>

<details>
  <summary>**Addons**</summary>

Addons enable advanced circuit manipulation —such as cutting, backpropagating observables, or approximating circuits— that allow users to sidestep hardware limitations at the cost of increased classical compute overhead.

* [Approximate quantum compilation for time evolution circuits](/docs/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator backpropagation (OBP) for estimation of expectation values](/docs/tutorials/operator-back-propagation)

* [Wire cutting for expectation values estimation](/docs/tutorials/wire-cutting)

* [Circuit cutting for periodic boundary conditions(/docs/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit cutting for depth reduction](/docs/tutorials/depth-reduction-with-circuit-cutting)

</details>


<details>
  <summary>**Error mitigation**</summary>

Error mitigation addresses the challenge of noise without full fault tolerance by recovering accurate expectation values through controlled circuit manipulation and post processing. 

* [Utility-scale error mitigation with probabilistic error amplification](/docs/tutorials/probabilistic-error-amplification)

* [Combine error mitigation options with the estimator primitive](/docs/tutorials/combine-error-mitigation-techniques)

* [Error mitigation with the IBM Circuit function](/docs/tutorials/error-mitigation-with-qiskit-functions)

* [Real-time benchmarking for qubit selection](/docs/tutorials/real-time-benchmarking-for-qubit-selection)



</details>


<details>
  <summary>**Error detection**</summary>

Error detection identifies faulty operations to return noise-free results shot-by-shot by post-processing.

* [Repeat until success](/docs/tutorials/repeat-until-success)

* [Repetition codes](/docs/tutorials/repetition-codes)

</details>





