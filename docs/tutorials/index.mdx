---
title: Tutorials
description: Browse tutorials on workflows toward advantage or Qiskit capabilities, and learn how to use Qiskit for common use cases.
---

# Tutorials

Use these tutorials to learn how to apply Qiskit to common quantum computing use cases.

- Start with the set of tutorials in the [Get started](#get-started) section if it is your first time running code on a quantum computer.
- The section on [workflows toward advantage](#explore-workflows-toward-advantage) contains end-to-end examples of using a quantum computer to solve real-world problems. These tutorials focus on algorithms that are promising candidates for achieving computational advantage by a quantum computer over a classical computer.
- The section on [Qiskit capabilities](#leverage-qiskit-capabilities) contains examples that use the latest and most advanced techniques in the Qiskit ecosystem to improve part or the whole of a particular workflow.

## Get started

These tutorials are for beginners who are ready to explore running quantum algorithms on a quantum computer.

* [CHSH inequality](/docs/tutorials/chsh-inequality)

## Explore workflows toward advantage

Tutorials in this section cover large-scale demonstrations of quantum algorithms.


<details>
  <summary>**Verifiable sampling algorithms**</summary>

The algorithms in this category focus on quantum circuits whose output distributions encode solutions to structured problems with verifiable output. Verifiability means that you can check the consistency between measured data, either through evaluating the chosen bitstring or by knowing that false positives do not occur.

The tutorials highlight techniques where repeated sampling enables estimation of problem-specific quantities (for example, cost function values or spectral weights). These methods are particularly relevant for optimization and simulation tasks with symmetries.

* [Sample-based quantum diagonalization of a chemistry Hamiltonian](/docs/tutorials/sample-based-quantum-diagonalization)

* [Sample-based Krylov quantum diagonalization of a fermionic lattice model](/docs/tutorials/sample-based-krylov-quantum-diagonalization)

* [Quantum approximate optimization algorithm](/docs/tutorials/quantum-approximate-optimization-algorithm)

* [Advanced techniques for QAOA](/docs/tutorials/advanced-techniques-for-qaoa)

* [Pauli Correlation Encoding to reduce Maxcut requirements](/docs/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Observable estimation**</summary>

These tutorials focus on estimating physically meaningful quantities, such as energy or correlation values, by preparing quantum states and measuring observables. Techniques include both variational and Trotterized circuit approaches that balance circuit expressiveness with circuit-depth efficiency. Emphasis is placed on workflows that reduce quantum resource demands while maintaining accuracy, and enabling practical estimation of observables in chemical and physical systems.

* [Krylov quantum diagonalization of lattice Hamiltonians](/docs/tutorials/krylov-quantum-diagonalization)

* [Nishimori phase transition](/docs/tutorials/nishimori-phase-transition)

* [Ground state energy estimation of the Heisenberg chain with VQE](/docs/tutorials/spin-chain-vqe)

* [Quantum kernel training](/docs/tutorials/quantum-kernel-training)

* [Enhance feature classification using projected quantum kernels](/docs/tutorials/projected-quantum-kernels)

* [CHSH inequality](/docs/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Fault-tolerant algorithms**</summary>

This section features algorithms with well-defined theoretical guarantees that are designed to run on future error-corrected quantum hardware. The circuits or sampling overhead for these algorithms scale in a manner that is not depth-efficient and are thereby are more likely to demonstrate quantum advantage when fault-tolerant quantum computers exist. These tutorials illustrate how the methods operate in idealized settings and demonstrate small scale examples.

* [Shor's algorithm](/docs/tutorials/shors-algorithm)
* [Grover's algorithm](/docs/tutorials/grovers-algorithm)

</details>

## Leverage Qiskit capabilities

This section introduces advanced capabilities within the Qiskit ecosystem that enhance performance, reliability, and speed when executing quantum algorithms.


<details>
  <summary>**Workload optimization**</summary>

Workload optimization focuses on either efficient orchestration of classical and quantum resources or tailored methods for improving quantum circuit manipulation.

* [Benchmark dynamic circuits with cut Bell pairs](/docs/tutorials/edc-cut-bell-pair-benchmarking)

* [Introduction to fractional gates](/docs/tutorials/fractional-gates)

* [Qiskit AI-powered transpiler service introduction](/docs/tutorials/ai-transpiler-introduction)

* [Transpilation optimizations with SABRE](/docs/tutorials/transpilation-optimizations-with-sabre)

* [Compilation methods for Hamiltonian simulation circuits](/docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Long-range entanglement with dynamic circuits](/docs/tutorials/long-range-entanglement)

* [Simulation of kicked Ising Hamiltonian with dynamic circuits](/docs/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Qiskit Functions are a collection of pre-packaged error management and application tools, making it easy to design large-scale experiments with circuits, molecules, QUBOs, and more.

- Design new algorithms with **Circuit functions** -- with pre-built transpilation, error suppression, and error mitigation pipelines.

  * [Error mitigation with the IBM Circuit function](/docs/tutorials/error-mitigation-with-qiskit-functions)

  * [Transverse-Field Ising Model with Q-CTRL's Performance Management](/docs/tutorials/transverse-field-ising-model)

  * [Quantum Phase Estimation with Q-CTRL's Qiskit Functions](/docs/tutorials/quantum-phase-estimation-qctrl)

  * [Simulate 2D tilted-field Ising with the QESEM function](/docs/tutorials/qedma-2d-ising-with-qesem)

- Experiment with domain-specific problems with **Application functions** -- with familiar inputs and outputs to classical solvers.

  * [Quantum Portfolio Optimizer - A Qiskit Function by Global Data Quantum](/docs/tutorials/global-data-quantum-optimizer)

  * [Higher-order binary optimization with Q-CTRL's Optimization Solver](/docs/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Model a flowing non-viscous fluid using QUICK-PDE](/docs/tutorials/colibritd-pde)

  * [Dissociation PES curves with Qunova HiVQE](/docs/tutorials/qunova-hivqe)

  * [Hybrid quantum-enhanced ensemble classification (grid stability workflow)](/docs/tutorials/sml-classification)
  
  * [Solve the Market Split problem with Kipu Quantum's Iskay Quantum Optimizer](/docs/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Qiskit addons**</summary>

Addons enable advanced circuit manipulation, such as cutting, backpropagating observables, or approximating circuits, that allow users to sidestep hardware limitations at the cost of increased classical compute overhead.

* [Multi-product formulas to reduce Trotter error](/docs/tutorials/multi-product-formula)

* [Approximate quantum compilation for time evolution circuits](/docs/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator backpropagation (OBP) for estimation of expectation values](/docs/tutorials/operator-back-propagation)

* [Wire cutting for expectation values estimation](/docs/tutorials/wire-cutting)

* [Circuit cutting for periodic boundary conditions](/docs/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit cutting for depth reduction](/docs/tutorials/depth-reduction-with-circuit-cutting)

* [Readout error mitigation for the Sampler primitive using M3](/docs/tutorials/readout-error-mitigation-sampler)

</details>


<details>
  <summary>**Error mitigation**</summary>

Error mitigation addresses the challenge of noise without full fault tolerance by recovering accurate expectation values through controlled circuit manipulation and post-processing.

* [Utility-scale error mitigation with probabilistic error amplification](/docs/tutorials/probabilistic-error-amplification)

* [Combine error mitigation options with the Estimator primitive](/docs/tutorials/combine-error-mitigation-techniques)

* [Real-time benchmarking for qubit selection](/docs/tutorials/real-time-benchmarking-for-qubit-selection)



</details>


<details>
  <summary>**Error detection**</summary>

Error detection identifies faulty operations to return noise-free results shot-by-shot by post-processing.

* [Repetition codes](/docs/tutorials/repetition-codes)

* [Low-overhead error detection with spacetime codes](/docs/tutorials/ghz-spacetime-codes)

</details>





