---
title: Exact simulation with Qiskit primitives
description: How to perform exact simulation of quantum circuits using primitives in Qiskit.
---

# Exact simulation with Qiskit primitives

The reference primitives in Qiskit can perform local statevector simulations, which is useful for quickly prototyping algorithms. 

The `Estimator` primitive can compute expectation values of circuits, and the `Sampler` primitive can sample from output distributions of circuits.  

## Compute an expectation value with the `Estimator` primitive

Follow these instructions to get the expected value of an observable for a given quantum circuit with the [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) primitive.

### Initialize observables

The first step is to define the observables whose expected values you want to compute. Each observable can be a Pauli string, a dictionary mapping Pauli strings to real coefficients, or a [`qiskit.quantum_info.SparsePauliOp`](../api/qiskit/qiskit.quantum_info.SparsePauliOp).
In this example, we define a single observable, but in general, you can attach many observables to a single circuit.

```python
from qiskit.quantum_info import SparsePauliOp

observable = SparsePauliOp(["II", "XX", "YY", "ZZ"], coeffs=[1, 1, -1, 1])
```

### Initialize QuantumCircuit

Next, create the [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit) for which you want to obtain the expected value.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.draw("mpl", style="iqp")
```

![Initial QuantumCircuit](/images/verify/simulate-with-qiskit-primitives/estimator-initialize.png "Initial QuantumCircuit")

<Admonition type="note">
  The [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit) you pass to [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) must not include any measurements.
</Admonition>

### Initialize `Estimator`

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    Next, instantiate an [`qiskit.primitives.StatevectorEstimator`](../api/qiskit/qiskit.primitives.StatevectorEstimator).

```python
from qiskit.primitives import StatevectorEstimator
estimator = StatevectorEstimator()
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    Next, instantiate an [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator).

```python
from qiskit.primitives import Estimator

estimator = Estimator()
```
  </TabItem>
</Tabs>


### Run and get results

This example only uses one [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit) and one observable. 

* For V1 primitives, if you want to get expectation values for multiple circuits and observables, you can pass a `list` of [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit)s and a list of `BaseOperator`s to the [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run) method. Both `list`s must have the same length.

* The V2 primitives accept **vectorized inputs**, where single circuits can be grouped with array-valued specifications. That is, one circuit can be executed
  for arrays of `n` parameter sets, `n` observables, or both (in the case of the estimator). Each group is called a  **primitive unified bloc (PUB)**, and can be represented as a tuple: `(1 x circuit, [n x observables], [n x parameters])`. Each PUB gets its own result.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    Run the estimation by calling the [`qiskit.primitives.StatevectorEstimator.run`](../api/qiskit/qiskit.primitives.StatevectorEstimator#run) method. 

```python
job = estimator.run([(qc, observable)])
result = job.result()[0].data.evs

print(f" > Metadata: {result[0].metadata}")
```
  </TabItem>
  <TabItem value="EstimatorV1" label="Estimator (V1)">
    Run your estimation by calling the [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run) method,
which returns an instance of [`qiskit.providers.JobV1`](../api/qiskit/qiskit.providers.JobV1). 


    ```python
job = estimator.run(qc, observable)
result = job.result()
print(result)
```
You can get the results from the job (as a [`qiskit.primitives.EstimatorResult`](../api/qiskit/qiskit.primitives.EstimatorResult) object)
with the [`qiskit.providers.JobV1.result`](../api/qiskit/qiskit.providers.JobV1#result) method.

```python
EstimatorResult(values=array([4.]), metadata=[{}])
```
  </TabItem>
</Tabs>

#### Get the expected value


<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
print(f" > Expectation value: {result[0].data.evs}")
print(f" > Metadata: {result[0].metadata}")
```
  </TabItem>
  <TabItem value="EstimatorV1" label="Estimator (V1)">
  From these results you can extract the expected values with the attribute [`qiskit.primitives.EstimatorResult.values`](../api/qiskit/qiskit.primitives.EstimatorResult#values).

[`qiskit.primitives.EstimatorResult.values`](../api/qiskit/qiskit.primitives.EstimatorResult#values) returns a `numpy.ndarray`
whose `i`<sup>th</sup> element is the expectation value corresponding to the `i`<sup>th</sup> circuit and `i`<sup>th</sup> observable.

  ```python
exp_value = result.values[0]
print(exp_value)
```

```python
3.999999999999999
```
  </TabItem>
</Tabs>

### Parameterized circuit with `Estimator`

The [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) primitive can be run with unbound parameterized circuits like the one below.
You can also manually bind values to the parameters of the circuit and follow the steps of the previous example.

```python
from qiskit.circuit import Parameter

theta = Parameter('θ')
param_qc = QuantumCircuit(2)
param_qc.ry(theta, 0)
param_qc.cx(0,1)
print(param_qc.draw(style="iqp"))
```

```
     ┌───────┐
q_0: ┤ Ry(θ) ├──■──
     └───────┘┌─┴─┐
q_1: ─────────┤ X ├
              └───┘
```

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
  ```python
import numpy as np

parameter_values = [[0], [np.pi/6], [np.pi/2]]

job = estimator.run([(param_qc, [[obs1, obs2, obs3]], [parameter_values])])

values = job.result()[0].data.evs

print(f"Parameter: {parameter_values[0]:.5f}\t Expectation value: {result[0].data.evs}")
```   
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    The main difference with the previous case is that now you need to specify the sets of parameter values for which you want to evaluate the expectation value as a `list` of `list`s of `float`s.
The `i`<sup>th</sup> element of the outer `list` is the set of parameter values that corresponds to the `i`<sup>th</sup> circuit and observable.

```python
import numpy as np

parameter_values = [[0], [np.pi/6], [np.pi/2]]

job = estimator.run([param_qc]*3, [observable]*3, parameter_values=parameter_values)
values = job.result().values

for i in range(3):
    print(f"Parameter: {parameter_values[i][0]:.5f}\t Expectation value: {values[i]}")
```

```
Parameter: 0.00000   Expectation value: 2.0
Parameter: 0.52360   Expectation value: 3.0
Parameter: 1.57080   Expectation value: 4.0
```
  </TabItem>
</Tabs>

### Change run options

Your workflow might require tuning primitive run options, such as the number of shots.

<Tabs>
  <TabItem value="V2" label="V2 primitives">
    The sampling overhead, commonly exposed by V1 implementations
  through the `shots` run option, is now an argument of the primitives `run()` method 
  that can be specified at the **PUB** level.
  The V2 base classes expose the arguments in formats different from the V1 API:

    * [`BaseSamplerV2.run`](/api/qiskit/qiskit.primitives.BaseSamplerV2#run)
      exposes a `shots` argument (similar to the previous workflow):
        
        ```python
        # Sample two circuits at 128 shots each.
        sampler_v2.run([circuit1, circuit2], shots=128)
        # Sample two circuits at different amounts of shots. The "None"s are necessary
        # as placeholders
        # for the lack of parameter values in this example.
        sampler_v2.run([(circuit1, None, 123), (circuit2, None, 456)])
        ```

    * [`EstimatorV2.run`](/api/qiskit/qiskit.primitives.BaseEstimatorV2#run)
      introduces a `precision` argument that specifies the error bars that the
      primitive implementation should target for expectation values estimates:
        ```python
        # Estimate expectation values for two PUBs, both with 0.05 precision.
        estimator_v2.run([(circuit1, obs_array1), (circuit2, obs_array_2)], precision=0.05)
        ```
  </TabItem>

  <TabItem value="V1" label="V1 primitives">
    By default, the reference [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) class performs an exact statevector calculation based on the [`qiskit.quantum_info.Statevector`](../api/qiskit/qiskit.quantum_info.Statevector) class. However, this can be modified to include shot noise if the number of `shots` is set. For reproducibility purposes, a `seed` will also be set in the following examples.

There are two main ways of setting options in the [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator):

  - Set keyword arguments in the [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run) method.
  - Modify [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) options.
  </TabItem>
</Tabs>

#### Set keyword arguments for [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run)

If you only want to change the settings for a specific run, it can be more convenient to set the options inside the [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run) method. You can do this by passing them as keyword arguments.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
        # Estimate expectation values for two PUBs, both with 0.05 precision.
        estimator_v2.run([(circuit1, obs_array1), (circuit2, obs_array_2)], precision=0.05)
        ```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
job = estimator.run(qc, observable, shots=2048, seed=123)
result = job.result()
print(result)
```

```python
EstimatorResult(values=array([4.]), metadata=[{'variance': 3.552713678800501e-15, 'shots': 2048}])
```

```python
print(result.values[0])
```

```python
3.999999998697238
```
  </TabItem>
</Tabs>

#### Modify [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) options

If you want to keep some configuration values for several runs, it can be better to change the [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) options. That way you can use the same [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) object as many times as you wish without having to
rewrite the configuration values every time you use [`qiskit.primitives.Estimator.run`](../api/qiskit/qiskit.primitives.Estimator#run).

#### Modify existing [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator)

If you prefer to change the options of an already-defined [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator), you can use the method [`qiskit.primitives.Estimator.set_options`](../api/qiskit/qiskit.primitives.Estimator#set_options) and introduce the new options as keyword arguments.

V1 primitives example: 

<Admonition>
 For V2 primitives, `shots` is now an argument of the primitives `run()` method.
 </Admonition>

```python
estimator.set_options(shots=2048, seed=123)

job = estimator.run(qc, observable)
result = job.result()
print(result)
```

```python
EstimatorResult(values=array([4.]), metadata=[{'variance': 3.552713678800501e-15, 'shots': 2048}])
```

```python
print(result.values[0])
```

```python
3.999999998697238
```

#### Define a new [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) with the options

If you prefer to define a new [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) with new options, define a `dict` like this one:


<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
     For V2 primitives, `shots` is  an argument of the primitives `run()` method, although you can specify different options, such as `optimization_level`.

 **I'M NOT SURE WHAT TO PUT FOR THIS. ARE THERE ANY OPTIONS STILL AVAILABLE FOR V2 BASE PRIMITIVES?**


 ```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options

service = QiskitRuntimeService()
options = Options()
options.resilience_level = 2
options.optimization_level = 1
backend = service.backend("ibmq_qasm_simulator")

estimator = Estimator(options=options, backend=backend)
job = estimator.run(circuits=[psi1], observables=[H1], parameter_values=[theta1])
psi1_H1 = job.result()
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
options = {"shots": 2048, "seed": 123}
```

You can then introduce it into your new [`qiskit.primitives.Estimator`](../api/qiskit/qiskit.primitives.Estimator) with the `options` argument.

```python
estimator = Estimator(options=options)

job = estimator.run(qc, observable)
result = job.result()
print(result)
```

```python
EstimatorResult(values=array([4.]), metadata=[{'variance': 3.552713678800501e-15, 'shots': 2048}])
```

```python
print(result.values[0])
```

```python
3.999999998697238
```
  </TabItem>
</Tabs>

## Compute circuit output probabilities with `Sampler` primitive

Follow these instructions to get the probability distribution of a quantum circuit with the [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) primitive.


### Initialize QuantumCircuit

The first step is to create the [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit)s from which you want to obtain the probability distribution.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.measure_all()
qc.draw("mpl", style="iqp")
```

![Initial QuantumCircuit](/images/verify/simulate-with-qiskit-primitives/sampler-initialize.png "Initial QuantumCircuit")

<Admonition type="note">
The [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit) you pass to [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) must include measurements.
</Admonition>

### Initialize `Sampler`

Next, create a [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) instance.


<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
from qiskit.primitives import StatevectorSampler

sampler = StatevectorSampler()
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
from qiskit.primitives import Sampler

sampler = Sampler()
```
  </TabItem>
</Tabs>

### Run and get results

Run Sampler by calling the [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run) method, which returns an instance of [`qiskit.providers.JobV1`](../api/qiskit/qiskit.providers.JobV1). You can get the results from the job (as a [`qiskit.primitives.SamplerResult`](../api/qiskit/qiskit.primitives.SamplerResult) object) with the [`qiskit.providers.JobV1.result`](../api/qiskit/qiskit.providers.JobV1#result) method.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
# execute 1 circuit with 3 parameter sets using Sampler V2
job = sampler_v2.run([(circuit, [vals1, vals2, vals3])])
counts = job.result()[0].data.meas.get_counts()
```
        V2 primitives accept multiple PUBs as inputs, and each pub gets its own result. This
  lets you run different circuits with various parameter/observable combinations,
  which was not always possible in the V1 interface:

```python
# execute 2 circuits with 1 parameter set using Sampler V2
job = sampler_v2.run([(circuit1, vals1), (circuit2, vals1)])
counts1 = job.result()[0].data.meas.get_counts()  # result for pub 1 (circuit 1)
counts2 = job.result()[1].data.meas.get_counts()  # result for pub 2 (circuit 2)
```      
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
job = sampler.run(qc)
result = job.result()
print(result)
```

```python
SamplerResult(quasi_dists=[{0: 0.4999999999999999, 3: 0.4999999999999999}], metadata=[{}])
```

While this example only uses one [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit), you can sample multiple circuits by passing a `list` of [`qiskit.circuit.QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit) instances to the [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run) method.
  </TabItem>
</Tabs>

### Get the probability distribution or measurement outcome

From these results you can extract the quasi-probability distributions (V1) with the attribute [`qiskit.primitives.SamplerResult.quasi_dists`](../api/qiskit/qiskit.primitives.SamplerResult#quasi_dists). The V2 sampler returns measurement outcome samples in the form of **bitstrings** or
   **counts**. The bitstrings show the measurement outcomes, preserving the shot
   order in which they were measured. The V2 sampler result objects organize
   data in terms of their input circuits' classical register names, for
   compatibility with dynamic circuits.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    <Admonition> The name of the classical register defaults to `"meas"`.
    This name will be used later to access the measurement bitstrings.</Admonition>

      ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```
    ```python
    # Run using V2 sampler
    result = sampler_v2.run([circuit]).result()
    # Access result data for pub 0
    data_pub = result[0].data
    # Access bitstring for the classical register "meas"
    bitstring = data_pub.meas.get_bitstring()
    print(f"The bitstring shape is: {bitstring.shape}")
    # Get counts for the classical register "meas"
    counts = data_pub.meas.get_counts()
    print(f"The counts are: {counts}")
    ```
    ```text
    The bitstring shape is: (1024, 1)
    The counts are: {'00': 523, '11': 501}
    ```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    Even though there is only one circuit in this example, [`qiskit.primitives.SamplerResult.quasi_dists`](../api/qiskit/qiskit.primitives.SamplerResult#quasi_dists) returns a list of [`qiskit.result.QuasiDistribution`](../api/qiskit/qiskit.result.QuasiDistribution)s.
`result.quasi_dists[i]` is the quasi-probability distribution of the `i`<sup>th</sup> circuit.

<Admonition type="note">
A quasi-probability distribution differs from a probability distribution in that negative values are also allowed.
However, the quasi-probabilities must sum up to 1 like probabilities.
Negative quasi-probabilities may appear when using error mitigation techniques.
</Admonition>
    ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```

    ```python
    # Run using V1 sampler
    result = sampler_v1.run(circuit).result()
    quasi_dist = result.quasi_dists[0]
    print(f"The quasi-probability distribution is: {quasi_dist}")
    ```
    ```text
    The quasi-probability distribution is: {0: 0.5, 3: 0.5}
    ```
  </TabItem>
</Tabs>


#### Probability distribution with binary outputs (V1)

If you prefer to see the output keys as binary strings instead of decimal numbers, you can use the [`qiskit.result.QuasiDistribution.binary_probabilities`](../api/qiskit/qiskit.result.QuasiDistribution#binary_probabilities) method.

```python
print(quasi_dist.binary_probabilities())
```

```python
{'00': 0.4999999999999999, '11': 0.4999999999999999}
```

### Parameterized circuit with `Sampler`

The [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) primitive can be run with unbound parameterized circuits like the one below.
You can also manually bind values to the parameters of the circuit and follow the steps of the previous example.

```python
from qiskit.circuit import Parameter

theta = Parameter('θ')
param_qc = QuantumCircuit(2)
param_qc.ry(theta, 0)
param_qc.cx(0,1)
param_qc.measure_all()
print(param_qc.draw(style="iqp"))
```

```
          ┌───────┐      ░ ┌─┐   
     q_0: ┤ Ry(θ) ├──■───░─┤M├───
          └───────┘┌─┴─┐ ░ └╥┘┌─┐
     q_1: ─────────┤ X ├─░──╫─┤M├
                   └───┘ ░  ║ └╥┘
  meas: 2/══════════════════╩══╩═
                            0  1 
```



<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
     ```python
      # run 1 circuit with 3 parameter sets using Sampler V2
      job = sampler_v2.run([(param_qc, parameter_values)])
      result = job.result()

      # Get counts for the classical register "meas"
        print(f"Parameter: {parameter_values[0]:.5f}\t Counts: {result[0].data.evs}")
      ```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    The main difference from the previous case is that now you need to specify the sets of parameter values for which you want to evaluate the expectation value as a `list` of `list`s of `float`s. The `i`<sup>th</sup> element of the outer `list` is the set of parameter values that corresponds to the `i`<sup>th</sup> circuit.

```python
import numpy as np

parameter_values = [[0], [np.pi/6], [np.pi/2]]

job = sampler.run([param_qc]*3, parameter_values=parameter_values)
dists = job.result().quasi_dists

for i in range(3):
    print(f"Parameter: {parameter_values[i][0]:.5f}\t Probabilities: {dists[i]}")
```

```
Parameter: 0.00000   Probabilities: {0: 1.0}
Parameter: 0.52360   Probabilities: {0: 0.9330127018922194, 3: 0.0669872981077807}
Parameter: 1.57080   Probabilities: {0: 0.5000000000000001, 3: 0.4999999999999999}
```
  </TabItem>
</Tabs>



### Change run options

Your workflow might require tuning primitive run options, such as the number of shots.

By default, the reference [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) class performs an exact statevector
calculation based on the [`qiskit.quantum_info.Statevector`](../api/qiskit/qiskit.quantum_info.Statevector) class. However, this can be
modified to include shot noise if the number of `shots` is set.
For reproducibility purposes, a `seed` will also be set in the following examples.

There are two main ways of setting options in the [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler):

- Set keyword arguments in the [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run) method.
- Modify [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) options.

#### Set keyword arguments for [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run)

If you only want to change the settings for a specific run, it can be more convenient to set the options inside the [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run) method. You can do this by passing them as keyword arguments.



<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
# Sample two circuits at 128 shots each.
sampler_v2.run([circuit1, circuit2], shots=128)
# Sample two circuits at different amounts of shots. The "None"s are necessary
# as placeholders
# for the lack of parameter values in this example.
sampler_v2.run([(circuit1, None, 123), (circuit2, None, 456)])
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
job = sampler.run(qc, shots=2048, seed=123)
result = job.result()
print(result)
```

```python
SamplerResult(quasi_dists=[{0: 0.5205078125, 3: 0.4794921875}], metadata=[{'shots': 2048}])
```
  </TabItem>
</Tabs>

#### Modify [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) options

If you want to keep some configuration values for several runs, it can be better to change the [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) options. That way you can use the same [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) object as many times as you wish without having to rewrite the configuration values every time you use [`qiskit.primitives.Sampler.run`](../api/qiskit/qiskit.primitives.Sampler#run).

#### Modify existing [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) (V1)

If you prefer to change the options of an already-defined [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler), you can use [`qiskit.primitives.Sampler.set_options`](../api/qiskit/qiskit.primitives.Sampler#set_options) and introduce the new options as keyword arguments.

```python
sampler.set_options(shots=2048, seed=123)

job = sampler.run(qc)
result = job.result()
print(result)
```

```python
SamplerResult(quasi_dists=[{0: 0.5205078125, 3: 0.4794921875}], metadata=[{'shots': 2048}])
```

#### Define a new [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) with the options

If you prefer, you can define a new [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) with new options.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    **I'M NOT SURE WHAT TO PUT FOR THIS. ARE THERE ANY OPTIONS STILL AVAILABLE FOR V2 BASE PRIMITIVES?**
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    Define a `dict` like this one:

```python
options = {"shots": 2048, "seed": 123}
```

You can then introduce it into your new [`qiskit.primitives.Sampler`](../api/qiskit/qiskit.primitives.Sampler) with the `options` argument.

```python
sampler = Sampler(options=options)

job = sampler.run(qc)
result = job.result()
print(result)
```

```python
SamplerResult(quasi_dists=[{0: 0.5205078125, 3: 0.4794921875}], metadata=[{'shots': 2048}])
```

  </TabItem>
</Tabs>

## Next steps

<Admonition type="tip" title="Recommendations">
  - For higher-performance simulation that can handle larger circuits, or to incorporate noise models into your simulation, see [Exact and noisy simulation with Qiskit Aer primitives](simulate-with-qiskit-aer).
  - To learn how to use Quantum Composer for simulation, try the [Explore gates and circuits with the Quantum Composer](https://learning.quantum.ibm.com/tutorial/explore-gates-and-circuits-with-the-quantum-composer) tutorial.
  - Read the [Qiskit Estimator API](/api/qiskit/qiskit.primitives.Estimator) reference.
  - Read the [Qiskit Sampler API](/api/qiskit/qiskit.primitives.Sampler) reference.
  - Learn how to run on a physical system in the [Run](../run) section.
</Admonition>