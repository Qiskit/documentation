---
title: Workload usage
description: Explains what usage is and how to estimate how long a job that uses a primitive will take to run

---

<span id="usage"></span>
# Workload usage

Usage is a measurement of the amount of time the QPU is locked for your workload, and it is calculated differently, depending on which execution mode you're using.

* Session usage is the time from when the first job starts until the session goes inactive, is closed, or when its last job completes, whichever happens last. It includes both classical and quantum time.
* Batch usage is the sum of quantum time of all jobs in the batch.
* Single job usage is the quantum time the job uses in processing.

The usage reported on the dashboard or by using the API is the time a QPU is locked for your workload. Failed or canceled jobs count toward your usage in certain circumstances - see the [Failed and canceled jobs](#failed-job) section for details.

Your usage has different impacts, depending on which channel you're using:

- For Qiskit Runtime on IBM Cloud users, the usage determines how much the job costs.  See [Manage cost](/guides/manage-cost#manage-cost) for details.
- For IBM Quantum Platform users, this translates to shares. The [fair-share scheduler](/guides/fair-share-scheduler) prioritizes instances with the most shares left. Thus, the higher your usage, the longer your next job stays in the queue.

<span id="failed-job"></span>
## Usage for failed and canceled jobs

When a job is failed or canceled, the reported usage is as follows:

* Job or batch mode: The reported usage is the time the QPU was locked for executing your workload until the time it failed or was canceled. Therefore, if the failure or cancellation occurred before the lock, the reported usage is zero. Otherwise, the workload's reported usage is the value that Qiskit Runtime returns as `consumed`. Thus, some failed jobs do not appear in your reported usage and others do.

* Session mode: The reported usage is the wall-clock time from the when the first job started executing in the session until the session terminates, regardless of the number of jobs that fail or are canceled.

<span id="view-usage"></span>
## Determine a workload's actual usage

After a workload has completed, there are several ways to view its actual usage:

- On the IBM Quantum Platform [Workloads table](https://quantum.ibm.com/workloads) in the Usage column.  From the Home page, click *View all* on the Recent workloads table.  The Usage column shows actual usage for completed workloads.
- Run [`batch.usage()`](/api/qiskit-ibm-runtime/batch#usage) or [`session.usage()`](/api/qiskit-ibm-runtime/session#usage) in `qiskit-ibm-runtime` 0.30 or later.  If using an older version of `qiskit-ibm-runtime` (>= 0.23 and < 0.30), the usage can be still be found in `session.details()["usage_time"]` and `batch.details()["usage_time"]`.
- Call the [GET usage](/api/runtime/tags/usage#tags__usage) REST API directly. The reported usage is the `elapsed_time` value returned by the `GET /sessions/{id}` endpoint, for both batch and session workloads.

## Estimate workload usage

After submitting a job to the IBM Quantum&trade; channel, you can see an estimation for how much _quantum time_ the job will take to run by using `job.usage_estimation`.  Alternatively, you can [view this information on the IBM Quantum Platform user interface](#view-usage).

Quantum time is the duration, in seconds, a QPU is committed to fulfilling a user request.

<Admonition type="note" title="Notes">
    - This only applies to jobs that use primitives.
    - This is not yet available on the Qiskit Runtime on IBM Cloud&reg; channel.
</Admonition>

Example:

```python
from qiskit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

service = QiskitRuntimeService()

# Create a new circuit with two qubits (first argument) and two classical
# bits (second argument)
qc = QuantumCircuit(2, 2)

# Add a Hadamard gate to qubit 0
qc.h(0)

# Perform a controlled-X gate on qubit 1, controlled by qubit 0
qc.cx(0, 1)

# Measure qubit 0 to cbit 0, and qubit 1 to cbit 1
qc.measure(0, 0)
qc.measure(1, 1)

# Run on the least-busy device you have access to
backend = service.least_busy(simulator=False,operational=True)

# Generate ISA circuits
pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(qc)

# Create a Sampler object
sampler = Sampler(backend)

# Submit the circuit to the sampler
job = sampler.run([isa_circuit])

print(job.usage_estimation)
```
Output:

```python
{'quantum_seconds': 4.1058720028432445}
```

## Next steps

<Admonition type="tip" title="Recommendations">
    - Review these tips: [Minimize job run time](minimize-time).
    - Set the [Maximum execution time](max-execution-time).
    - Learn how to transpile locally in the [Transpile](./transpile/) section.
    - Try the [Submit pre-transpiled circuits](https://learning.quantum.ibm.com/tutorial/submitting-user-transpiled-circuits-using-primitives) tutorial.
</Admonition>