---
title: Executor primitive (beta)
description: Executor is a lower-level primitive that provides more flexibility when customizing your error mitigation workflow.

---

# Executor primitive (beta)

<Admonition type="note" title="Beta release">
The Executor primitive is currently in beta and might not be stable. You are invited to test it and provide feedback by opening an issue in the [Samplomatic](https://github.com/Qiskit/samplomatic/issues) or [Qiskit Runtime](https://github.com/Qiskit/qiskit-ibm-runtime/issues) GitHub repositories.
</Admonition>

The Executor primitive and its supporting tools are designed for quantum information scientists to run utility-scale experiments that require more control and flexibility. Executor provides the ingredients to capture design intents on the client side, and shifts the costly generation of circuit variants to the server side, so that you can fine-tune error mitigation and other techniques without sacrificing performance. Executor's clear, composable model for execution workflows makes it easier to experiment with new techniques, reproduce results, and share methods.

In this initial release, Executor support focuses mostly on Pauli twirling, noise model learning and injection, and basis changes. Other support capabilities will be added gradually over time.

## Workflow

Samplomatic uses box instructions to reason about collections of circuit operations that should be treated as having a stable noise context, and uses annotations on boxes to allow users to declare and configure intent. Every box is a scope that owns a set of qubits, operations that act on those qubits, and a list of annotations. Samplomatic annotations specify directives and dressings. Directives specify what to do with the box, e.g. twirl the box. Dressings are groups of parameterized gates to add to the left- or right-side of the box, e.g. a layer of single qubit gates.


The core type of the samplomatic is the `Samplex` class. This object represents a parametric probability distribution over the parameters of some template circuit, as well as other array-valued fields to use in post-processing data collected from executing the bound template circuit. Its `sample()` method is the primary interface you will use for querying and specifying inputs and processing outputs. The various inputs and outputs present in a samplex depend on many factors, for example, whether measurement twirling is present or whether noise injection is required. 


Important words to define:
    - box
    - annotation
    - samplex
    - dressing


## NoiseLearnerV3

## Next steps

<Admonition type="tip" title="Recommendations">
- Visit the Samplomatic documentation for [API references](https://qiskit.github.io/samplomatic/api/index.html) and guides, which include examples of the following:
    - [Dressed boxes](https://qiskit.github.io/samplomatic/guides/dressed_boxes.html)
    - [Transpiling with `generate_boxing_pass_manager()`](https://qiskit.github.io/samplomatic/guides/transpiler.html)
    - [Working with samplex inputs and outputs](https://qiskit.github.io/samplomatic/guides/samplex_io.html)
</Admonition>