---
title: Introduction to Qiskit patterns
description: Qiskit patterns are the broad steps employed when running a domain-specific problem on quantum hardware.
---
# Introduction to Qiskit patterns
A Qiskit pattern is a general framework for breaking down domain-specific problems and contextualizing required capabilities in stages. This allows for the seamless composability of new capabilities developed by IBM Quantum&trade; researchers (and others) and enables a future in which quantum computing tasks are performed by powerful heterogenous (CPU/GPU/QPU) computing infrastructure. Blocks or groups of blocks perform the steps of a pattern, with the Qiskit SDK providing an important foundational layer, supported by other tools or services developed by IBM Quantum or the quantum open-source community. Qiskit patterns allow domain experts to specify a problem and compose the tooling (blocks) that achieves a Qiskit pattern. That pattern can then be executed locally, through cloud services, or deployed with Qiskit Serverless.
The four steps of a Qiskit pattern are as follows:
- [**Map** problem to quantum circuits and operators](./map-problem-to-circuits)
- [**Optimize** for target hardware](./optimize-for-hardware)
- [**Execute** on target hardware](./execute-on-hardware)
- [**Post-process** results](./post-process-results)
![All Qiskit pattern steps are shown (Map the problem, Optimize for hardware, Execute on hardware, and Post-process results). All steps except 'Execute on hardware' use the Qiskit SDK. Optimizing for hardware additionally uses the Qiskit Transpiler Service.  Executing on hardware uses only the Qiskit Runtime Service.](/images/qiskit-patterns/patterns.svg)
Each step is detailed in the sections below.
## Map the problem to quantum circuits and operators
This step describes how a user starts with a classical problem and figures out how to map it to a quantum computer. For example, in applications such as chemistry and quantum simulation, this step generally involves constructing a quantum circuit representing the Hamiltonian you are attempting to solve. During this step, for certain problems, it might also be desirable to specify the mapping of the problem onto qubits in the heavy-hex (or gross) lattice of IBM&reg; hardware from the outset if the structure of the problem lends itself to optimization earlier. It is also worth considering at this point what the outcome of the particular algorithm will be in preparation for the later execute step - for example, if the desired outcome involves inferring correlation functions using Hadamard tests, you might prepare to use Sampler, whereas specifying observables would use the Estimator and could provide many error mitigation options.
The output of this step is normally a collection of circuits or quantum operators that can be optimized for hardware in the next step.
## Optimize for target hardware
In this step you take the abstract circuits (or operators) produced from the map step and perform a series of optimizations on them. This can include mapping the route and layout of the circuit to physical qubit hardware, converting to basis gates of the hardware, and reducing the number of operations, all designed to optimize the likelihood of success in the later execute step. At this point you might also wish to test out your circuits with a simulator before executing on real hardware in the next step.
During this step, abstract circuits must be transpiled to Instruction Set Architecture (ISA) circuits. An ISA circuit is one that only consists of gates understood by the target hardware (basis gates), and any multi-qubit gates needed to obey any connectivity constraints (coupling map). Only ISA circuits can be run on IBM hardware using IBM Qiskit Runtime.


## Execute on target hardware
