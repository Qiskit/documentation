---
title: Dynamic repetition rate execution
description: Explanatory content about dynamic repetition rate execution

---

# Dynamic repetition rate execution

All IBM&reg; quantum processing units (QPUs) use dynamic repetition rate execution for circuit execution. These QPUs are identified in Qiskit using `backend.configuration().dynamic_reprate_enabled`, and return a value of `True`. On these QPUs, it is possible to manually set the above idle time by setting the `rep_delay` of the submitted job. One can see from the above figures that by reducing the idle time one can potentially see a greater throughput of circuits on the QPUs that support dynamic repetition rates.

Note that while circuits are processed in order; that is, circuit0_shot0 -> circuit1_shot0, and so on, there is no guarantee on the order the circuits from PUBs are executed. Thus, even though you submit pubs=[pub1, pub2], there is no guarantee the circuits from pub1 will run before those from pub2.

## Specify rep_delay for a primitive job

```python
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

service = QiskitRuntimeService()

# Make sure your backend supports it
backend = service.least_busy(operational=True, min_num_qubits=100, dynamic_reprate_enabled=True)

# Determine the allowable range
backend.rep_delay_range
sampler = Sampler(mode=backend)

#Specify a value in the supported range
sampler.options.execution.rep_delay = 0.0005
```

## Next steps

<Admonition type="tip" title="Recommendations">
  - Try an example in the [Quantum approximate optimization algorithm (QAOA)](https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm) tutorial.
  - Review how to [get started with primitives.](./get-started-with-primitives)
</Admonition>