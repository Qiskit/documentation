---
title: Specify options
description: Specify options when building with Qiskit Runtime primitives

---

# Specify options

You can use options to customize the Estimator and Sampler primitives. This section focuses on how to specify Qiskit Runtime primitive options. While the interface of the primitives' `run()`  method is common across all implementations, their options are not. Consult the corresponding API references for information about the [`qiskit.primitives`](/api/qiskit/primitives#primitives) and [`qiskit_aer.primitives`](https://qiskit.github.io/qiskit-aer/apidocs/aer_primitives.html) options.

Options are specified differently depending on whether you are using the V1 or V2 interface.

## V2 primitives

Options are specified differently in the V2 primitives in these ways:

- `SamplerV2` and `EstimatorV2` have separate options classes. You can see the available options and update option values during or after primitive initialization.
- Instead of the `set_options()` method, V2 primitive options have the `update()` method that applies changes to the `options` attribute.
- If you do not specify a value for an option, it is given a special value of `Unset` and the server defaults are used.
- For V2 primitives, the `options` attribute is the `dataclass` Python type.  You can use the built-in `asdict` method to convert it to a dictionary.

## Instantiate the Options class (V1)

When using V1 primitives, you must Instantiate the options class before you can set the options. In the example below, we create an instance of the `Options` class. `optimization_level` is a first-level option and can be passed as an input parameter. Options related to the execution environment are passed using the `environment` parameter.

```python
from qiskit_ibm_runtime import Options

options = Options(optimization_level=1, environment={"log_level": "INFO"})
```

The `Options` class supports auto-complete. Once you create an instance of the `Options` class, you can use auto-complete to see what options are available. If you choose one of the categories, you can use auto-complete again to see what options are available under that category.

```python
from qiskit_ibm_runtime import Options

options = Options()
options.resilience_level = 1
options.execution.shots = 2048
```
<span id="pass-options"></span>
## Set primitive options

You can set options when initializing the primitive, after initializing the primitive, or in the `run()` method. See the [precidence rules](runtime-options-overview#options-precedence) section to understand what happens when the same option is specified in multiple places.

### Primitive initialization

You can pass in an instance of the options class or a dictionary when initializing a primitive.

#### Options class

When creating an instance of the `Estimator` or `Sampler` class, you can pass in the `options` you created in the options class. Those options will then be applied when you use `run()` to perform the calculation.  Specify the options in this format:  `primitive.options.option.sub-option.sub-sub-option = choice`.  For example: `estimator.options.dynamical_decoupling.enable = True`

Example:

<Tabs>
  <TabItem value="PrimV2" label="V2 primitives">
    `SamplerV2` and `EstimatorV2` have separate options classes ([`EstimatorOptions`](/api/qiskit-ibm-runtime/qiskit_ibm_runtime.options.EstimatorOptions) and [`SamplerOptions`](/api/qiskit-ibm-runtime/qiskit_ibm_runtime.options.SamplerOptions)) that do not need to be instantiated.

```python
estimator = Estimator(backend=backend)

estimator.options.resilience_level = 2
estimator.options.resilience.zne_mitigation = True
estimator.options.resilience.zne.noise_factors = [1, 3, 5]
```
  </TabItem>

  <TabItem value="PrimV1" label="V1 primitives">
```python
from qiskit_ibm_runtime import Estimator, Options

options = Options(resilience_level = 2)

# or...

options = Options()
options.resilience_level = 2

estimator = Estimator(session=backend, options=options)
```
  </TabItem>
</Tabs>

#### Dictionary

You can specify options as a dictionary when initializing the primitive.

<Tabs>
  <TabItem value="PrimV2" label="V2 primitives">
 ```python
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

# Setting options during primitive initialization
estimator = Estimator(backend, options={"resilience_level": 2})
```
  </TabItem>

  <TabItem value="PrimV1" label="V1 primitives">
 ```python
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import Estimator

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

# Setting options during primitive initialization
estimator = Estimator(backend, options={"resilience_level": 2})
```
  </TabItem>
</Tabs>

### Update options after initialization

<Tabs>
  <TabItem value="PrimV2" label="V2 primitives">
```python
# Setting options after primitive initialization
# This uses auto complete.
estimator.options.default_shots = 4000
# This does bulk update.
estimator.options.update(default_shots=4000, resilience_level=2)
```
  </TabItem>

  <TabItem value="PrimV1" label="V1 primitives">
```python
# Setting options after primitive initialization
# This uses auto complete.
options.resilience_level = 2
estimator = Estimator(backend=backend, options=options)

# Setting options after primitive initialization.
# This does bulk update.
estimator.set_options(shots=4000)
```
  </TabItem>
</Tabs>

<span id="run-method"></span>
### Run() method

The run() method accepts options in V1 only.

<Tabs>
  <TabItem value="PrimV2" label="V2 primitives">
In V2, the only values you can pass to `run()` are those defined in the interface.  That is, `shots` for Sampler and `precision` for Estimator. This overwrites any value set for `default_shots` or `default_precision` for the current run.

```python
# Sample two circuits at 128 shots each.
sampler.run([circuit1, circuit2], shots=128)
```

  </TabItem>

  <TabItem value="PrimV1" label="V1 primitives">
You can pass any options to `run()`. Because most users will only overwrite a few options at the job level, it is not necessary to specify the options category. The code below, for example, specifies `shots=1024` instead of `execution={"shots": 1024}` (which is also valid).
```python
estimator = Estimator(backend=backend, options=options)
result = estimator.run(circuit, observable, shots=1024).result()
print(f">>> Metadata: {result.metadata[0]}")
```
</TabItem>
</Tabs>

## Commonly used options

There are many available options, but the following are the most commonly used:

### Shots
For some algorithms, setting a specific number of shots is a core part of their routines.  There are several ways to set and update shots with the primitives.

<Tabs>
  <TabItem value="primitivesV2" label="V2 Primitives">
Shots (or precision) can be specified in multiple places in V2.  They are prioritized as follows:

For any Sampler pub:

1. Integer-valued shots contained in the pub
2. The `run(...,shots=val)` value
3. The `options.default_shots` value

For any Estimator pub:

1. Float-valued precision contained in the pub
2. The `run(...,precision=val)` value
3. The `options.default_shots` value
4. The `options.default_precision` value

Example:

```python
from qiskit_ibm_runtime import SamplerV2 as Sampler

# Setting shots during primitive initialization
sampler = Sampler(backend, options={"default_shots": 4096})

# Setting options after primitive initialization
# This uses auto complete.
sampler.options.default_shots=2000

# This does bulk update.  The value for default_shots is overridden if you specify shots with run() or in the PUB.
sampler.options.update(default_shots=1024, dynamical_decoupling={"sequence_type": "XpXm"})

# Sample two circuits at 128 shots each.
sampler.run([circuit1, circuit2], shots=128)
 ```
  </TabItem>

  <TabItem value="v1primitives" label="V1 Primitives">
Previously, shots could be set during the call to `backend.run()`. For example, `backend.run(shots=1024)`. Now, that setting is part of the execution
options ("second level option"). This can be done during the primitive setup:

```python
from qiskit_ibm_runtime import Estimator, Options

options = Options()
options.execution.shots = 1024

estimator = Estimator(session=backend, options=options)
```

If you need to modify the number of shots set between iterations (primitive calls), you can set the
shots directly in the `run()` method. This overwrites the initial `shots` setting.

```python
from qiskit_ibm_runtime import Estimator

estimator = Estimator(session=backend)

estimator.run(circuits=circuits, observables=observables, shots=50)

# other logic

estimator.run(circuits=circuits, observables=observables, shots=100)
```

For more information about the primitive options, refer to the
[Options class API reference](../api/qiskit-ibm-runtime/qiskit_ibm_runtime.options.Options).
</TabItem>
</Tabs>

### Maximum execution time

The maximum execution time (`max_execution_time`) limits how long a job can run.  If a job exceeds this time limit, it is forcibly cancelled.  This value applies to single jobs, whether they are run in job, session, or batch mode.

The value is set in seconds, based on quantum time (not wall clock time), which is the amount of time that the QPU is dedicated to processing your job.  It is ignored when using local testing mode because that mode does not have quantum time.

<Tabs>
  <TabItem value="PrimV2" label="V2 primitives">

```python
estimator = Estimator(mode=backend)

estimator.options.max_execution_time = 2500
```

  </TabItem>

  <TabItem value="PrimV1" label="V1 primitives">
```python
options = Options()
estimator.options.max_execution_time = 2500

estimator = Estimator(backend=backend)
```
</TabItem>
</Tabs>

<span id="no-error-mitigation"></span>
## Turn off all error mitigation and error suppression

You can turn off all error mitigation and suppression if you are, for example, doing research on your own mitigation techniques. To accomplish this, for EstimatorV2, set `resilience_level = 0`. For SamplerV2, no changes are necessary because no error mitigation or suppression options are enabled by default.

Example:

Turn off all error mitigation and suppression in EstimatorV2.

```python
from qiskit_ibm_runtime import EstimatorV2 as Estimator, Options, QiskitRuntimeService

# Define the service.  This allows you to access IBM QPU.
service = QiskitRuntimeService()

# Get a backend
backend = service.least_busy(operational=True, simulator=False)

# Define Estimator
estimator = Estimator(backend)

options = estimator.options

# Turn off all error mitigation and suppression
options.resilience_level = 0
```


## Next steps

<Admonition type="tip" title="Recommendations">
    - Find more details about the `Estimator` methods in the [Estimator API reference](../api/qiskit-ibm-runtime/qiskit_ibm_runtime.Estimator#estimator).
    - Find more details about the `Sampler` methods in the [Sampler API reference](../api/qiskit-ibm-runtime/qiskit_ibm_runtime.Sampler#sampler).
    - Find all available options in the [Options API reference](../api/qiskit-ibm-runtime/qiskit_ibm_runtime.options.Options).
    - Find details about how to configure [error suppression](configure-error-suppression) and [error mitigation](configure-error-mitigation).
    - Decide what [execution mode](execution-modes) to run your job in.
</Admonition>