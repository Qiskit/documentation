---
title: Tools and features index
description: Find resources relevant to your work, organized by task.
in_page_toc_min_heading_level: 2
in_page_toc_max_heading_level: 2

---

{/* cspell:ignore HUBO */}

# Tools and features index

## Map problem to circuits

<CardGroup>
    <Card
      title="Qiskit circuit library"
      description="Start with the Qiskit circuit library when beginning the process of constructing circuits and workloads. Available features range from standard single- and multi-qubit gates to pre-built ansatze, and also include custom unitary gates."
      href="/docs/guides/circuit-library"
      analyticsName="Tools index page: Circuit library"
      linkText="Read the guide"
    />

    <Card
      title="Optimization mapper"
      description="Optimization mapper is a Qiskit addon that contains the functionality to model optimization problems. For example, you can use it to create models of binary optimization problems to solve with Qiskit."
      href="https://qiskit.github.io/qiskit-addon-opt-mapper/"
      analyticsName="Tools index page: Optimization mapper"
      linkText="Browse the GitHub documentation"
    />

    <Card
      title="AQC-Tensor"
      description="A Qiskit addon that uses tensor network methods to compile the initial portion of a circuit into a nearly equivalent approximation, with many fewer layers. In addition to simulating the time evolution of a quantum system, this addon can also be useful in the following cases: your circuit's tensor-network simulation achieves a great intermediate state; and your circuit prepares an approximation to the target state, but with fewer layers when compiled to the target hardware device."
      href="/docs/guides/qiskit-addons-aqc"
      analyticsName="Tools index page: AQC-Tensor"
      linkText="Read the guide"
    />
    
    <Card
      title="Quantum optimization best practices"
      description="To get started building quantum workloads to solve optimization problems, refer to this community repository, which contains guidelines, best practices, and reference implementations for running quantum optimization algorithms."
      href="https://github.com/qiskit-community/qopt-best-practices"
      analyticsName="Tools index page: Optimization best practices"
      linkText="Explore the GitHub repository"
    />


</CardGroup>

## Prepare and optimize workloads

<CardGroup>
    <Card
      title="Transpiler"
      description="Once your circuits have been created, they then need to be transpiled against the QPU that will execute your workload. The Qiskit SDK has robust tooling for building custom transpilation pipelines that allow you to carefully tune which transformation and analysis passes are executed (and in which sequence). Note that the simplest way to get started is to use the pre-built pass managers."
      href="/docs/guides/transpile"
      analyticsName="Tools index page: transpiler"
      linkText="Read the guide"
    />

    <Card
      title="Dynamic circuits"
      description="Dynamic circuits are powerful tools for measuring qubits in the middle of a quantum circuit execution - and based on the outcome of those mid-circuit measurements, you can then perform classical logic operations within the circuit. Some common uses cases include efficient quantum state preparation, long-range entanglement, and sampling of instantaneous quantum polynomial-like circuits. "
      href="/docs/guides/classical-feedforward-and-control-flow"
      analyticsName="Tools index page: Dynamic circuits"
      linkText="Read the guide"
    />

    <Card
      title="Operator backpropagation (OBP)"
      description="This Qiskit addon utilizes a technique to reduce circuit depth by trimming operations from its end at the cost of more operator measurements. However, this increased cost can be lessened by dropping operators with small coefficients, which don't contribute much to the final estimation. You could experiment with coupling this alongside the AQC-Tensor addon for even lower circuit depths."
      href="/docs/guides/qiskit-addons-obp"
      analyticsName="Tools index page: OBP"
      linkText="Read the guide"
    />
</CardGroup>

## Debug

<CardGroup>

    <Card
      title="Noisy estimator analyzer tool (NEAT)"
      description="NEAT analyzes and predicts the performance of your queries when you are gauging the expected performance of estimator-based workloads. It uses Qiskit Aer to simulate the estimation task classically and efficiently, either exactly or in the presence of noise, and can also convert your Primitive Unified Blocs (PUBs) into Cliffordized circuits."
      href="/docs/guides/debug-qiskit-runtime-jobs"
      analyticsName="Tools index page: NEAT"
      linkText="Read the guide"
    />

    <Card
      title="Qiskit Runtime local testing mode"
      description="Qiskit Runtime can test workloads while fine-tuning them before submitting them to a QPU. To use this feature, simply specify one of the fake backends from `qiskit_ibm_runtime.fake_provider` or use one from the Qiskit Aer library. To utilize this feature, we suggest either Cliffordizing your circuit,  or scale down the number of qubits in your workload."
      href="/docs/guides/local-testing-mode"
      analyticsName="Tools index page: Local testing mode"
      linkText="Read the guide"
    />

</CardGroup>

## Execute on hardware

<CardGroup>

    <Card
      title="Estimator and Sampler primitives"
      description="The Estimator and Sampler primitives are used to execute your circuits on QPUs. Estimator computes expectation values of observables with respect to states prepared by quantum circuits, and Sampler samples the output register from quantum circuit execution. Both primitives have built-in error suppression support, and Estimator also has built-in error mitigation methods."
      href="/docs/guides/get-started-with-primitives"
      analyticsName="Tools index page: Primitives"
      linkText="Visit the primitives guides"
    />

    <Card
      title="Execution modes"
      description="Explore the different execution modes - scheduling strategies for execution - when building quantum workloads, to determine which one is most efficient for a specific workload."
      href="/docs/guides/execution-modes"
      analyticsName="Tools index page: Execution modes"
      linkText="Visit the execution modes guides"
    />

    <Card
      title="Directed execution model"
      description="Executor allows you to fine-tune error mitigation and other techniques without sacrificing performance, by providing the ingredients to capture design intents on the client-side, and shifting the costly generation of circuit variants to the server-side. With Executor, users will gain a clearer and more composable model for execution workflows, making it easier to experiment with new techniques, reproduce results, and share methods."
      href="/docs/guides/directed-execution-model"
      analyticsName="Tools index page: Executor"
      linkText="Read the guide"
    />

</CardGroup>

## Manage noise

<CardGroup>

    <Card
      title="Samplomatic"
      description="Samplomatic is a library for sampling randomizations of your quantum circuits in exactly the way that you specify. It utilizes the Qiskit SDK's `Box` annotations to specify regions of a circuit that should have similar noise profiles; it can also can group collections of gates to twirl, or use the same noise model from `NoiseLearner`."
      href="https://qiskit.github.io/samplomatic/"
      analyticsName="Tools index page: Samplomatic"
      linkText="Browse the GitHub documentation"
    />

    <Card
      title="NoiseLearner"
      description="Many error mitigation techniques, such as PEA and PEC, require an accurate noise model. `NoiseLearner` is a helper program that returns a Pauli-Lindblad noise model for the input circuit. You can then further tune how PEA and PEC are done in your Estimator job, or re-use the same model in an iterative workload."
      href="/docs/guides/noise-learning"
      analyticsName="Tools index page: NoiseLearner"
      linkText="Read the guide"
    />

    <Card
      title="Pauli twirling"
      description="Pauli twirling, also known as randomized compiling, is an error suppression technique used to convert the effects of unknown types of noise into one that can be characterized (and thus mitigated). "
      href="/docs/guides/error-mitigation-and-suppression-techniques#pauli-twirling"
      analyticsName="Tools index page: Pauli twirling"
      linkText="Read the guide"
    />

    <Card
      title="Matrix-free measurement mitigation (M3)"
      description="The Matrix-free measurement mitigation (M3) Qiskit addon is used to reduce measurement error by finding corrected measurement probabilities. Use it for problems that benefit from workloads that estimate the expectation value of observables. M3 also works in the context of dynamic circuits."
      href="https://qiskit.github.io/qiskit-addon-mthree/"
      analyticsName="Tools index page: mthree"
      linkText="Browse the GitHub documentation"
    />

    <Card
      title="Probabilistic error cancellation (PEC)"
      description="This error mitigation technique returns an unbiased estimate of the expectation value, at the expense of greater overhead than other techniques such as ZNE. It reproduces the output of the ideal circuit by executing different noisy circuit instances drawn from a random ensemble defined by the linear combination. The Qiskit Runtime Estimator primitive has built-in support for PEC, which you can enable through the Estimator option."
      href="/docs/guides/error-mitigation-and-suppression-techniques#probabilistic-error-cancellation-pec"
      analyticsName="Tools index page: PEC"
      linkText="Read the guide"
    />

    <Card
      title="Zero-noise extrapolation (ZNE)"
      description="This error mitigation technique first computes the expectation value at different noise levels, then estimates the ideal result by extrapolating the noisy expectation value results to the zero-noise limit. Since this can be done in multiple ways, a number of noise amplification and extrapolation techniques are available."
      href="/docs/guides/error-mitigation-and-suppression-techniques#zero-noise-extrapolation-zne"
      analyticsName="Tools index page: ZNE"
      linkText="Read the guide"
    />

    <Card
      title="Gate folding-based ZNE"
      description="Gate folding is a noise amplification process that replaces two-qubit gates with equivalent sequences of two-qubit gates and their inverses. This approach is straightforward and simple to use, but can be imperfect."
      href="/docs/api/qiskit-ibm-runtime/options-zne-options"
      analyticsName="Tools index page: Gate folding-based ZNE"
      linkText="Read the guide"
    />

    <Card
      title="Probabilistic error amplification (PEA)"
      description="Probabilistic error amplification is a more sophisticated means of amplifying errors for ZNE. It involves running preliminary experiments to learn a twirled noise model of the circuit, and then uses this model to perform a more accurate error amplification. "
      href="/docs/guides/error-mitigation-and-suppression-techniques#probabilistic-error-amplification-pea"
      analyticsName="Tools index page: PEA"
      linkText="Read the guide"
    />

    <Card
      title="Twirled readout error extinction (TREX)"
      description="This error mitigation technique is used to mitigate the effects of measurement errors by using twirled measurements. It can be used alongside many other techniques that mitigate gate errors, such as ZNE and PEC."
      href="/docs/guides/error-mitigation-and-suppression-techniques#twirled-readout-error-extinction-trex"
      analyticsName="Tools index page: TREX"
      linkText="Read the guide"
    />

    <Card
      title="Propagated noise absorption (PNA)"
      description="This Qiskit addon uses Pauli propagation to characterize Pauli noise affecting different layers of a circuit, by using a learned noise model and propagating its inverse into the target observable to measure."
      href="https://qiskit.github.io/qiskit-addon-pna/"
      analyticsName="Tools index page: PNA"
      linkText="Browse the GitHub documentation"
    />

    <Card
      title="Shaded lightcones (SLC)"
      description="The shaded lightcones (SLC) Qiskit addon uses Pauli propagation to reduce the number of error terms accounted for in a noise model, according to the specifics of the target observable. It is useful for reducing the sampling overhead when running PEC-based workloads."
      href="https://qiskit.github.io/qiskit-addon-slc/"
      analyticsName="Tools index page: SLC"
      linkText="Browse the GitHub documentation"
    />

    <Card
      title="Dynamical decoupling (DD)"
      description="A technique for suppressing errors due to qubit decoherence, DD is primarily useful in regions within a quantum circuit in which one or more qubits site idle while other instructions are being executed. Both Sampler and Estimator primitives have built-in support for applying DD. Alternatively, you can use the `PadDynamicalDecoupling` transpiler pass, or build your own using the new stretch instruction."
      href="/docs/guides/error-mitigation-and-suppression-techniques#dynamical-decoupling"
      analyticsName="Tools index page: DD"
      linkText="Read the guide"
    />

    <Card
      title="Sample-based quantum diagonalization (SQD)"
      description="With this Qiskit addon, you can implement a post-processing technique to measure the ground state energies of a quantum system. SQD processes samples from a given circuit to project and diagonalize a target Hamiltonian in a subspace spanned by them, essentially refining the results obtained from a workload. Use when you want to obtain the eigenvalues and eigenvectors of quantum systems (such as chemical or lattice models)."
      href="/docs/guides/qiskit-addons-sqd"
      analyticsName="Tools index page: SQD"
      linkText="Read the guide"
    />

    <Card
      title="SQD for HPC"
      description="This HPC-ready implementation of the SQD addon is written in modern C++17 standards and is designed to create a single compiled binary for use with MPI."
      href="https://qiskit.github.io/qiskit-addon-sqd-hpc/"
      analyticsName="Tools index page: SQD for HPC"
      linkText="Browse the GitHub documentation"
    />

    <Card
      title="Multi-product formulas (MPF)"
      description="This Qiskit addon post-processes workloads that simulate the time evolution of a quantum system. The MPF tool will ingest data such as the number of Trotter steps to prepare and solve an associated system of linear equations, which can then be used to refine the expectation-value measurements of a time-evolved state."
      href="/docs/guides/qiskit-addons-mpf"
      analyticsName="Tools index page:MPF"
      linkText="Read the guide"
    />

    <Card
      title="Measurement post-selection"
      description="The noise models produced by `NoiseLearner` might not be accurate for Heron backends due to non-Markovian noise on these devices. An internal study has shown this can be alleviated with measurement-based post-selection. This technique adds a series of RX gates followed by a measurement to the circuit, and in post-processing throws away the bad bitstrings. Implement with the Qiskit addon utilities package, or with `NoiseLearnerV3`. "
      href="/docs/api/qiskit-addon-utils/noise-management"
      analyticsName="Tools index page: Measurement post-selection"
      linkText="API reference"
    />

</CardGroup>

## Qiskit Functions

<CardGroup>

    <Card
      title="Q-CTRL Performance Management Function"
      description="This Qiskit Function by Q-CTRL Fire Opal uses AI-powered error suppression and mitigation techniques, and is agnostic to the type of workload being executed."
      href="/docs/guides/q-ctrl-performance-management"
      analyticsName="Tools index page: Performance management"
      linkText="Read the guide"
    />

    <Card
      title="Qedma Qiskit Function QESEM"
      description="This Qiskit Function uses a suite of proprietary error mitigation techniques to improve the results of your workload. These techniques include gate optimization, noise-aware transpilation, error suppression, and unbiased error mitigation."
      href="/docs/guides/qedma-qesem"
      analyticsName="Tools index page: QESEM"
      linkText="Read the guide"
    />

    <Card
      title="Iskay Quantum Optimizer"
      description="This Qiskit Function by Kipu Quantum solves unconstrained binary optimization problems with the  Quadratic Unconstrained Binary Optimization (QUBO) formulation and higher-order (HUBO) optimization problems."
      href="/docs/guides/kipu-optimization"
      analyticsName="Tools index page: Iskay"
      linkText="Read the guide"
    />

    <Card
      title="Q-CTRL Optimization Solver"
      description="This Qiskit Function by Q-CTRL is designed to solve utility-scale optimization problems. It takes in a high-level problem definition, and executes an entire workflow to optimize the problem, without manual configuration. "
      href="/docs/guides/q-ctrl-optimization-solver"
      analyticsName="Tools index page: Optimization solver"
      linkText="Read the guide"
    />

    <Card
      title="Algorithmiq Tensor-Network Error Mitigation Function"
      description="This function's method is a hybrid quantum-classical algorithm designed for automating and performing noise mitigation. It constructs a tensor network representing an approximate inverse of the noise affecting a circuit to obtain unbiased estimates of an observable."
      href="/docs/guides/algorithmiq-tem"
      analyticsName="Tools index page: Algorithmiq TEM"
      linkText="Read the guide"
    />
</CardGroup>