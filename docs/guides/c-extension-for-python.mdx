---
title: Extending Qiskit in Python with C
description: How to build a C extension for your Qiskit workflow in Python
---

# A little C with your Python

To accelerate your Qiskit Python programs with C, we can use Qiskit's C extension for Python.
This requires additional steps to the standalone C usage, see the [respective guide](./install-c-api).

<Admonition type="note">
  These instructions have only been tested on unix-based systems. Windows instructions are in progress._
</Admonition>

## Requirements

As base, we need the same requirements as the [C standalone usage](./install-c-api).
In addition we need to install Qiskit's Python interface,
```bash
pip install -r requirements.txt -c constraints.txt
pip install .
```

## Defining the C extension

There are various options to write a C extension for Python. Here, we will describe an approach
using Python's built-in [`ctypes`](https://docs.python.org/3/library/ctypes.html) module
which requires minimal overhead. See [below](#manual-c-extension) for another example which is
manually building the C extension using Python's C API.

As example, assume we write a C function to build an observable and would like to return
it to Python. We can convert a C-side `QkObs*` to a Python-side `SparseObservable` object
(both are backed by the same Rust data structure), using the provided converter
`qk_obs_to_python`:
```c
// file: extension.c
#define PY_SSIZE_T_CLEAN
#include <Python.h>  // include Python header for access to PyObject
#define QISKIT_C_PYTHON_INTERFACE  // enable C->Python conversion functions
#include <qiskit.h>

PyObject *build_observable(void) {
    QkObs *obs = qk_obs_zero(100);
    // build the observable ...
    PyObject *pyobj = qk_obs_to_python(obs); // convert to Qiskit's Python ``SparseObservable``
    qk_obs_free(obs);
    return pyobj;
}
```

Below we will show how to compile this into a shared library, say `qiskit_cextension.so`.
Once this is done, we will be able to call the C program from Python as
```python
# file: main.py
import qiskit
import ctypes

# Load the extension, ensuring the global interpreter lock (GIL) is acquired for function calls,
# which we need for the C->Python object conversion.
lib = ctypes.PyDLL("/path/to/qiskit_cextension.so")
lib.build_observable.argtypes = None  # set argument types to the function
lib.build_observable.restype = ctypes.py_object  # set return type

# now we can directly call the function
obs = lib.build_observable()
print("SparseObservable instance?", isinstance(obs, qiskit.quantum_info.SparseObservable))
print(obs)
```

## Building

First, we have to build Qiskit's Python extension. This will include the C symbols so we can
access both interfaces via the same shared library. This is important to ensure data ensured
across C and Python has the same ABI.
```bash
python setup.py build_rust --inplace --release
```
The shared library is called ``_accelerate.<platform-specific-part>``, whose location and name we can find as
```bash
QKLIB=$(python -c "import os; import qiskit; print(os.path.dirname(qiskit._accelerate.__file__))")
QKNAME=$(python -c "import os; import qiskit; print(os.path.basename(qiskit._accelerate.__file__))")
```

We will need to know the location of the environments Python includes (``Python.h``) and libraries (``libpython.<suffix>``).
These can, for example, be identified via
```bash
PYINCLUDE=$(python -c "import sysconfig; print(sysconfig.get_path('include'))")
PYLIB=$(python -c "import sysconfig; print(sysconfig.get_config_var('LIBDIR'))")
PYNAME=$(find $PYLIB -maxdepth 1 -name "libpython*" | grep -oE "[^/]+$" | grep -oE "python[0-9]+\.[0-9]+" || echo "python")
```
(If you just know these locations and names, you can also just set them directly.)

### Linux

Linking can slightly differ between platforms, here we first describe a solution for linkers
supporting libraries with arbitrary names, using the `-l:` flag. See below if your linker
requires the library to be called `lib<something>`.

We can build the extension specifying the full name of the `_accelerate` library:
```bash
gcc extension.c -fpic -shared -o cextension.so \
  -I/path/to/dist/c/include -L$QKLIB -l:$QKNAME \
  -I$PYINCLUDE -L$PYLIB -l$PYNAME
```
And then simply ``python main.py`` to run the Python program.

### MacOS

An alternative to using the exact library name with `-l:` is to symlink the `_accelerate` library
to the desired name. This solution works on Mac (and also Linux if you replace all occurences of `.dylib` with `.so`).
To include the `_accelerate` shared library we symlink it to the linkers expected format of `lib<library name>.<suffix>`,
```bash
ln -s $QKLIB/$QKNAME $QKLIB/libqiskit.dylib
```
which allows to use `qiskit` as library name:
```bash
gcc extension.c -fpic -shared -o qiskit_cextension.so \
  -I/path/to/dist/c/include -L$QKLIB -lqiskit \
  -I$PYINCLUDE -L$PYLIB -l$PYNAME
```
Then simply ``python main.py`` to run the Python program.

## Manual C extension

Instead of using `ctypes`, it is possible to manually build an extension for Python using [Python's
C API](https://docs.python.org/3/c-api/intro.html) directly. This has the potential to be
faster than using `ctypes`, albeit requires more effort to implement.
In the following we provide a brief example on how this can be achieved

```c
// file: extension.c
#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <stdio.h>
#define QISKIT_C_PYTHON_INTERFACE
#include <qiskit.h>

QkObs *build_observable() {
    // build a 100-qubit empty observable
    u_int32_t num_qubits = 100;
    QkObs *obs = qk_obs_zero(num_qubits);

    // add the term 2 * (X0 Y1 Z2) to the observable
    complex double coeff = 2;  // the coefficient
    QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};  // bit terms: X Y Z
    uint32_t indices[3] = {0, 1, 2};  // indices: 0 1 2
    QkObsTerm term = {coeff, 3, bit_terms, indices, num_qubits};
    qk_obs_add_term(obs, &term);  // append the term

    return obs;
}

/// Define the Python function, which will internally build the QkObs using the
/// C function defined above, and then convert the C object to the Python equivalent:
/// a SparseObservable, handled as PyObject.
static PyObject *cextension_build_observable(PyObject *self, PyObject *args) {
    // At this point, ``args`` could be parsed for arguments. See PyArg_ParseTuple for details.
    QkObs *obs = build_observable();  // call the C function to build the observable
    PyObject *py_obs = qk_obs_to_python(obs);  // convert QkObs to the Python-equivalent
    return py_obs;
}

/// Define the module methods.
static PyMethodDef CExtMethods[] = {
    {"build_observable", cextension_build_observable, METH_VARARGS, "Build an observable."},
    {NULL, NULL, 0, NULL}, // sentinel
};

/// Define the module, which we will call ``cextension``.
static struct PyModuleDef cextension = {
    PyModuleDef_HEAD_INIT,
    "cextension", // module name
    NULL,         // docs
    -1,           // keep the module state in global variables
    CExtMethods,
};

PyMODINIT_FUNC PyInit_cextension(void) { return PyModule_Create(&cextension); }

int main(int argc, char *argv[]) {
    PyStatus status;
    PyConfig config;
    PyConfig_InitPythonConfig(&config);

    // Add a built-in module, before Py_Initialize.
    if (PyImport_AppendInittab("cextension", PyInit_cextension) == -1) {
        fprintf(stderr, "Error: could not extend in-built modules table\n");
        exit(1);
    }

    // Pass argv[0] to the Python interpreter.
    status = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);
    if (PyStatus_Exception(status)) {
        goto exception;
    }

    // Initialize the Python interpreter.
    status = Py_InitializeFromConfig(&config);
    if (PyStatus_Exception(status)) {
        goto exception;
    }
    PyConfig_Clear(&config);

    // Import the module.
    PyObject *pmodule = PyImport_ImportModule("cextension");
    if (!pmodule) {
        PyErr_Print();
        fprintf(stderr, "Error: could not import module 'cextension'\n");
    }

    return 0;

exception:
    PyConfig_Clear(&config);
    Py_ExitStatusException(status);
}
```
To compile a shared library, we link both the Python and Qiskit libraries, as described in
the [Building](#building) section above. The Python script then does not need `ctypes`
but can directly import `cextension` module:
```python
# file: main.py
import qiskit
import cextension

# directly call the function
obs = cextension.build_observable()
print("SparseObservable instance?", isinstance(obs, qiskit.quantum_info.SparseObservable))
print(obs)
```
