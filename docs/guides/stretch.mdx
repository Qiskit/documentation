---
title: Deferred timing resolution using stretch
description: How to use stretch to defer timing resolution with dynamic circuits
---

# Deferred timing resolution using stretch

The OpenQASM 3 language specification contains a `stretch` type that lets you specify relative timing of operations instead of absolute timing. Support for `stretch` as durations for [`Delay`](/docs/api/qiskit/circuit#qiskit.circuit.Delay) instructions was added in [Qiskit v2.0.0.](/docs/api/qiskit/release-notes/2.0#200) The concrete value of a stretch duration is resolved at compile time, after the exact duration of calibrated gates are known.  The compiler tries to minimize the stretch duration, subject to timing constraints on one or more qubits. This lets you express gate designs such as evenly spacing gates (for example, to implement a higher-order echo decoupling sequence), left-aligning a sequence of gates, or applying a gate for the duration of some sub-circuit, without knowing the exact timing.

## Example

A common use case of `stretch` is to apply dynamical decoupling to an idling qubit while another qubit is undergoing conditional operations.

For example, we can use `stretch` to apply an XX dynamical decoupling sequence to qubit 1, for the duration of the conditional block applied to qubit 0, as illustrated by the following diagram:

![Image illustrating the following circuit](/docs/images/guides/stretch/stretch.avif)

The corresponding circuit would look like the following. Note that a pair of barriers is needed to define the boundaries of this relative timing.

```python
from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister

qubits = QuantumRegister(2)
clbits = ClassicalRegister(2)
circuit = QuantumCircuit(qubits, clbits)
(q0, q1) = qubits
(c0, c1) = clbits

# Add barriers to define the boundaries
circuit.barrier()
circuit.h(q0)
circuit.measure(q0, c0)
with circuit.if_test((c0, 1)) as else_:
    circuit.h(q0)
with else_:
    circuit.x(q0)

# Apply an XX DD sequence with stretch on qubit 1
s = circuit.add_stretch("s")
circuit.delay(s, q1)
circuit.x(q1)
circuit.delay(expr.mul(s, 2), q1)
circuit.x(q1)
circuit.delay(s, q1)
circuit.barrier()
```

Here is another example of using `stretch` to ensure a sequence of gates between two barriers are left-aligned, whatever their actual durations are:
```python
from qiskit import QuantumCircuit
from numpy import pi

qc = QuantumCircuit(5)
qc.barrier()
qc.cx(0, 1)
qc.u(pi/4, 0, pi/2, 2)
qc.cx(3, 4)

a = qc.add_stretch("a")
b = qc.add_stretch("b")
c = qc.add_stretch("c")

# Use the stretches as Delay duration.
qc.delay(a, [0, 1])
qc.delay(b, 2)
qc.delay(c, [3, 4])
qc.barrier()
```

## Limitations

The following constraints apply when using `stretch` in Qiskit Runtime:

- At most one stretch variable per _qubit set_ between barriers (implicit and explicit). A qubit set is one or more qubits; these sets must be mutually exclusive.
    <Tabs>
     <TabItem value="Valid" label="Valid">
        ```python
        a = circuit.add_stretch("a")
        b = circuit.add_stretch("b")
        circuit.delay(a, (q0, q1))
        circuit.delay(b, q2)
        ```
     </TabItem>

     <TabItem value="Invalid" label="Invalid">
        ```python
        stretch a;
        stretch b;
        delay[a] $0, $1;
        delay[b] $0;
        ```
     </TabItem>
    </Tabs>

- We call the area surrounded by a set of barriers a "barrier region". A stretch variable cannot be used in multiple barrier regions.
    <Tabs>
     <TabItem value="Valid" label="Valid">
        ```python
        barrier $0, $1;
        delay[a] $0;
        barrier $3;
        delay[a] $0;
        barrier $0, $1;
        ```
     </TabItem>

     <TabItem value="Invalid" label="Invalid">
        ```python
        barrier $0, $1;
        delay[a] $0;
        barrier $0, $1;
        delay[a] $0;
        barrier $0, $1;
         ```
     </TabItem>
    </Tabs>

- Stretch expressions are limited to those of the form `A*stretch + B` where `A` and `B` are floating point or integer constants.
    <Tabs>
     <TabItem value="Valid" label="Valid">
        ```python
        delay[2 * a + 3.0] $0;
        delay[a / 5 - 40.0] $0;
        delay[a + a] $0; # equivalent to "delay[2 * a] $0;"
        ```
     </TabItem>

     <TabItem value="Invalid" label="Invalid">
        ```python
        delay[2 * a * a] $0;
         ```
     </TabItem>
    </Tabs>

- Stretch expressions can only include a single stretch variable.
    <Tabs>
     <TabItem value="Valid" label="Valid">
        ```python
        xxxxxx
        ```
     </TabItem>

     <TabItem value="Invalid" label="Invalid">
        ```python
        stretch a;stretch b;
        delay[ a + b ] $0;delay[ a * b ] $0;
         ```
     </TabItem>
    </Tabs>

    Invalid:



- Stretch expressions cannot resolve to negative delay values.
    Invalid:

        ```python
        delay[a  - 40.0] $0; #if "a" resolves to a value <= 40.0
         ```

- Any remainder resulting from a stretch resolution is added to the first delay that uses the stretch.
    Example:

        ```python
        stretch a;
        barrier $0, $1;
        delay[100dt] $0;
        delay[a] $1; # resolves to 26
        x $1; # duration: 8
        delay[a] $1; # resolves to  25
        x $1; # duration: 8
        delay[a] $1; # resolves to  25
        x $1; # duration: 8
        barrier  $0, $1;
         ```

    The above code resolves to a value of 25 with a remainder of 1. The first delay`[a]` will have the remainder added.

    Stretch resolution equation:  $a + 8 + a + 8 + a + 8 = 100   =   3*a + 24$
